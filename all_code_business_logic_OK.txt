import 'package:isar/isar.dart';

part 'user_profile.g.dart';

@collection
class UserProfile {
  Id id = 0; // Р’СЃРµРіРґР° 0 РґР»СЏ РµРґРёРЅСЃС‚РІРµРЅРЅРѕР№ Р·Р°РїРёСЃРё РїСЂРѕС„РёР»СЏ

  String name = '';
  int age = 0;
  String gender = 'male'; // 'male', 'female', 'other'
  double weight = 0.0;
  
  int targetSystolic = 120;
  int targetDiastolic = 80;

  UserProfile({
    this.name = '',
    this.age = 0,
    this.gender = 'male',
    this.weight = 0.0,
    this.targetSystolic = 120,
    this.targetDiastolic = 80,
  });
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile.dart';

// **************************************************************************
// IsarCollectionGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: duplicate_ignore, non_constant_identifier_names, constant_identifier_names, invalid_use_of_protected_member, unnecessary_cast, prefer_const_constructors, lines_longer_than_80_chars, require_trailing_commas, inference_failure_on_function_invocation, unnecessary_parenthesis, unnecessary_raw_strings, unnecessary_null_checks, join_return_with_assignment, prefer_final_locals, avoid_js_rounded_ints, avoid_positional_boolean_parameters, always_specify_types

extension GetUserProfileCollection on Isar {
  IsarCollection<UserProfile> get userProfiles => this.collection();
}

const UserProfileSchema = CollectionSchema(
  name: r'UserProfile',
  id: 4738427352541298891,
  properties: {
    r'age': PropertySchema(
      id: 0,
      name: r'age',
      type: IsarType.long,
    ),
    r'gender': PropertySchema(
      id: 1,
      name: r'gender',
      type: IsarType.string,
    ),
    r'name': PropertySchema(
      id: 2,
      name: r'name',
      type: IsarType.string,
    ),
    r'targetDiastolic': PropertySchema(
      id: 3,
      name: r'targetDiastolic',
      type: IsarType.long,
    ),
    r'targetSystolic': PropertySchema(
      id: 4,
      name: r'targetSystolic',
      type: IsarType.long,
    ),
    r'weight': PropertySchema(
      id: 5,
      name: r'weight',
      type: IsarType.double,
    )
  },
  estimateSize: _userProfileEstimateSize,
  serialize: _userProfileSerialize,
  deserialize: _userProfileDeserialize,
  deserializeProp: _userProfileDeserializeProp,
  idName: r'id',
  indexes: {},
  links: {},
  embeddedSchemas: {},
  getId: _userProfileGetId,
  getLinks: _userProfileGetLinks,
  attach: _userProfileAttach,
  version: '3.1.0+1',
);

int _userProfileEstimateSize(
  UserProfile object,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  var bytesCount = offsets.last;
  bytesCount += 3 + object.gender.length * 3;
  bytesCount += 3 + object.name.length * 3;
  return bytesCount;
}

void _userProfileSerialize(
  UserProfile object,
  IsarWriter writer,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  writer.writeLong(offsets[0], object.age);
  writer.writeString(offsets[1], object.gender);
  writer.writeString(offsets[2], object.name);
  writer.writeLong(offsets[3], object.targetDiastolic);
  writer.writeLong(offsets[4], object.targetSystolic);
  writer.writeDouble(offsets[5], object.weight);
}

UserProfile _userProfileDeserialize(
  Id id,
  IsarReader reader,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  final object = UserProfile(
    age: reader.readLongOrNull(offsets[0]) ?? 0,
    gender: reader.readStringOrNull(offsets[1]) ?? 'male',
    name: reader.readStringOrNull(offsets[2]) ?? '',
    targetDiastolic: reader.readLongOrNull(offsets[3]) ?? 80,
    targetSystolic: reader.readLongOrNull(offsets[4]) ?? 120,
    weight: reader.readDoubleOrNull(offsets[5]) ?? 0.0,
  );
  object.id = id;
  return object;
}

P _userProfileDeserializeProp<P>(
  IsarReader reader,
  int propertyId,
  int offset,
  Map<Type, List<int>> allOffsets,
) {
  switch (propertyId) {
    case 0:
      return (reader.readLongOrNull(offset) ?? 0) as P;
    case 1:
      return (reader.readStringOrNull(offset) ?? 'male') as P;
    case 2:
      return (reader.readStringOrNull(offset) ?? '') as P;
    case 3:
      return (reader.readLongOrNull(offset) ?? 80) as P;
    case 4:
      return (reader.readLongOrNull(offset) ?? 120) as P;
    case 5:
      return (reader.readDoubleOrNull(offset) ?? 0.0) as P;
    default:
      throw IsarError('Unknown property with id $propertyId');
  }
}

Id _userProfileGetId(UserProfile object) {
  return object.id;
}

List<IsarLinkBase<dynamic>> _userProfileGetLinks(UserProfile object) {
  return [];
}

void _userProfileAttach(
    IsarCollection<dynamic> col, Id id, UserProfile object) {
  object.id = id;
}

extension UserProfileQueryWhereSort
    on QueryBuilder<UserProfile, UserProfile, QWhere> {
  QueryBuilder<UserProfile, UserProfile, QAfterWhere> anyId() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(const IdWhereClause.any());
    });
  }
}

extension UserProfileQueryWhere
    on QueryBuilder<UserProfile, UserProfile, QWhereClause> {
  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: id,
        upper: id,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idNotEqualTo(
      Id id) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            )
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            );
      } else {
        return query
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            )
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            );
      }
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idGreaterThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.greaterThan(lower: id, includeLower: include),
      );
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idLessThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.lessThan(upper: id, includeUpper: include),
      );
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idBetween(
    Id lowerId,
    Id upperId, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: lowerId,
        includeLower: includeLower,
        upper: upperId,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension UserProfileQueryFilter
    on QueryBuilder<UserProfile, UserProfile, QFilterCondition> {
  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageEqualTo(
      int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'age',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'age',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'age',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'age',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'gender',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderContains(
      String value,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderMatches(
      String pattern,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'gender',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'gender',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'gender',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idEqualTo(
      Id value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idGreaterThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idLessThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idBetween(
    Id lower,
    Id upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'id',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'name',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameContains(
      String value,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameMatches(
      String pattern,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'name',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'name',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      nameIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'name',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'targetDiastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'targetDiastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'targetDiastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'targetDiastolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'targetSystolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'targetSystolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'targetSystolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'targetSystolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> weightEqualTo(
    double value, {
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'weight',
        value: value,
        epsilon: epsilon,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      weightGreaterThan(
    double value, {
    bool include = false,
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'weight',
        value: value,
        epsilon: epsilon,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> weightLessThan(
    double value, {
    bool include = false,
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'weight',
        value: value,
        epsilon: epsilon,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> weightBetween(
    double lower,
    double upper, {
    bool includeLower = true,
    bool includeUpper = true,
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'weight',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        epsilon: epsilon,
      ));
    });
  }
}

extension UserProfileQueryObject
    on QueryBuilder<UserProfile, UserProfile, QFilterCondition> {}

extension UserProfileQueryLinks
    on QueryBuilder<UserProfile, UserProfile, QFilterCondition> {}

extension UserProfileQuerySortBy
    on QueryBuilder<UserProfile, UserProfile, QSortBy> {
  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByAge() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByAgeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByGender() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByGenderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByName() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByNameDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByTargetDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      sortByTargetDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByTargetSystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      sortByTargetSystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByWeight() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByWeightDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.desc);
    });
  }
}

extension UserProfileQuerySortThenBy
    on QueryBuilder<UserProfile, UserProfile, QSortThenBy> {
  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByAge() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByAgeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByGender() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByGenderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenById() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByIdDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByName() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByNameDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByTargetDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      thenByTargetDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByTargetSystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      thenByTargetSystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByWeight() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByWeightDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.desc);
    });
  }
}

extension UserProfileQueryWhereDistinct
    on QueryBuilder<UserProfile, UserProfile, QDistinct> {
  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByAge() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'age');
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByGender(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'gender', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByName(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'name', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct>
      distinctByTargetDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'targetDiastolic');
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByTargetSystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'targetSystolic');
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByWeight() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'weight');
    });
  }
}

extension UserProfileQueryProperty
    on QueryBuilder<UserProfile, UserProfile, QQueryProperty> {
  QueryBuilder<UserProfile, int, QQueryOperations> idProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'id');
    });
  }

  QueryBuilder<UserProfile, int, QQueryOperations> ageProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'age');
    });
  }

  QueryBuilder<UserProfile, String, QQueryOperations> genderProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'gender');
    });
  }

  QueryBuilder<UserProfile, String, QQueryOperations> nameProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'name');
    });
  }

  QueryBuilder<UserProfile, int, QQueryOperations> targetDiastolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'targetDiastolic');
    });
  }

  QueryBuilder<UserProfile, int, QQueryOperations> targetSystolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'targetSystolic');
    });
  }

  QueryBuilder<UserProfile, double, QQueryOperations> weightProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'weight');
    });
  }
}
import 'package:isar/isar.dart';
import '../../features/home/data/blood_pressure_model.dart';

class IsarService {
  final Isar isar;

  IsarService(this.isar);

  Stream<List<BloodPressureRecord>> listenToRecords() {
    return isar.bloodPressureRecords
        .where()
        .sortByDateTimeDesc()
        .watch(fireImmediately: true);
  }

  Future<void> saveRecord(BloodPressureRecord record) async {
    await isar.writeTxn(() async {
      await isar.bloodPressureRecords.put(record);
    });
  }
}
import 'package:get_it/get_it.dart';
import 'package:isar/isar.dart';
import 'package:blood_pressure_diary/features/home/presentation/bloc/home_bloc.dart';
import 'package:blood_pressure_diary/core/database/isar_service.dart';
import 'package:blood_pressure_diary/core/repositories/pressure_repository.dart';
import 'package:blood_pressure_diary/features/add_record/presentation/bloc/add_record_bloc.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_cubit.dart';
import 'package:blood_pressure_diary/features/profile/presentation/bloc/profile_cubit.dart';
import 'package:blood_pressure_diary/core/services/export_service.dart';
import 'package:blood_pressure_diary/core/services/notification_service.dart';

final getIt = GetIt.instance;

Future<void> setupLocator(Isar isar) async {
  getIt.registerSingleton<Isar>(isar);
  getIt.registerSingleton<IsarService>(IsarService(isar));
  getIt.registerSingleton<ExportService>(ExportService());
  
  final notificationService = NotificationService();
  await notificationService.initialize();
  getIt.registerSingleton<NotificationService>(notificationService);

  // 2. Р РµРїРѕР·РёС‚РѕСЂРёР№ (Р·Р°РІРёСЃРёС‚ РѕС‚ IsarService)
  getIt.registerLazySingleton<PressureRepository>(
        () => PressureRepository(getIt<IsarService>()),
  );

  // 3. BLoC (Р·Р°РІРёСЃРёС‚ РѕС‚ СЂРµРїРѕР·РёС‚РѕСЂРёСЏ)
  // РСЃРїРѕР»СЊР·СѓРµРј registerFactory, С‡С‚РѕР±С‹ РїСЂРё РєР°Р¶РґРѕРј РѕС‚РєСЂС‹С‚РёРё СЌРєСЂР°РЅР° Р±С‹Р» СЃРІРµР¶РёР№ BLoC
  getIt.registerFactory(() => HomeBloc(getIt<PressureRepository>()));
  getIt.registerFactory(() => AddRecordBloc(getIt<PressureRepository>()));
  getIt.registerFactory(() => ProfileCubit(getIt<Isar>()));
  
  // SettingsCubit РєР°Рє СЃРёРЅРіР»С‚РѕРЅ, С‡С‚РѕР±С‹ РЅР°СЃС‚СЂРѕР№РєРё Р±С‹Р»Рё РґРѕСЃС‚СѓРїРЅС‹ РІРµР·РґРµ
  // РџРµСЂРµРґР°РµРј HomeBloc С‡РµСЂРµР· Р°РЅРѕРЅРёРјРЅСѓСЋ С„СѓРЅРєС†РёСЋ, С‚Р°Рє РєР°Рє HomeBloc Р·Р°СЂРµРіРёСЃС‚СЂРёСЂРѕРІР°РЅ РєР°Рє Factory
  getIt.registerSingleton(SettingsCubit(
    isar,
    getIt<ExportService>(),
    getIt<NotificationService>(),
    homeBloc: getIt<HomeBloc>(),
  ));
}
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:get_it/get_it.dart';

import '../theme/scale.dart';

import '../../features/home/presentation/home_screen.dart';
import '../../features/home/presentation/statistics_screen.dart';
import '../../features/settings/presentation/settings_screen.dart';
import '../../features/profile/presentation/profile_screen.dart';
import '../../features/add_record/presentation/add_record_screen.dart';
import '../../features/home/presentation/bloc/home_bloc.dart';

import '../../features/profile/presentation/bloc/profile_cubit.dart';

class AppNavigation extends StatefulWidget {
  const AppNavigation({super.key});

  @override
  State<AppNavigation> createState() => _AppNavigationState();
}

class _AppNavigationState extends State<AppNavigation> {
  // 0 Home, 1 Stats, 2 Settings, 3 Profile
  int _selectedIndex = 0;

  void _openAddRecord() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => const AddRecordScreen()),
    );
  }

  void _onNavTap(int navIndex) {
    // navIndex: 0 Home, 1 Stats, 2 FAB, 3 Settings, 4 Profile
    if (navIndex == 2) {
      _openAddRecord();
      return;
    }
    final pageIndex = (navIndex < 2) ? navIndex : (navIndex - 1);
    setState(() => _selectedIndex = pageIndex);
  }

  @override
  Widget build(BuildContext context) {
    final pages = <Widget>[
      const HomeScreen(),
      const StatisticsScreen(),
      const SettingsScreen(),
      const ProfileScreen(),
    ];

    return MultiBlocProvider(
      providers: [
        BlocProvider(create: (_) => GetIt.I<HomeBloc>()),
        BlocProvider(create: (_) => GetIt.I<ProfileCubit>()..loadProfile()),
      ],
      child: Scaffold(
        backgroundColor: const Color(0xFFF0F4F8),
        body: IndexedStack(index: _selectedIndex, children: pages),
        bottomNavigationBar: _BottomNavBar(
          activeIndex: _selectedIndex,
          onTap: _onNavTap,
        ),
      ),
    );
  }
}

class _BottomNavBar extends StatelessWidget {
  final int activeIndex; // 0..3
  final ValueChanged<int> onTap; // 0..4 (2 is center)

  const _BottomNavBar({
    required this.activeIndex,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    const inactive = Color(0xFFBFD4E7);
    const active = Color(0xFF2E5D85);

    final barH = dp(context, 69);
    final icon = dp(context, 30);

    final outer = dp(context, 86);
    final inner = dp(context, 60);
    final plus = dp(context, 48);

    final lift = outer / 2;

    return SafeArea(
      top: false,
      child: SizedBox(
        height: barH + lift, // <- СЂР°СЃС€РёСЂРёР»Рё С‚РѕР»СЊРєРѕ С…РёС‚С‚РµСЃС‚, РќР• Р±Р°СЂ
        child: Stack(
          clipBehavior: Clip.none,
          alignment: Alignment.bottomCenter,
          children: [
            // Р¤РћРќ Р‘РђР Рђ вЂ” СЃС‚СЂРѕРіРѕ РІРЅРёР·Сѓ, РІС‹СЃРѕС‚Р° РЅРµ РјРµРЅСЏРµС‚СЃСЏ РІРёР·СѓР°Р»СЊРЅРѕ
            Positioned(
              left: 0,
              right: 0,
              bottom: 0,
              height: barH,
              child: Container(
                color: const Color(0xFFF9F8FA),
                child: Row(
                  children: [
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/house.svg',
                        size: icon,
                        color: activeIndex == 0 ? active : inactive,
                        onTap: () => onTap(0),
                      ),
                    ),
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/Vector.svg',
                        size: icon,
                        color: activeIndex == 1 ? active : inactive,
                        onTap: () => onTap(1),
                      ),
                    ),
                    SizedBox(width: outer),
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/settings.svg',
                        size: icon,
                        color: activeIndex == 2 ? active : inactive,
                        onTap: () => onTap(3),
                      ),
                    ),
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/user-pen.svg',
                        size: icon,
                        color: activeIndex == 3 ? active : inactive,
                        onTap: () => onTap(4),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            // FAB вЂ” РІРёР·СѓР°Р»СЊРЅРѕ РєР°Рє Р±С‹Р»Рѕ: РЅР°РїРѕР»РѕРІРёРЅСѓ РІС‹С€Рµ Р±Р°СЂР°
            Positioned(
              // РІРµСЂС… РєСЂСѓРіР° Р±СѓРґРµС‚ РЅР°Рґ Р±Р°СЂРѕРј, РЅРѕ РҐРРўРўР•РЎРў С‚РµРїРµСЂСЊ РІРЅСѓС‚СЂРё SizedBox(barH+lift)
              bottom: barH - lift,
              child: GestureDetector(
                behavior: HitTestBehavior.opaque,
                onTap: () => onTap(2),
                child: SizedBox(
                  width: outer,
                  height: outer,
                  child: _Fab(outer: outer, inner: inner, plus: plus),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


class _NavItem extends StatelessWidget {
  final String asset;
  final double size;
  final Color color;
  final VoidCallback onTap;

  const _NavItem({
    required this.asset,
    required this.size,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: onTap,
        behavior: HitTestBehavior.opaque,
        child: SizedBox(
          width: dp(context, 56),
          height: dp(context, 56),
          child: Center(
            child: SvgPicture.asset(
              asset,
              width: size,
              height: size,
              colorFilter: ColorFilter.mode(color, BlendMode.srcIn),
            ),
          ),
        ),
      ),
    );
  }
}

class _Fab extends StatelessWidget {
  final double outer;
  final double inner;
  final double plus;

  const _Fab({required this.outer, required this.inner, required this.plus});

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: outer,
      height: outer,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Container(
            width: outer,
            height: outer,
            decoration: BoxDecoration(
              color: const Color(0xFFF9F8FA),
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.08),
                  blurRadius: dp(context, 12),
                  offset: const Offset(0, 4),
                ),
              ],
            ),
          ),
          Container(
            width: inner,
            height: inner,
            decoration: const BoxDecoration(
              color: Color(0xFF2E5D85),
              shape: BoxShape.circle,
            ),
            child: Center(
              child: SvgPicture.asset(
                'assets/Plus.svg',
                width: plus,
                height: plus,
                colorFilter: const ColorFilter.mode(Colors.white, BlendMode.srcIn),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:isar/isar.dart';
import '../database/isar_service.dart';
import '../../features/home/data/blood_pressure_model.dart';

class PressureRepository {
  final IsarService _isarService;

  PressureRepository(this._isarService);

  // РЎС‚СЂРёРј РґР»СЏ РіР»Р°РІРЅРѕРіРѕ СЌРєСЂР°РЅР°
  Stream<List<BloodPressureRecord>> getAllRecordsStream() {
    return _isarService.isar.bloodPressureRecords
        .where()
        .sortByDateTimeDesc()
        .watch(fireImmediately: true);
  }

  // РњР•РўРћР” Р—РђРџРРЎР (РСЃРїСЂР°РІР»СЏРµС‚ РѕС€РёР±РєСѓ РІ AddRecordBloc)
  Future<void> addRecord(BloodPressureRecord record) async {
    await _isarService.isar.writeTxn(() async {
      await _isarService.isar.bloodPressureRecords.put(record);
    });
  }

  // РњРµС‚РѕРґ РґР»СЏ РїРѕР»СѓС‡РµРЅРёСЏ СЃРїРёСЃРєР° (РґР»СЏ Р°РЅР°Р»РёС‚РёРєРё РёР»Рё СЌРєСЃРїРѕСЂС‚Р°)
  Future<List<BloodPressureRecord>> getAllRecords() async {
    return await _isarService.isar.bloodPressureRecords
        .where()
        .sortByDateTimeDesc()
        .findAll();
  }

  // РњР•РўРћР” РЈР”РђР›Р•РќРРЇ (РїСЂРёРіРѕРґРёС‚СЃСЏ РґР»СЏ Dismissible)
  Future<void> deleteRecord(int id) async {
    await _isarService.isar.writeTxn(() async {
      await _isarService.isar.bloodPressureRecords.delete(id);
    });
  }
}
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:csv/csv.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:share_plus/share_plus.dart';
import 'package:intl/intl.dart';
import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';

enum ExportFormat { csv, pdf }

class ExportService {
  Future<void> exportData(List<BloodPressureRecord> records, ExportFormat format, String languageCode) async {
    if (format == ExportFormat.csv) {
      await _exportToCSV(records);
    } else {
      await _exportToPDF(records, languageCode);
    }
  }

  Future<void> _exportToCSV(List<BloodPressureRecord> records) async {
    final List<List<dynamic>> rows = [
      ['Date', 'Time', 'Systolic', 'Diastolic', 'Pulse', 'Note']
    ];

    for (var record in records) {
      rows.add([
        DateFormat('dd.MM.yyyy').format(record.dateTime),
        DateFormat('HH:mm').format(record.dateTime),
        record.systolic,
        record.diastolic,
        record.pulse,
        record.note ?? '',
      ]);
    }

    final csvContent = const ListToCsvConverter().convert(rows);
    final directory = await getTemporaryDirectory();
    final file = File('${directory.path}/blood_pressure_export.csv');
    await file.writeAsString(csvContent);

    await Share.shareXFiles([XFile(file.path)], text: 'Blood Pressure Export (CSV)');
  }

  Future<void> _exportToPDF(List<BloodPressureRecord> records, String languageCode) async {
    final pdf = pw.Document();

    // Р—Р°РіСЂСѓР·РєР° С€СЂРёС„С‚Р° Inter РґР»СЏ РїРѕРґРґРµСЂР¶РєРё РєРёСЂРёР»Р»РёС†С‹
    final fontData = await rootBundle.load("assets/fonts/Inter-Regular.ttf");
    final ttf = pw.Font.ttf(fontData);
    final boldFontData = await rootBundle.load("assets/fonts/Inter-Bold.ttf");
    final ttfBold = pw.Font.ttf(boldFontData);

    final isRu = languageCode == 'ru';
    final title = isRu ? 'Р”РЅРµРІРЅРёРє РґР°РІР»РµРЅРёСЏ' : 'Blood Pressure Diary';
    final headers = isRu 
        ? ['Р”Р°С‚Р°', 'Р’СЂРµРјСЏ', 'РЎРРЎ', 'Р”РРђ', 'РџСѓР»СЊСЃ', 'Р—Р°РјРµС‚РєР°']
        : ['Date', 'Time', 'SYS', 'DIA', 'Pulse', 'Note'];

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(32),
        build: (context) => [
          pw.Header(
            level: 0,
            child: pw.Row(
              mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
              children: [
                pw.Text(title, style: pw.TextStyle(font: ttfBold, fontSize: 24, color: PdfColors.blue900)),
                pw.Text(DateFormat('dd.MM.yyyy').format(DateTime.now()), style: pw.TextStyle(font: ttf, fontSize: 12)),
              ],
            ),
          ),
          pw.SizedBox(height: 20),
          pw.TableHelper.fromTextArray(
            headers: headers,
            data: records.map((r) => [
              DateFormat('dd.MM.yyyy').format(r.dateTime),
              DateFormat('HH:mm').format(r.dateTime),
              r.systolic.toString(),
              r.diastolic.toString(),
              r.pulse.toString(),
              r.note ?? '',
            ]).toList(),
            headerStyle: pw.TextStyle(font: ttfBold, color: PdfColors.white),
            headerDecoration: const pw.BoxDecoration(color: PdfColors.blue800),
            cellStyle: pw.TextStyle(font: ttf),
            cellAlignment: pw.Alignment.center,
            columnWidths: {
              0: const pw.FixedColumnWidth(80),
              1: const pw.FixedColumnWidth(60),
              2: const pw.FixedColumnWidth(40),
              3: const pw.FixedColumnWidth(40),
              4: const pw.FixedColumnWidth(50),
              5: const pw.FlexColumnWidth(),
            },
          ),
        ],
      ),
    );

    final directory = await getTemporaryDirectory();
    final file = File('${directory.path}/blood_pressure_export.pdf');
    await file.writeAsBytes(await pdf.save());

    await Share.shareXFiles([XFile(file.path)], text: 'Blood Pressure Export (PDF)');
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest_all.dart' as tz_data;
import 'package:permission_handler/permission_handler.dart';

class NotificationService {
  final FlutterLocalNotificationsPlugin _notificationsPlugin = FlutterLocalNotificationsPlugin();

  Future<void> initialize() async {
    tz_data.initializeTimeZones();
    
    const AndroidInitializationSettings androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const DarwinInitializationSettings iosSettings = DarwinInitializationSettings(
      requestAlertPermission: false,
      requestBadgePermission: false,
      requestSoundPermission: false,
    );

    const InitializationSettings settings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );

    await _notificationsPlugin.initialize(settings);
  }

  Future<bool> requestPermissions() async {
    if (await Permission.notification.request().isGranted) {
      return true;
    }
    return false;
  }

  Future<void> scheduleDailyNotification(int id, TimeOfDay time) async {
    final now = tz.TZDateTime.now(tz.local);
    var scheduledDate = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      time.hour,
      time.minute,
    );

    if (scheduledDate.isBefore(now)) {
      scheduledDate = scheduledDate.add(const Duration(days: 1));
    }

    await _notificationsPlugin.zonedSchedule(
      id,
      'РџРѕСЂР° РёР·РјРµСЂРёС‚СЊ РґР°РІР»РµРЅРёРµ',
      'РќРµ Р·Р°Р±СѓРґСЊС‚Рµ РІРЅРµСЃС‚Рё РґР°РЅРЅС‹Рµ РІ РґРЅРµРІРЅРёРє РґР»СЏ РєРѕРЅС‚СЂРѕР»СЏ Р·РґРѕСЂРѕРІСЊСЏ.',
      scheduledDate,
      const NotificationDetails(
        android: AndroidNotificationDetails(
          'blood_pressure_reminders',
          'РќР°РїРѕРјРёРЅР°РЅРёСЏ Рѕ РґР°РІР»РµРЅРёРё',
          channelDescription: 'Р•Р¶РµРґРЅРµРІРЅС‹Рµ СѓРІРµРґРѕРјР»РµРЅРёСЏ Рѕ РЅРµРѕР±С…РѕРґРёРјРѕСЃС‚Рё Р·Р°РјРµСЂР° РґР°РІР»РµРЅРёСЏ',
          importance: Importance.max,
          priority: Priority.high,
        ),
        iOS: DarwinNotificationDetails(),
      ),
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      uiLocalNotificationDateInterpretation: UILocalNotificationDateInterpretation.absoluteTime,
      matchDateTimeComponents: DateTimeComponents.time,
    );
  }

  Future<void> cancelNotification(int id) async {
    await _notificationsPlugin.cancel(id);
  }

  Future<void> cancelAllNotifications() async {
    await _notificationsPlugin.cancelAll();
  }
}
import 'package:flutter/material.dart';

class AppUI {
  static const double hPad = 20.0;
  static const double cardRadius = 5.0;
  static const double fieldRadius = 10.0;
  static const double fieldHeight = 48.0;
  static const double noteHeight = 72.0;
  static const double keypadButtonWidth = 96.0;
  static const double keypadButtonHeight = 48.0;
  static const double dateButtonWidth = 208.0;
  static const double timeButtonWidth = 96.0;
  static const double dateTextWidth = 184.0;
  static const double timeTextWidth = 57.0;
  static const double noteWidth = 320.0;
  
  static const Color primaryBlue = Color(0xFF3D8BFC);
  static const Color headerBlue = Color(0xFF4D83AC);
  static const Color buttonBlue = Color(0xFF2E5D85);
  static const Color summaryCardColor = Color(0xFF3973A2);
  static const Color background = Color(0xFFF0F4F8);
  
  static const Color textPrimary = Color(0xFF1C1C1C);
  static const Color textSecondary = Color(0xFF718096);
  static const Color textLight = Color(0xFFA0AEC0);
  static const Color textTime = Color(0xFF325674);
  
  static const Color accentRed = Color(0xFFDA3F3F);
  static const Color accentGreen = Color(0xFF3DBE65);
  static const Color accentBlue = Color(0xFF5A8EF6);
  static const Color accentOrange = Color(0xFFDD6B20);
  
  static const Color todayButtonColor = Color(0xFF6B9DC0);
  
  static const Color white = Color(0xFFFFFFFF);
  static const Color dividerColor = Color(0xFFE2E8F0);
  static const BoxShadow shadow4x2 = BoxShadow(
    offset: Offset(0, 2),
    blurRadius: 4,
    color: Color(0x1A000000),
  );
}

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      fontFamily: 'Inter',
      scaffoldBackgroundColor: AppUI.background,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppUI.primaryBlue,
        primary: AppUI.primaryBlue,
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppUI.cardRadius),
          side: BorderSide(color: Colors.grey.withValues(alpha: 0.1)),
        ),
        color: Colors.white,
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: AppUI.white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppUI.fieldRadius),
          borderSide: BorderSide.none,
        ),
        hintStyle: const TextStyle(color: Color(0xFF718096)),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppUI.buttonBlue,
          foregroundColor: AppUI.white,
          disabledBackgroundColor: const Color(0x1A000000),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppUI.fieldRadius),
          ),
          textStyle: const TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 20,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          backgroundColor: AppUI.white,
          foregroundColor: AppUI.buttonBlue,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppUI.fieldRadius),
          ),
          side: BorderSide(color: Colors.grey.withValues(alpha: 0.15)),
          padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 14),
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w400),
        ),
      ),
      textTheme: const TextTheme(
        titleLarge: TextStyle(fontFamily: 'Inter', fontSize: 24, fontWeight: FontWeight.w600),
        titleMedium: TextStyle(fontFamily: 'Inter', fontSize: 20, fontWeight: FontWeight.w600),
        bodyLarge: TextStyle(fontFamily: 'Inter', fontSize: 18, fontWeight: FontWeight.w400),
        bodyMedium: TextStyle(fontFamily: 'Inter', fontSize: 16, fontWeight: FontWeight.w400),
        labelLarge: TextStyle(fontFamily: 'Inter', fontSize: 14, fontWeight: FontWeight.w500),
      ),
    );
  }
}
import 'package:flutter/widgets.dart';

/// dp/sp scaling like in "frash":
/// base width = 360, clamp scale to [0.85..1.25]
double _uiScale(BuildContext context) {
  final w = MediaQuery.of(context).size.width;
  final s = w / 360.0;
  return s.clamp(0.85, 1.25).toDouble();
}

/// Density-independent pixels mapped to design pixels (Figma @ 360).
double dp(BuildContext context, double designPx) => designPx * _uiScale(context);

/// Scaled pixels for text.
double sp(BuildContext context, double designSp) => designSp * _uiScale(context);
class AppStrings {
  static const newRecord = 'РќРѕРІР°СЏ Р·Р°РїРёСЃСЊ';
  static const deleteRecordQ = 'РЈРґР°Р»РёС‚СЊ Р·Р°РїРёСЃСЊ?';
  static const cannotUndo = 'Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.';
  static const cancel = 'РћС‚РјРµРЅР°';
  static const delete = 'РЈРґР°Р»РёС‚СЊ';
  static const pickTime = 'Р’С‹Р±РµСЂРёС‚Рµ РІСЂРµРјСЏ';
  static const pickDate = 'Р’С‹Р±РµСЂРёС‚Рµ РґР°С‚Сѓ';
  static const systolicShort = 'РЎРёСЃС‚.';
  static const diastolicShort = 'Р”РёР°СЃС‚.';
  static const pulse = 'РџСѓР»СЊСЃ';
  static const commentHint = 'РљРѕРјРјРµРЅС‚Р°СЂРёР№';
  static const save = 'РЎРѕС…СЂР°РЅРёС‚СЊ';
  static const today = 'РЎРµРіРѕРґРЅСЏ';
  static const week = 'РќРµРґРµР»СЏ';
  static const month = 'РњРµСЃСЏС†';
  static const allShort = 'Р’СЃС‘';
  static const allTime = 'Р’СЃС‘ РІСЂРµРјСЏ';
  static const myDiary = 'РњРѕР№ РґРЅРµРІРЅРёРє';
  static String recordsWord(int n) {
    final nAbs = n.abs() % 100;
    final n1 = nAbs % 10;
    if (nAbs >= 11 && nAbs <= 19) return 'Р·Р°РїРёСЃРµР№';
    if (n1 == 1) return 'Р·Р°РїРёСЃСЊ';
    if (n1 >= 2 && n1 <= 4) return 'Р·Р°РїРёСЃРё';
    return 'Р·Р°РїРёСЃРµР№';
  }
}
import 'package:flutter/material.dart';

/// РЈС‚РёР»РёС‚С‹ РґР»СЏ РѕРїСЂРµРґРµР»РµРЅРёСЏ С†РІРµС‚Р° РёРЅРґРёРєР°С‚РѕСЂР° РґР°РІР»РµРЅРёСЏ
class BloodPressureColorUtils {
  /// РћРїСЂРµРґРµР»СЏРµС‚ С†РІРµС‚ РёРЅРґРёРєР°С‚РѕСЂР° РЅР° РѕСЃРЅРѕРІРµ СЃРёСЃС‚РѕР»РёС‡РµСЃРєРѕРіРѕ РґР°РІР»РµРЅРёСЏ
  /// РСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ РґР»СЏ РІРёР·СѓР°Р»СЊРЅРѕРіРѕ РѕС‚РѕР±СЂР°Р¶РµРЅРёСЏ СЃРѕСЃС‚РѕСЏРЅРёСЏ РґР°РІР»РµРЅРёСЏ РІ СЃРїРёСЃРєРµ
  static Color getIndicatorColor(int systolic) {
    if (systolic < 120) return Colors.green;
    if (systolic < 140) return Colors.orange;
    return Colors.red;
  }
}
class ValidationUtils {
  // Business Logic (README)
  static const int minSys = 50;
  static const int maxSys = 250;

  static const int minDia = 30;
  static const int maxDia = 150;

  static const int minPulse = 30;
  static const int maxPulse = 250;

  // DIA constraints
  static const int maxSysDiaDiff = 110; // SYS - DIA <= 110

  static int minDiaForSys(int sys) {
    final lo = (sys - maxSysDiaDiff) > minDia ? (sys - maxSysDiaDiff) : minDia;
    return lo;
  }

  static int maxDiaForSys(int sys) {
    final hi = (sys - 1) < maxDia ? (sys - 1) : maxDia;
    return hi;
  }


  static bool isFormValid({
    required String systolic,
    required String diastolic,
    required String pulse,
  }) {
    final sys = int.tryParse(systolic);
    final dia = int.tryParse(diastolic);
    final pul = int.tryParse(pulse);
    if (sys == null || dia == null || pul == null) return false;

    if (sys < minSys || sys > maxSys) return false;
    if (pul < minPulse || pul > maxPulse) return false;

    final (diaMin, diaMax) = diaRangeForSys(sys);
    if (dia < diaMin || dia > diaMax) return false;

    return true;
  }

  /// DIA must satisfy:
  /// - DIA in [30..150]
  /// - DIA < SYS
  /// - SYS - DIA <= 110
  static (int, int) diaRangeForSys(int sys) {
    // DIA >= max(30, SYS-110)
    final lo = (sys - maxSysDiaDiff) > minDia ? (sys - maxSysDiaDiff) : minDia;
    // DIA <= min(150, SYS-1)
    final hi = (sys - 1) < maxDia ? (sys - 1) : maxDia;
    return (lo, hi);
  }

  /// Returns the exact field length that completes input based on README rules.
  /// If currentText is empty, [nextDigit] is used to determine the target length.
  static int targetLengthFor({
    required String fieldType, // 'SYS' | 'DIA' | 'PUL'
    required String currentText,
    required String nextDigit,
  }) {
    final first = currentText.isEmpty ? nextDigit : currentText[0];

    switch (fieldType) {
      case 'SYS':
      // If starts with 1 or 2 -> 3 digits, if starts with 5-9 -> 2 digits
        return (first == '1' || first == '2') ? 3 : 2;
      case 'DIA':
      // If starts with 1 -> 3 digits, else (3-9) -> 2 digits
        return (first == '1') ? 3 : 2;
      case 'PUL':
      default:
      // README says: if starts with 1 or 2 -> 3 digits, else (3-9) -> 2 digits
        return (first == '1' || first == '2') ? 3 : 2;
    }
  }

  /// Returns true if [digit] can be appended to [currentText] for the given field,
  /// while keeping at least one reachable final number within the allowed range AND
  /// respecting the strict length rule (2 or 3 digits) from README.
  static bool isDigitAllowed({
    required String currentText,
    required String digit,
    required String fieldType, // 'SYS' | 'DIA' | 'PUL'
    int? systolicValue, // only for DIA
  }) {
    if (digit.length != 1) return false;
    final cu = digit.codeUnitAt(0);
    if (cu < 48 || cu > 57) return false;

    // no leading zero
    if (currentText.isEmpty && digit == '0') return false;

    final prefix = currentText + digit;

    // Determine target length (strict)
    final targetLen = targetLengthFor(
      fieldType: fieldType,
      currentText: currentText,
      nextDigit: digit,
    );

    if (prefix.length > targetLen) return false;

    final (minV, maxV) = _rangeForField(fieldType, systolicValue);

    // If prefix already complete -> must be within range
    if (prefix.length == targetLen) {
      final v = int.tryParse(prefix);
      if (v == null) return false;
      return v >= minV && v <= maxV;
    }

    // Otherwise check reachability of SOME number with this prefix and target length.
    final lo = _minWithPrefixLen(prefix, targetLen);
    final hi = _maxWithPrefixLen(prefix, targetLen);
    return !(hi < minV || lo > maxV);
  }

  static (int, int) _rangeForField(String fieldType, int? systolicValue) {
    switch (fieldType) {
      case 'SYS':
        return (minSys, maxSys);
      case 'DIA':
        if (systolicValue != null && systolicValue > 0) {
          return diaRangeForSys(systolicValue);
        }
        return (minDia, maxDia);
      case 'PUL':
      default:
        return (minPulse, maxPulse);
    }
  }

  static int _pow10(int n) {
    if (n <= 0) return 1;
    if (n == 1) return 10;
    if (n == 2) return 100;
    return 1000;
  }

  static int _minWithPrefixLen(String prefix, int totalLen) {
    final base = int.parse(prefix);
    final missing = totalLen - prefix.length;
    if (missing <= 0) return base;
    return base * _pow10(missing);
  }

  static int _maxWithPrefixLen(String prefix, int totalLen) {
    final base = int.parse(prefix);
    final missing = totalLen - prefix.length;
    if (missing <= 0) return base;
    final p = _pow10(missing);
    return base * p + (p - 1);
  }

  /// Auto-advance strictly by target length rule from README.
  static bool shouldAutoAdvanceByLength({
    required String currentText,
    required String fieldType,
  }) {
    if (currentText.isEmpty) return false;
    final first = currentText[0];
    final targetLen = switch (fieldType) {
      'SYS' => (first == '1' || first == '2') ? 3 : 2,
      'DIA' => (first == '1') ? 3 : 2,
      'PUL' => (first == '1' || first == '2') ? 3 : 2,
      _ => 3,
    };
    return currentText.length >= targetLen;
  }
}
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/repositories/pressure_repository.dart';
import '../../../home/data/blood_pressure_model.dart';
import 'add_record_event.dart';
import 'add_record_state.dart';

class AddRecordBloc extends Bloc<AddRecordEvent, AddRecordState> {
  final PressureRepository _repository;
  int? _editingId;

  // ===== Business Logic (README) =====
  static const int _minSys = 50;
  static const int _maxSys = 250;

  static const int _minDia = 30;
  static const int _maxDia = 150;

  static const int _minPulse = 20;
  static const int _maxPulse = 250;

  static const int _maxSysDiaDiff = 110; // SYS - DIA <= 110

  AddRecordBloc(this._repository) : super(AddRecordState()) {
    on<EditStarted>(_onEditStarted);
    on<NumberPressed>(_onNumberPressed);
    on<BackspacePressed>(_onBackspacePressed);
    on<FieldChanged>(_onFieldChanged);
    on<NoteChanged>((event, emit) => emit(state.copyWith(note: event.note)));
    on<SaveSubmitted>(_onSaveSubmitted);
    on<DeleteSubmitted>(_onDeleteSubmitted);
    on<DateTimeSet>((event, emit) => emit(state.copyWith(selectedDateTime: event.value)));

    // РљР РРўРР§РќРћ: РРЅРёС†РёР°Р»РёР·РёСЂСѓРµРј РєРЅРѕРїРєРё РґР»СЏ РїСѓСЃС‚РѕРіРѕ СЃРѕСЃС‚РѕСЏРЅРёСЏ СЃРёСЃС‚РѕР»С‹ СЃСЂР°Р·Сѓ
    add(FieldChanged(InputField.systolic));
  }

  void _onNumberPressed(NumberPressed event, Emitter<AddRecordState> emit) {
    // Safety: if keyboard pressed while no field active, start from SYS
    if (state.activeField == InputField.none) {
      final ns = state.copyWith(activeField: InputField.systolic);
      emit(ns);
      _updateEnabledKeys(emit, ns);
      return;
    }

    if (!state.enabledKeys.contains(event.number)) return;

    final cur = _getVal(state.activeField);
    final next = cur + event.number;

    // 1) РѕР±РЅРѕРІР»СЏРµРј Р·РЅР°С‡РµРЅРёРµ РїРѕР»СЏ
    final ns = _updateStateValue(state, state.activeField, next);

    // 2) Р°РІС‚Рѕ-РїРµСЂРµС…РѕРґ: С‡РёС‚Р°РµРј СѓР¶Рµ РёР· ns (Р° РЅРµ РёР· state)
    final nextField = _getAutoNextField(ns);

    if (nextField != ns.activeField) {
      final finalState = ns.copyWith(activeField: nextField);
      emit(finalState);
      _updateEnabledKeys(emit, finalState);
    } else {
      emit(ns);
      _updateEnabledKeys(emit, ns);
    }
  }

  InputField _getAutoNextField(AddRecordState s) {
    final val = _getValFrom(s, s.activeField);
    if (val.isEmpty) return s.activeField;

    if (s.activeField == InputField.systolic) {
      return _isCompleteByLengthRule(field: InputField.systolic, text: val)
          ? InputField.diastolic
          : s.activeField;
    }

    if (s.activeField == InputField.diastolic) {
      return _isCompleteByLengthRule(field: InputField.diastolic, text: val)
          ? InputField.pulse
          : s.activeField;
    }

    if (s.activeField == InputField.pulse) {
      return _isCompleteByLengthRule(field: InputField.pulse, text: val)
          ? InputField.none
          : s.activeField;
    }

    return s.activeField;
  }

  void _updateEnabledKeys(Emitter<AddRecordState> emit, AddRecordState s) {
    final val = _getValFrom(s, s.activeField);
    final sys = int.tryParse(s.systolic);

    final fieldType = switch (s.activeField) {
      InputField.systolic => 'SYS',
      InputField.diastolic => 'DIA',
      InputField.pulse => 'PUL',
      _ => 'SYS',
    };

    // Allowed digits: strict length rule + reachability in allowed range
    const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
    final allowed = <String>[];

    for (final d in digits) {
      if (_isDigitAllowed(
        currentText: val,
        digit: d,
        fieldType: fieldType,
        systolicValue: sys,
      )) {
        allowed.add(d);
      }
    }

    emit(s.copyWith(enabledKeys: allowed));
  }

  void _onFieldChanged(FieldChanged event, Emitter<AddRecordState> emit) {
    final ns = state.copyWith(activeField: event.field);
    emit(ns);
    _updateEnabledKeys(emit, ns);
  }

  String _getValFrom(AddRecordState s, InputField field) {
    if (field == InputField.systolic) return s.systolic;
    if (field == InputField.diastolic) return s.diastolic;
    if (field == InputField.pulse) return s.pulse;
    return '';
  }

  // Backward-compatible helper: read from current bloc state
  String _getVal(InputField field) => _getValFrom(state, field);

  // ===== README helpers =====

  (int, int) _diaRangeForSys(int sys) {
    final lo = (sys - _maxSysDiaDiff) > _minDia ? (sys - _maxSysDiaDiff) : _minDia;
    final hi = (sys - 1) < _maxDia ? (sys - 1) : _maxDia;
    return (lo, hi);
  }

  int _targetLenFor({
    required String fieldType,
    required String currentText,
    required String nextDigit,
  }) {
    final first = currentText.isEmpty ? nextDigit : currentText[0];
    switch (fieldType) {
      case 'SYS':
      // 1/2 -> 3 digits, 5-9 -> 2 digits
        return (first == '1' || first == '2') ? 3 : 2;
      case 'DIA':
      // 1 -> 3 digits, 3-9 -> 2 digits
        return (first == '1') ? 3 : 2;
      case 'PUL':
      default:
      // README: 1/2 -> 3 digits, 3-9 -> 2 digits
        return (first == '1' || first == '2') ? 3 : 2;
    }
  }

  bool _isCompleteByLengthRule({required InputField field, required String text}) {
    if (text.isEmpty) return false;
    final t = switch (field) {
      InputField.systolic => 'SYS',
      InputField.diastolic => 'DIA',
      InputField.pulse => 'PUL',
      _ => 'SYS',
    };

    // nextDigit С‚СѓС‚ РЅРµ РІР°Р¶РµРЅ (РїРµСЂРµРґР°С‘Рј first char, С‡С‚РѕР±С‹ РїРѕР»СѓС‡РёС‚СЊ target length)
    final target = _targetLenFor(fieldType: t, currentText: text, nextDigit: text[0]);
    return text.length >= target;
  }

  (int, int) _rangeForField(String fieldType, int? systolicValue) {
    switch (fieldType) {
      case 'SYS':
        return (_minSys, _maxSys);
      case 'DIA':
        if (systolicValue != null && systolicValue > 0) {
          return _diaRangeForSys(systolicValue);
        }
        return (_minDia, _maxDia);
      case 'PUL':
      default:
        return (_minPulse, _maxPulse);
    }
  }

  int _pow10(int n) {
    if (n <= 0) return 1;
    if (n == 1) return 10;
    if (n == 2) return 100;
    return 1000;
  }

  int _minWithPrefixLen(String prefix, int totalLen) {
    final base = int.parse(prefix);
    final missing = totalLen - prefix.length;
    if (missing <= 0) return base;
    return base * _pow10(missing);
  }

  int _maxWithPrefixLen(String prefix, int totalLen) {
    final base = int.parse(prefix);
    final missing = totalLen - prefix.length;
    if (missing <= 0) return base;
    final p = _pow10(missing);
    return base * p + (p - 1);
  }

  bool _isDigitAllowed({
    required String currentText,
    required String digit,
    required String fieldType,
    required int? systolicValue,
  }) {
    if (digit.length != 1) return false;
    final cu = digit.codeUnitAt(0);
    if (cu < 48 || cu > 57) return false;

    // no leading zero
    if (currentText.isEmpty && digit == '0') return false;

    final prefix = currentText + digit;
    final targetLen = _targetLenFor(fieldType: fieldType, currentText: currentText, nextDigit: digit);
    if (prefix.length > targetLen) return false;

    final (minV, maxV) = _rangeForField(fieldType, systolicValue);

    // If complete by strict length -> must be in range
    if (prefix.length == targetLen) {
      final v = int.tryParse(prefix);
      if (v == null) return false;
      return v >= minV && v <= maxV;
    }

    // Otherwise: must be reachable (some number with this prefix, length=targetLen, lies in range)
    final lo = _minWithPrefixLen(prefix, targetLen);
    final hi = _maxWithPrefixLen(prefix, targetLen);
    return !(hi < minV || lo > maxV);
  }

  AddRecordState _updateStateValue(AddRecordState s, InputField f, String v) {
    if (f == InputField.systolic) return s.copyWith(systolic: v);
    if (f == InputField.diastolic) return s.copyWith(diastolic: v);
    if (f == InputField.pulse) return s.copyWith(pulse: v);
    return s;
  }

  void _onBackspacePressed(BackspacePressed event, Emitter<AddRecordState> emit) {
    final cur = _getVal(state.activeField);
    if (cur.isEmpty) {
      _autoPrevField(emit);
      return;
    }

    final next = cur.substring(0, cur.length - 1);
    final ns = _updateStateValue(state, state.activeField, next);
    emit(ns);
    _updateEnabledKeys(emit, ns);
  }

  void _autoPrevField(Emitter<AddRecordState> emit) {
    InputField prev = state.activeField;
    if (state.activeField == InputField.diastolic) {
      prev = InputField.systolic;
    } else if (state.activeField == InputField.pulse) {
      prev = InputField.diastolic;
    }

    if (prev != state.activeField) {
      final ns = state.copyWith(activeField: prev);
      emit(ns);
      _updateEnabledKeys(emit, ns);
    }
  }

  void _onEditStarted(EditStarted event, Emitter<AddRecordState> emit) {
    _editingId = event.record.id;
    final s = state.copyWith(
      systolic: event.record.systolic.toString(),
      diastolic: event.record.diastolic.toString(),
      pulse: event.record.pulse.toString(),
      note: event.record.note,
      selectedDateTime: event.record.dateTime,
      activeField: InputField.systolic,
    );
    emit(s);
    _updateEnabledKeys(emit, s);
  }

  Future<void> _onSaveSubmitted(SaveSubmitted event, Emitter<AddRecordState> emit) async {
    final sys = int.tryParse(state.systolic) ?? 0;
    final dia = int.tryParse(state.diastolic) ?? 0;
    final pul = int.tryParse(state.pulse) ?? 0;
    if (sys == 0 || dia == 0 || pul == 0) return;

    final record = BloodPressureRecord()
      ..systolic = sys
      ..diastolic = dia
      ..pulse = pul
      ..dateTime = state.selectedDateTime
      ..note = state.note;

    if (_editingId != null) record.id = _editingId!;
    await _repository.addRecord(record);
    emit(state.copyWith(shouldClose: true));
  }

  Future<void> _onDeleteSubmitted(DeleteSubmitted event, Emitter<AddRecordState> emit) async {
    if (_editingId == null) return;
    await _repository.deleteRecord(_editingId!);
    emit(state.copyWith(shouldClose: true));
  }
}
import 'package:equatable/equatable.dart';
import 'add_record_state.dart';
// РРјРїРѕСЂС‚РёСЂСѓРµРј РјРѕРґРµР»СЊ, С‡С‚РѕР±С‹ СЃРѕР±С‹С‚РёРµ EditStarted Р·РЅР°Р»Рѕ Рѕ BloodPressureRecord
import '../../../home/data/blood_pressure_model.dart';

abstract class AddRecordEvent extends Equatable {
  const AddRecordEvent();
  @override
  List<Object?> get props => [];
}

// РЎРћР‘Р«РўРР• Р”Р›РЇ Р Р•Р”РђРљРўРР РћР’РђРќРРЇ
class EditStarted extends AddRecordEvent {
  final BloodPressureRecord record;
  const EditStarted(this.record);

  @override
  List<Object?> get props => [record];
}

class NumberPressed extends AddRecordEvent {
  final String number;
  const NumberPressed(this.number);
  @override
  List<Object?> get props => [number];
}

class BackspacePressed extends AddRecordEvent {}

class FieldChanged extends AddRecordEvent {
  final InputField field;
  const FieldChanged(this.field);
  @override
  List<Object?> get props => [field];
}

// РЎРћР‘Р«РўРР• Р”Р›РЇ Р—РђРњР•РўРћРљ
class NoteChanged extends AddRecordEvent {
  final String note;
  const NoteChanged(this.note);

  @override
  List<Object?> get props => [note];
}

class EmotionChanged extends AddRecordEvent {
  final String emotion;
  const EmotionChanged(this.emotion);
  @override
  List<Object?> get props => [emotion];
}

class EmojiAppended extends AddRecordEvent {
  final String emoji;
  const EmojiAppended(this.emoji);

  @override
  List<Object?> get props => [emoji];
}

class SaveSubmitted extends AddRecordEvent {}
class DeleteSubmitted extends AddRecordEvent {}

class DateTimeSet extends AddRecordEvent {
  final DateTime value;
  const DateTimeSet(this.value);
  @override
  List<Object?> get props => [value];
}
import 'package:equatable/equatable.dart';
import '../../../../core/utils/validation_utils.dart';

enum InputField { systolic, diastolic, pulse, none }

class AddRecordState extends Equatable {
  final String systolic;
  final String diastolic;
  final String pulse;
  final String note;
  final DateTime selectedDateTime;
  final InputField activeField;
  final bool shouldClose;
  final List<String> enabledKeys; // РџРѕР»Рµ РґР»СЏ СѓРјРЅРѕР№ РєР»Р°РІРёР°С‚СѓСЂС‹

  AddRecordState({
    this.systolic = '',
    this.diastolic = '',
    this.pulse = '',
    this.note = '',
    DateTime? selectedDateTime,
    this.activeField = InputField.systolic,
    this.shouldClose = false,
    this.enabledKeys = const ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
  }) : selectedDateTime = selectedDateTime ?? DateTime.now();

  /// РџСЂРѕРІРµСЂСЏРµС‚, РІР°Р»РёРґРЅР° Р»Рё С„РѕСЂРјР°
  bool get isValid => ValidationUtils.isFormValid(
        systolic: systolic,
        diastolic: diastolic,
        pulse: pulse,
      );

  bool get systolicValid {
    final v = int.tryParse(systolic);
    if (v == null) return false;
    return v >= ValidationUtils.minSys && v <= ValidationUtils.maxSys;
  }

  bool get diastolicValid {
    final d = int.tryParse(diastolic);
    if (d == null) return false;

    final s = int.tryParse(systolic);
    if (s == null) {
      return d >= ValidationUtils.minDia &&
          d <= ValidationUtils.maxDia;
    }

    final minDia = ValidationUtils.minDiaForSys(s);
    final maxDia = ValidationUtils.maxDiaForSys(s);

    return d >= minDia && d <= maxDia;
  }



  bool get pulseValid {
    final p = int.tryParse(pulse);
    if (p == null) return false;
    return p >= ValidationUtils.minPulse && p <= ValidationUtils.maxPulse;
  }

  AddRecordState copyWith({
    String? systolic,
    String? diastolic,
    String? pulse,
    String? note,
    DateTime? selectedDateTime,
    InputField? activeField,
    bool? shouldClose,
    List<String>? enabledKeys,
  }) {
    return AddRecordState(
      systolic: systolic ?? this.systolic,
      diastolic: diastolic ?? this.diastolic,
      pulse: pulse ?? this.pulse,
      note: note ?? this.note,
      selectedDateTime: selectedDateTime ?? this.selectedDateTime,
      activeField: activeField ?? this.activeField,
      shouldClose: shouldClose ?? this.shouldClose,
      enabledKeys: enabledKeys ?? this.enabledKeys,
    );
  }

  @override
  List<Object?> get props => [
    systolic,
    diastolic,
    pulse,
    note,
    selectedDateTime,
    activeField,
    shouldClose,
    enabledKeys,
  ];
}
import 'package:flutter/material.dart';

class CustomKeypad extends StatelessWidget {
  final Function(String) onKeyPressed;
  final VoidCallback onDeletePressed;
  final List<String>? enabledKeys;

  /// РњРµС‚СЂРёРєРё РёР· СЌРєСЂР°РЅР° (С‚Р°РєРёРµ Р¶Рµ, РєР°Рє Сѓ _ValuePill)
  final double horizontalPadding;
  final double gap;
  final double cellHeight;
  final double radius;

  /// (РѕРїС†РёРѕРЅР°Р»СЊРЅРѕ) СЃС‚РёР»РёР·Р°С†РёСЏ РїРѕРґ РІР°С€ UI
  final Color background;
  final Color deleteBackground;
  final Color foreground;
  final TextStyle textStyle;

  const CustomKeypad({
    super.key,
    required this.onKeyPressed,
    required this.onDeletePressed,
    this.enabledKeys, // <-- Р”РћР‘РђР’Р¬ Р­РўРЈ РЎРўР РћРљРЈ
    required this.horizontalPadding,
    required this.gap,
    required this.cellHeight,
    required this.radius,
    this.background = const Color(0xFFFFFFFF),
    this.deleteBackground = const Color(0xFFE5E7EB),
    this.foreground = const Color(0xFF2E5D85),
    this.textStyle = const TextStyle(fontSize: 24, fontWeight: FontWeight.w800, height: 1.0),
  });

  @override
  Widget build(BuildContext context) {
    final keys = <String>['1', '2', '3', '4', '5', '6', '7', '8', '9', '', '0', 'delete'];

    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        mainAxisExtent: cellHeight,
        mainAxisSpacing: gap,
        crossAxisSpacing: gap,
      ),
      itemCount: keys.length,
      itemBuilder: (context, index) {
        final key = keys[index];
        if (key.isEmpty) return const SizedBox.shrink();

        final isDelete = key == 'delete';

        // Р“Р›РђР’РќРђРЇ Р›РћР“РРљРђ РўРЈРў:
        // Р•СЃР»Рё СЌС‚Рѕ РєРЅРѕРїРєР° СѓРґР°Р»РµРЅРёСЏ - РѕРЅР° РІСЃРµРіРґР° Р°РєС‚РёРІРЅР°.
        // Р•СЃР»Рё С†РёС„СЂР° - РїСЂРѕРІРµСЂСЏРµРј, РµСЃС‚СЊ Р»Рё РѕРЅР° РІ СЃРїРёСЃРєРµ СЂР°Р·СЂРµС€РµРЅРЅС‹С….
        final bool isEnabled = isDelete ||
            (enabledKeys == null) ||
            enabledKeys!.contains(key);

        return Opacity(
          opacity: isEnabled ? 1.0 : 0.3, // "Р“Р°СЃРёРј" РєРЅРѕРїРєСѓ РІРёР·СѓР°Р»СЊРЅРѕ
          child: ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: isDelete ? deleteBackground : background,
              foregroundColor: foreground,
              elevation: 0,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(radius),
              ),
            ),
            // Р•СЃР»Рё РєРЅРѕРїРєР° РЅРµ Р°РєС‚РёРІРЅР°, РїРµСЂРµРґР°РµРј null РІ onPressed, Рё Flutter СЃР°Рј РµС‘ РѕС‚РєР»СЋС‡РёС‚
            onPressed: isEnabled
                ? () => isDelete ? onDeletePressed() : onKeyPressed(key)
                : null,
            child: isDelete
                ? const Icon(Icons.backspace_outlined)
                : Text(key, style: textStyle),
          ),
        );
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:get_it/get_it.dart';
import 'package:intl/intl.dart';

import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';

import '../../../../core/theme/app_theme.dart';
import '../../../../core/theme/scale.dart';
import '../../../../core/utils/app_strings.dart';
import 'bloc/add_record_bloc.dart';
import 'bloc/add_record_event.dart';
import 'bloc/add_record_state.dart';
import 'widgets/custom_keypad.dart';

class AddRecordScreen extends StatelessWidget {
  final BloodPressureRecord? record;

  const AddRecordScreen({super.key, this.record});

  @override
  Widget build(BuildContext context) {
    debugPrint(
      '### AddRecordScreen BUILD from: lib/features/add_record/presentation/add_record_screen.dart',
    );

    return BlocProvider(
      create: (_) {
        final bloc = GetIt.I<AddRecordBloc>();
        if (record != null) {
          bloc.add(EditStarted(record!));
        }
        return bloc;
      },
      child: AddRecordView(isEditing: record != null),
    );
  }
}

class AddRecordView extends StatefulWidget {
  final bool isEditing;

  const AddRecordView({super.key, required this.isEditing});

  @override
  State<AddRecordView> createState() => _AddRecordViewState();
}

class _AddRecordViewState extends State<AddRecordView> {
  final TextEditingController _noteController = TextEditingController();
  final FocusNode _noteFocusNode = FocusNode();

  double _snapFloor(BuildContext c, double v) {
    final dpr = MediaQuery.of(c).devicePixelRatio;
    return (v * dpr).floorToDouble() / dpr;
  }

  @override
  void initState() {
    super.initState();
    _noteFocusNode.addListener(() {
      if (_noteFocusNode.hasFocus) {
        context.read<AddRecordBloc>().add(const FieldChanged(InputField.none));
      }
    });
  }

  @override
  void dispose() {
    _noteController.dispose();
    _noteFocusNode.dispose();
    super.dispose();
  }

  Future<void> _pickTime(BuildContext context, DateTime current) async {
    final picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(current),
      helpText: AppStrings.pickTime,
    );
    if (picked == null) return;
    if (!context.mounted) return;

    final merged = DateTime(
      current.year,
      current.month,
      current.day,
      picked.hour,
      picked.minute,
    );
    context.read<AddRecordBloc>().add(DateTimeSet(merged));
  }

  Future<void> _pickDate(BuildContext context, DateTime current) async {
    final picked = await showDatePicker(
      context: context,
      initialDate: current,
      firstDate: DateTime(current.year - 1),
      lastDate: DateTime(current.year + 1),
      helpText: AppStrings.pickDate,
    );
    if (picked == null) return;
    if (!context.mounted) return;

    final merged = DateTime(
      picked.year,
      picked.month,
      picked.day,
      current.hour,
      current.minute,
    );
    context.read<AddRecordBloc>().add(DateTimeSet(merged));
  }

  Future<void> _confirmDelete(BuildContext context) async {
    final ok = await showDialog<bool>(
      context: context,
      builder: (ctx) {
        return AlertDialog(
          title: const Text(AppStrings.deleteRecordQ),
          content: const Text(AppStrings.cannotUndo),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: const Text(AppStrings.cancel, style: TextStyle(color: AppUI.buttonBlue)),
            ),
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: const Text(AppStrings.delete, style: TextStyle(color: AppUI.accentRed)),
            ),
          ],
        );
      },
    );

    if (ok == true && context.mounted) {
      context.read<AddRecordBloc>().add(DeleteSubmitted());
    }
  }

  Widget _buildHeader({
    required BuildContext context,
    required bool isEditing,
    required VoidCallback onClose,
    required VoidCallback onDelete,
  }) {
    final pad = dp(context, 20);
    final topInset = MediaQuery.paddingOf(context).top;

    // Р’РђР–РќРћ: 128dp + СЃС‚Р°С‚СѓСЃ-Р±Р°СЂ
    final headerHeight = topInset + dp(context, 128);

    return Container(
      height: headerHeight,
      width: double.infinity,
      color: AppUI.headerBlue,
      padding: EdgeInsets.only(
        left: pad,
        right: pad,
        top: dp(context, 8) + topInset,
        bottom: dp(context, 16),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              IconButton(
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
                icon: const Icon(Icons.close, color: AppUI.white),
                onPressed: onClose,
              ),
              const Spacer(),
              if (isEditing)
                IconButton(
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(),
                  icon: const Icon(Icons.delete_outline, color: AppUI.white),
                  onPressed: onDelete,
                ),
            ],
          ),
          SizedBox(height: dp(context, 18)),
          Text(
            AppStrings.newRecord,
            style: TextStyle(
              color: AppUI.white,
              fontSize: sp(context, 24),
              fontWeight: FontWeight.w700,
              fontFamily: 'Inter',
              height: 1.0,
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final pad = dp(context, 20);
    final topInset = MediaQuery.paddingOf(context).top;

    final pillH = AppUI.fieldHeight;
    final radius = AppUI.fieldRadius;

    const labelColor = AppUI.textLight;
    const valueColor = AppUI.buttonBlue;

    final pillLabelStyle = TextStyle(
      color: labelColor,
      fontSize: sp(context, 14),
      fontWeight: FontWeight.w700,
      fontFamily: 'Inter',
      height: 1.0,
    );

    final pillValueStyle = TextStyle(
      color: valueColor,
      fontSize: sp(context, 18),
      fontWeight: FontWeight.w700,
      fontFamily: 'Inter',
      height: 1.0,
    );

    return BlocListener<AddRecordBloc, AddRecordState>(
      listenWhen: (p, n) => p.shouldClose != n.shouldClose,
      listener: (context, state) {
        if (state.shouldClose) Navigator.of(context).pop(true);
      },
      child: Scaffold(
        backgroundColor: AppUI.background,
        body: SafeArea(
          top: false,
          bottom: true,
          child: BlocBuilder<AddRecordBloc, AddRecordState>(
            builder: (context, state) {
              final dt = state.selectedDateTime;
              final showKeypad = state.activeField != InputField.none;

              return Center(
                child: SingleChildScrollView(
                  padding: EdgeInsets.only(
                    bottom: MediaQuery.viewInsetsOf(context).bottom +
                        MediaQuery.paddingOf(context).bottom,
                    top: topInset,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      _buildHeader(
                        context: context,
                        isEditing: widget.isEditing,
                        onClose: () => Navigator.of(context).pop(),
                        onDelete: () => _confirmDelete(context),
                      ),

                      SizedBox(height: pad),

                      Padding(
                        padding: EdgeInsets.symmetric(horizontal: pad),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.stretch,
                          children: [
                            LayoutBuilder(
                              builder: (ctx, cons) {
                                final maxW = cons.maxWidth;
                                final gap = _snapFloor(ctx, pad);
                                final colW = _snapFloor(ctx, (maxW - 2 * gap) / 3);

                                return Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Row(
                                      children: [
                                        _ValuePill(
                                          width: colW,
                                          height: pillH,
                                          radius: radius,
                                          label: AppStrings.systolicShort,
                                          value: state.systolic,
                                          isActive: state.activeField == InputField.systolic,
                                          isInvalid: state.systolic.isNotEmpty && !state.systolicValid,
                                          labelStyle: pillLabelStyle,
                                          valueStyle: pillValueStyle,
                                          onTap: () => context
                                              .read<AddRecordBloc>()
                                              .add(const FieldChanged(InputField.systolic)),
                                        ),
                                        SizedBox(width: gap),
                                        _ValuePill(
                                          width: colW,
                                          height: pillH,
                                          radius: radius,
                                          label: AppStrings.diastolicShort,
                                          value: state.diastolic,
                                          isActive: state.activeField == InputField.diastolic,
                                          isInvalid: state.diastolic.isNotEmpty && !state.diastolicValid,
                                          labelStyle: pillLabelStyle,
                                          valueStyle: pillValueStyle,
                                          onTap: () => context
                                              .read<AddRecordBloc>()
                                              .add(const FieldChanged(InputField.diastolic)),
                                        ),
                                        SizedBox(width: gap),
                                        _ValuePill(
                                          width: colW,
                                          height: pillH,
                                          radius: radius,
                                          label: AppStrings.pulse,
                                          value: state.pulse,
                                          isActive: state.activeField == InputField.pulse,
                                          isInvalid: state.pulse.isNotEmpty && !state.pulseValid,
                                          labelStyle: pillLabelStyle,
                                          valueStyle: pillValueStyle,
                                          onTap: () => context
                                              .read<AddRecordBloc>()
                                              .add(const FieldChanged(InputField.pulse)),
                                        ),
                                      ],
                                    ),
                                    SizedBox(height: dp(context, 6)),
                                    Builder(
                                      builder: (_) {
                                        String? err;
                                        if (state.systolic.isNotEmpty && !state.systolicValid) {
                                          err = 'РџСЂРѕРІРµСЂСЊС‚Рµ СЃРёСЃС‚РѕР»РёС‡РµСЃРєРѕРµ Р·РЅР°С‡РµРЅРёРµ';
                                        } else if (state.diastolic.isNotEmpty && !state.diastolicValid) {
                                          err = 'РџСЂРѕРІРµСЂСЊС‚Рµ РґРёР°СЃС‚РѕР»РёС‡РµСЃРєРѕРµ Р·РЅР°С‡РµРЅРёРµ';
                                        } else if (state.pulse.isNotEmpty && !state.pulseValid) {
                                          err = 'РџСЂРѕРІРµСЂСЊС‚Рµ РїСѓР»СЊСЃ';
                                        }
                                        return err == null
                                            ? const SizedBox.shrink()
                                            : Text(
                                          err,
                                          style: TextStyle(
                                            color: AppUI.accentRed,
                                            fontSize: sp(context, 14),
                                            fontWeight: FontWeight.w500,
                                            fontFamily: 'Inter',
                                            height: 1.0,
                                          ),
                                        );
                                      },
                                    ),
                                  ],
                                );
                              },
                            ),

                            SizedBox(height: pad),

                            LayoutBuilder(
                              builder: (ctx, cons) {
                                final gap = _snapFloor(ctx, pad);
                                return Row(
                                  children: [
                                    _ChevronPill(
                                      width: AppUI.timeButtonWidth,
                                      height: pillH,
                                      radius: radius,
                                      text: DateFormat('HH:mm').format(dt),
                                      textStyle: pillValueStyle,
                                      chevronColor: labelColor,
                                      onTap: () => _pickTime(context, dt),
                                    ),
                                    SizedBox(width: gap),
                                    _ChevronPill(
                                      width: AppUI.dateButtonWidth,
                                      height: pillH,
                                      radius: radius,
                                      text: DateFormat('dd MMMM yyyy', 'ru').format(dt),
                                      textStyle: pillValueStyle,
                                      chevronColor: labelColor,
                                      onTap: () => _pickDate(context, dt),
                                    ),
                                  ],
                                );
                              },
                            ),

                            SizedBox(height: pad),

                            Container(
                              width: double.infinity,
                              height: dp(context, 72),
                              decoration: BoxDecoration(
                                color: AppUI.white,
                                borderRadius: BorderRadius.circular(radius),
                                boxShadow: const [],
                              ),
                              padding: EdgeInsets.symmetric(
                                horizontal: dp(context, 14),
                                vertical: dp(context, 12),
                              ),
                              alignment: Alignment.topLeft,
                              child: TextField(
                                controller: _noteController,
                                focusNode: _noteFocusNode,
                                expands: true,
                                minLines: null,
                                maxLines: null,
                                textAlignVertical: TextAlignVertical.top,
                                onChanged: (v) => context.read<AddRecordBloc>().add(NoteChanged(v)),
                                style: TextStyle(
                                  color: valueColor,
                                  fontSize: sp(context, 16),
                                  fontFamily: 'Inter',
                                  height: 1.0,
                                ),
                                decoration: InputDecoration.collapsed(
                                  hintText: AppStrings.commentHint,
                                  hintStyle: TextStyle(
                                    color: labelColor,
                                    fontSize: sp(context, 16),
                                    fontFamily: 'Inter',
                                    fontWeight: FontWeight.w600,
                                    height: 1.0,
                                  ),
                                ),
                              ),
                            ),

                            SizedBox(height: pad),

                            const SizedBox.shrink(),

                            SizedBox(height: pad),

                            LayoutBuilder(
                              builder: (ctx, cons) {
                                final maxW = cons.maxWidth;
                                final gap = _snapFloor(ctx, pad);
                                final timeW = _snapFloor(ctx, (maxW - 2 * gap) / 3);
                                final saveW = _snapFloor(ctx, maxW - (gap + timeW));
                                return Align(
                                  alignment: Alignment.centerRight,
                                  child: SizedBox(
                                    width: saveW,
                                    height: pillH,
                                    child: ElevatedButton(
                                      onPressed: state.isValid
                                          ? () => context.read<AddRecordBloc>().add(SaveSubmitted())
                                          : null,
                                      style: ElevatedButton.styleFrom(
                                        backgroundColor: AppUI.buttonBlue,
                                        disabledBackgroundColor: AppUI.dividerColor,
                                        foregroundColor: AppUI.white,
                                        disabledForegroundColor: AppUI.textLight,
                                        elevation: 0,
                                        shape: RoundedRectangleBorder(
                                          borderRadius: BorderRadius.circular(radius),
                                        ),
                                      ),
                                      child: Text(
                                        AppStrings.save,
                                        style: TextStyle(
                                          fontSize: sp(context, 18),
                                          fontWeight: FontWeight.w700,
                                          fontFamily: 'Inter',
                                          height: 1.0,
                                        ),
                                      ),
                                    ),
                                  ),
                                );
                              },
                            ),

                            if (showKeypad) ...[
                              SizedBox(height: pad),

                              // Р’РђР–РќРћ: РєР»Р°РІРёР°С‚СѓСЂР° РїРѕР»СѓС‡Р°РµС‚ С‚Рµ Р¶Рµ РјРµС‚СЂРёРєРё, С‡С‚Рѕ Рё РїРёР»СЋР»Рё
                              LayoutBuilder(
                                builder: (ctx, cons) {
                                  final gap = _snapFloor(ctx, pad);

                                  return CustomKeypad(
                                    enabledKeys: state.enabledKeys,
                                    onKeyPressed: (v) => context.read<AddRecordBloc>().add(NumberPressed(v)),
                                    onDeletePressed: () => context.read<AddRecordBloc>().add(BackspacePressed()),
                                    horizontalPadding: 0, // РјС‹ СѓР¶Рµ РІРЅСѓС‚СЂРё Padding(horizontal: pad)
                                    gap: gap,
                                    cellHeight: pillH,
                                    radius: radius,
                                    background: AppUI.white,
                                    deleteBackground: AppUI.dividerColor,
                                    foreground: valueColor,
                                    textStyle: TextStyle(
                                      fontSize: sp(context, 24),
                                      fontWeight: FontWeight.w800,
                                      fontFamily: 'Inter',
                                      height: 1.0,
                                    ),
                                  );
                                },
                              ),
                            ],

                            SizedBox(height: pad),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}

class _ValuePill extends StatelessWidget {
  final double width;
  final double height;
  final double radius;
  final String label;
  final String value;
  final bool isActive;
  final bool isInvalid;
  final TextStyle labelStyle;
  final TextStyle valueStyle;
  final VoidCallback onTap;

  const _ValuePill({
    required this.width,
    required this.height,
    required this.radius,
    required this.label,
    required this.value,
    required this.isActive,
    required this.isInvalid,
    required this.labelStyle,
    required this.valueStyle,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width,
      height: height,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque, // Р§С‚РѕР±С‹ РєР»РёРєР°Р»РѕСЃСЊ РїРѕ РІСЃРµР№ РїР»РѕС‰Р°РґРё
        onTap: onTap,
        child: Container(
          decoration: BoxDecoration(
            color: AppUI.white,
            borderRadius: BorderRadius.circular(radius),
            boxShadow: const [AppUI.shadow4x2],
            border: (isInvalid || isActive)
                ? Border.all(
              color: isInvalid ? AppUI.accentRed : AppUI.headerBlue,
              width: dp(context, 2),
            )
                : null,
          ),
          alignment: Alignment.center,
          child: Text(
            value.isEmpty ? label : value,
            style: value.isEmpty ? labelStyle : valueStyle,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}

class _ChevronPill extends StatelessWidget {
  final double width;
  final double height;
  final double radius;
  final String text;
  final TextStyle textStyle;
  final Color chevronColor;
  final VoidCallback onTap;

  const _ChevronPill({
    required this.width,
    required this.height,
    required this.radius,
    required this.text,
    required this.textStyle,
    required this.chevronColor,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final chevronSize = dp(context, 18);
    return SizedBox(
      width: width,
      height: height,
      child: Material( // Р”РѕР±Р°РІРёР»Р° Material РґР»СЏ РЅРѕСЂРјР°Р»СЊРЅРѕРіРѕ InkWell (СЌС„С„РµРєС‚ РЅР°Р¶Р°С‚РёСЏ)
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(radius),
          onTap: onTap,
          child: Container(
            decoration: BoxDecoration(
              color: AppUI.white,
              borderRadius: BorderRadius.circular(radius),
              boxShadow: const [AppUI.shadow4x2],
            ),
            padding: EdgeInsets.symmetric(horizontal: dp(context, 14)),
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    text,
                    style: textStyle,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                SizedBox(width: dp(context, 8)),
                Icon(Icons.keyboard_arrow_down, size: chevronSize, color: chevronColor),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:isar/isar.dart';

part 'blood_pressure_model.g.dart';

@Collection()
class BloodPressureRecord {
  Id id = Isar.autoIncrement;

  @Index()
  late DateTime dateTime;
  late int systolic;
  late int diastolic;
  late int pulse;

  String? note;    // РџРѕР»Рµ РґР»СЏ Р·Р°РјРµС‚РѕРє (Р±С‹РІС€РёР№ comment)
  String? emotion; // РўРІРѕР№ СЌРјРѕРґР·Рё

  @ignore
  Color get statusColor {
    // Р•РґРёРЅР°СЏ СЃРёСЃС‚РµРјР° СЃС‚Р°С‚СѓСЃРѕРІ (РєР°Рє РІ В«СЃРІРµР¶РµРјВ» UI):
    // - РєСЂР°СЃРЅС‹Р№: РїРѕРІС‹С€РµРЅРЅРѕРµ
    // - РіРѕР»СѓР±РѕР№: РїРѕРЅРёР¶РµРЅРЅРѕРµ
    // - Р·РµР»С‘РЅС‹Р№: РѕСЃС‚Р°Р»СЊРЅРѕРµ
    if (systolic >= 140 || diastolic >= 90) return const Color(0xFFE11D48);
    if (systolic <= 100 || diastolic <= 60) return const Color(0xFF60A5FA);
    return const Color(0xFF22C55E);
  }

  @ignore
  String get statusText {
    if (systolic >= 140 || diastolic >= 90) return 'РџРѕРІС‹С€РµРЅРѕ';
    if (systolic <= 100 || diastolic <= 60) return 'РџРѕРЅРёР¶РµРЅРѕ';
    return 'РќРѕСЂРјР°';
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'blood_pressure_model.dart';

// **************************************************************************
// IsarCollectionGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: duplicate_ignore, non_constant_identifier_names, constant_identifier_names, invalid_use_of_protected_member, unnecessary_cast, prefer_const_constructors, lines_longer_than_80_chars, require_trailing_commas, inference_failure_on_function_invocation, unnecessary_parenthesis, unnecessary_raw_strings, unnecessary_null_checks, join_return_with_assignment, prefer_final_locals, avoid_js_rounded_ints, avoid_positional_boolean_parameters, always_specify_types

extension GetBloodPressureRecordCollection on Isar {
  IsarCollection<BloodPressureRecord> get bloodPressureRecords =>
      this.collection();
}

const BloodPressureRecordSchema = CollectionSchema(
  name: r'BloodPressureRecord',
  id: -3447328812780924616,
  properties: {
    r'dateTime': PropertySchema(
      id: 0,
      name: r'dateTime',
      type: IsarType.dateTime,
    ),
    r'diastolic': PropertySchema(
      id: 1,
      name: r'diastolic',
      type: IsarType.long,
    ),
    r'emotion': PropertySchema(
      id: 2,
      name: r'emotion',
      type: IsarType.string,
    ),
    r'note': PropertySchema(
      id: 3,
      name: r'note',
      type: IsarType.string,
    ),
    r'pulse': PropertySchema(
      id: 4,
      name: r'pulse',
      type: IsarType.long,
    ),
    r'systolic': PropertySchema(
      id: 5,
      name: r'systolic',
      type: IsarType.long,
    )
  },
  estimateSize: _bloodPressureRecordEstimateSize,
  serialize: _bloodPressureRecordSerialize,
  deserialize: _bloodPressureRecordDeserialize,
  deserializeProp: _bloodPressureRecordDeserializeProp,
  idName: r'id',
  indexes: {
    r'dateTime': IndexSchema(
      id: -138851979697481250,
      name: r'dateTime',
      unique: false,
      replace: false,
      properties: [
        IndexPropertySchema(
          name: r'dateTime',
          type: IndexType.value,
          caseSensitive: false,
        )
      ],
    )
  },
  links: {},
  embeddedSchemas: {},
  getId: _bloodPressureRecordGetId,
  getLinks: _bloodPressureRecordGetLinks,
  attach: _bloodPressureRecordAttach,
  version: '3.1.0+1',
);

int _bloodPressureRecordEstimateSize(
  BloodPressureRecord object,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  var bytesCount = offsets.last;
  {
    final value = object.emotion;
    if (value != null) {
      bytesCount += 3 + value.length * 3;
    }
  }
  {
    final value = object.note;
    if (value != null) {
      bytesCount += 3 + value.length * 3;
    }
  }
  return bytesCount;
}

void _bloodPressureRecordSerialize(
  BloodPressureRecord object,
  IsarWriter writer,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  writer.writeDateTime(offsets[0], object.dateTime);
  writer.writeLong(offsets[1], object.diastolic);
  writer.writeString(offsets[2], object.emotion);
  writer.writeString(offsets[3], object.note);
  writer.writeLong(offsets[4], object.pulse);
  writer.writeLong(offsets[5], object.systolic);
}

BloodPressureRecord _bloodPressureRecordDeserialize(
  Id id,
  IsarReader reader,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  final object = BloodPressureRecord();
  object.dateTime = reader.readDateTime(offsets[0]);
  object.diastolic = reader.readLong(offsets[1]);
  object.emotion = reader.readStringOrNull(offsets[2]);
  object.id = id;
  object.note = reader.readStringOrNull(offsets[3]);
  object.pulse = reader.readLong(offsets[4]);
  object.systolic = reader.readLong(offsets[5]);
  return object;
}

P _bloodPressureRecordDeserializeProp<P>(
  IsarReader reader,
  int propertyId,
  int offset,
  Map<Type, List<int>> allOffsets,
) {
  switch (propertyId) {
    case 0:
      return (reader.readDateTime(offset)) as P;
    case 1:
      return (reader.readLong(offset)) as P;
    case 2:
      return (reader.readStringOrNull(offset)) as P;
    case 3:
      return (reader.readStringOrNull(offset)) as P;
    case 4:
      return (reader.readLong(offset)) as P;
    case 5:
      return (reader.readLong(offset)) as P;
    default:
      throw IsarError('Unknown property with id $propertyId');
  }
}

Id _bloodPressureRecordGetId(BloodPressureRecord object) {
  return object.id;
}

List<IsarLinkBase<dynamic>> _bloodPressureRecordGetLinks(
    BloodPressureRecord object) {
  return [];
}

void _bloodPressureRecordAttach(
    IsarCollection<dynamic> col, Id id, BloodPressureRecord object) {
  object.id = id;
}

extension BloodPressureRecordQueryWhereSort
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QWhere> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhere> anyId() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(const IdWhereClause.any());
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhere>
      anyDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        const IndexWhereClause.any(indexName: r'dateTime'),
      );
    });
  }
}

extension BloodPressureRecordQueryWhere
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QWhereClause> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: id,
        upper: id,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idNotEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            )
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            );
      } else {
        return query
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            )
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            );
      }
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idGreaterThan(Id id, {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.greaterThan(lower: id, includeLower: include),
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idLessThan(Id id, {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.lessThan(upper: id, includeUpper: include),
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idBetween(
    Id lowerId,
    Id upperId, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: lowerId,
        includeLower: includeLower,
        upper: upperId,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeEqualTo(DateTime dateTime) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.equalTo(
        indexName: r'dateTime',
        value: [dateTime],
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeNotEqualTo(DateTime dateTime) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [],
              upper: [dateTime],
              includeUpper: false,
            ))
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [dateTime],
              includeLower: false,
              upper: [],
            ));
      } else {
        return query
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [dateTime],
              includeLower: false,
              upper: [],
            ))
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [],
              upper: [dateTime],
              includeUpper: false,
            ));
      }
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeGreaterThan(
    DateTime dateTime, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.between(
        indexName: r'dateTime',
        lower: [dateTime],
        includeLower: include,
        upper: [],
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeLessThan(
    DateTime dateTime, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.between(
        indexName: r'dateTime',
        lower: [],
        upper: [dateTime],
        includeUpper: include,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeBetween(
    DateTime lowerDateTime,
    DateTime upperDateTime, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.between(
        indexName: r'dateTime',
        lower: [lowerDateTime],
        includeLower: includeLower,
        upper: [upperDateTime],
        includeUpper: includeUpper,
      ));
    });
  }
}

extension BloodPressureRecordQueryFilter on QueryBuilder<BloodPressureRecord,
    BloodPressureRecord, QFilterCondition> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeEqualTo(DateTime value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'dateTime',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeGreaterThan(
    DateTime value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'dateTime',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeLessThan(
    DateTime value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'dateTime',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeBetween(
    DateTime lower,
    DateTime upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'dateTime',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'diastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'diastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'diastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'diastolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNull(
        property: r'emotion',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsNotNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNotNull(
        property: r'emotion',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionEqualTo(
    String? value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionGreaterThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionLessThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionBetween(
    String? lower,
    String? upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'emotion',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'emotion',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'emotion',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'emotion',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idEqualTo(Id value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idGreaterThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idLessThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idBetween(
    Id lower,
    Id upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'id',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNull(
        property: r'note',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsNotNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNotNull(
        property: r'note',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteEqualTo(
    String? value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteGreaterThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteLessThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteBetween(
    String? lower,
    String? upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'note',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'note',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'note',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'note',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'pulse',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'pulse',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'pulse',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'pulse',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'systolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'systolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'systolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'systolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension BloodPressureRecordQueryObject on QueryBuilder<BloodPressureRecord,
    BloodPressureRecord, QFilterCondition> {}

extension BloodPressureRecordQueryLinks on QueryBuilder<BloodPressureRecord,
    BloodPressureRecord, QFilterCondition> {}

extension BloodPressureRecordQuerySortBy
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QSortBy> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDateTimeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByEmotion() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByEmotionDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByNote() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByNoteDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByPulse() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByPulseDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortBySystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortBySystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.desc);
    });
  }
}

extension BloodPressureRecordQuerySortThenBy
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QSortThenBy> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDateTimeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByEmotion() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByEmotionDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenById() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByIdDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByNote() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByNoteDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByPulse() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByPulseDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenBySystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenBySystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.desc);
    });
  }
}

extension BloodPressureRecordQueryWhereDistinct
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'dateTime');
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'diastolic');
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByEmotion({bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'emotion', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByNote({bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'note', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByPulse() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'pulse');
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctBySystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'systolic');
    });
  }
}

extension BloodPressureRecordQueryProperty
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QQueryProperty> {
  QueryBuilder<BloodPressureRecord, int, QQueryOperations> idProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'id');
    });
  }

  QueryBuilder<BloodPressureRecord, DateTime, QQueryOperations>
      dateTimeProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'dateTime');
    });
  }

  QueryBuilder<BloodPressureRecord, int, QQueryOperations> diastolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'diastolic');
    });
  }

  QueryBuilder<BloodPressureRecord, String?, QQueryOperations>
      emotionProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'emotion');
    });
  }

  QueryBuilder<BloodPressureRecord, String?, QQueryOperations> noteProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'note');
    });
  }

  QueryBuilder<BloodPressureRecord, int, QQueryOperations> pulseProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'pulse');
    });
  }

  QueryBuilder<BloodPressureRecord, int, QQueryOperations> systolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'systolic');
    });
  }
}
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/repositories/pressure_repository.dart';
import '../../data/blood_pressure_model.dart';
import 'home_event.dart';
import 'home_state.dart';

class HomeBloc extends Bloc<HomeEvent, HomeState> {
  final PressureRepository _repository;

  HomeBloc(this._repository) : super(HomeLoading()) {
    on<LoadHomeData>(_onLoadData);
    add(LoadHomeData());
  }

  Future<void> _onLoadData(LoadHomeData event, Emitter<HomeState> emit) async {
    // РЇРІРЅРѕ С‚РёРїРёР·РёСЂСѓРµРј СЃС‚СЂРёРј, С‡С‚РѕР±С‹ РёР·Р±РµР¶Р°С‚СЊ РѕС€РёР±РєРё Object?
    await emit.forEach<List<BloodPressureRecord>>(
      _repository.getAllRecordsStream(),
      onData: (records) => HomeLoaded(records),
      onError: (error, stackTrace) => HomeError(error.toString()),
    );
  }
}
import 'package:equatable/equatable.dart';

abstract class HomeEvent extends Equatable {
  const HomeEvent();
  @override
  List<Object> get props => [];
}

class LoadHomeData extends HomeEvent {}
import 'package:equatable/equatable.dart';
import '../../data/blood_pressure_model.dart';

abstract class HomeState extends Equatable {
  const HomeState();
  @override
  List<Object> get props => [];
}

class HomeLoading extends HomeState {}

class HomeLoaded extends HomeState {
  final List<BloodPressureRecord> records;
  const HomeLoaded(this.records);

  @override
  List<Object> get props => [records];
}

class HomeError extends HomeState {
  final String message;
  const HomeError(this.message);
}
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../data/blood_pressure_model.dart';
import 'statistics_state.dart';

class StatisticsCubit extends Cubit<StatisticsState> {
  final List<BloodPressureRecord> _allRecords;

  StatisticsCubit(
    this._allRecords, {
    int targetSystolic = 120,
    int targetDiastolic = 80,
  }) : super(StatisticsState(
          targetSystolic: targetSystolic,
          targetDiastolic: targetDiastolic,
        )) {
    updatePeriod(StatisticsPeriod.sevenDays);
  }

  void updatePeriod(StatisticsPeriod period) {
    final now = DateTime.now();
    List<BloodPressureRecord> filtered;

    switch (period) {
      case StatisticsPeriod.sevenDays:
        filtered = _allRecords
            .where((r) => r.dateTime.isAfter(now.subtract(const Duration(days: 7))))
            .toList();
        break;
      case StatisticsPeriod.thirtyDays:
        filtered = _allRecords
            .where((r) => r.dateTime.isAfter(now.subtract(const Duration(days: 30))))
            .toList();
        break;
      case StatisticsPeriod.all:
        filtered = List.from(_allRecords);
        break;
    }

    filtered.sort((a, b) => a.dateTime.compareTo(b.dateTime));
    
    // Thinning if records > 100
    if (filtered.length > 100) {
      final int skip = (filtered.length / 50).floor();
      final List<BloodPressureRecord> thinned = [];
      for (int i = 0; i < filtered.length; i++) {
        if (i % skip == 0 || i == filtered.length - 1) {
          thinned.add(filtered[i]);
        }
      }
      filtered = thinned;
    }

    _calculateAnalytics(filtered, period);
  }

  void _calculateAnalytics(List<BloodPressureRecord> records, StatisticsPeriod period) {
    if (records.isEmpty) {
      emit(StatisticsState(period: period));
      return;
    }

    double maxSys = 0;
    double maxDia = 0;
    double minSys = double.infinity;
    double minDia = double.infinity;
    double sumSys = 0;
    double sumDia = 0;

    for (var r in records) {
      if (r.systolic > maxSys) maxSys = r.systolic.toDouble();
      if (r.diastolic > maxDia) maxDia = r.diastolic.toDouble();
      if (r.systolic < minSys) minSys = r.systolic.toDouble();
      if (r.diastolic < minDia) minDia = r.diastolic.toDouble();
      sumSys += r.systolic;
      sumDia += r.diastolic;
    }

    emit(state.copyWith(
      filteredRecords: records,
      period: period,
      maxSys: maxSys,
      maxDia: maxDia,
      minSys: minSys == double.infinity ? 0 : minSys,
      minDia: minDia == double.infinity ? 0 : minDia,
      avgSys: sumSys / records.length,
      avgDia: sumDia / records.length,
    ));
  }
}
import 'package:equatable/equatable.dart';
import '../../data/blood_pressure_model.dart';

enum StatisticsPeriod { sevenDays, thirtyDays, all }

class StatisticsState extends Equatable {
  final List<BloodPressureRecord> filteredRecords;
  final StatisticsPeriod period;
  final double maxSys;
  final double maxDia;
  final double minSys;
  final double minDia;
  final double avgSys;
  final double avgDia;
  final int targetSystolic;
  final int targetDiastolic;

  const StatisticsState({
    this.filteredRecords = const [],
    this.period = StatisticsPeriod.sevenDays,
    this.maxSys = 0,
    this.maxDia = 0,
    this.minSys = 0,
    this.minDia = 0,
    this.avgSys = 0,
    this.avgDia = 0,
    this.targetSystolic = 120,
    this.targetDiastolic = 80,
  });

  StatisticsState copyWith({
    List<BloodPressureRecord>? filteredRecords,
    StatisticsPeriod? period,
    double? maxSys,
    double? maxDia,
    double? minSys,
    double? minDia,
    double? avgSys,
    double? avgDia,
    int? targetSystolic,
    int? targetDiastolic,
  }) {
    return StatisticsState(
      filteredRecords: filteredRecords ?? this.filteredRecords,
      period: period ?? this.period,
      maxSys: maxSys ?? this.maxSys,
      maxDia: maxDia ?? this.maxDia,
      minSys: minSys ?? this.minSys,
      minDia: minDia ?? this.minDia,
      avgSys: avgSys ?? this.avgSys,
      avgDia: avgDia ?? this.avgDia,
      targetSystolic: targetSystolic ?? this.targetSystolic,
      targetDiastolic: targetDiastolic ?? this.targetDiastolic,
    );
  }

  @override
  List<Object?> get props => [
        filteredRecords,
        period,
        maxSys,
        maxDia,
        minSys,
        minDia,
        avgSys,
        avgDia,
        targetSystolic,
        targetDiastolic,
      ];
}
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';

import '../../../../core/theme/app_theme.dart';
import '../../../../core/theme/scale.dart';
import '../../data/blood_pressure_model.dart';

class RecordListItem extends StatelessWidget {
  final BloodPressureRecord record;
  final VoidCallback? onTap;

  const RecordListItem({
    super.key,
    required this.record,
    this.onTap,
  });

  String _hhmm(DateTime t) => DateFormat('HH:mm').format(t);

  @override
  Widget build(BuildContext context) {
    final rowH = dp(context, 59);
    final timeW = dp(context, 56);
    final dotD = dp(context, 15);

    final pillR = dp(context, 6);
    final padH = dp(context, 20);
    final padV = dp(context, 10);

    final iconSize = dp(context, 22);
    final iconGap = dp(context, 8);

    final valueStyle = TextStyle(
      fontFamily: 'Inter',
      fontSize: sp(context, 22),
      fontWeight: FontWeight.w700,
      color: AppUI.textPrimary,
      height: 1.0,
    );

    final timeStyle = TextStyle(
      fontFamily: 'Inter',
      fontSize: sp(context, 16),
      fontWeight: FontWeight.w400,
      color: AppUI.textTime,
      height: 1.0,
    );

    final dotColor = record.statusColor;

    return SizedBox(
      height: rowH,
      child: InkWell(
        onTap: onTap,
        child: Row(
          children: [
            SizedBox(
              width: timeW,
              child: Align(
                alignment: Alignment.centerLeft,
                child: Text(_hhmm(record.dateTime), style: timeStyle),
              ),
            ),
            SizedBox(width: dp(context, 8)),
            Container(
              width: dotD,
              height: dotD,
              decoration: BoxDecoration(
                color: dotColor,
                shape: BoxShape.circle,
              ),
            ),
            SizedBox(width: dp(context, 12)),
            Expanded(
              child: Container(
                height: rowH,
                padding: EdgeInsets.symmetric(horizontal: padH, vertical: padV),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(pillR),
                  boxShadow: const [
                    BoxShadow(
                      offset: Offset(0, 2),
                      blurRadius: 4,
                      color: Color(0x1A000000),
                    )
                  ],
                ),
                child: Row(
                  children: [
                    // Р›Р•Р’РђРЇ Р“Р РЈРџРџРђ: РґР°РІР»РµРЅРёРµ + СЃС‚СЂРµР»РєРё (РёРєРѕРЅРєР° СЂСЏРґРѕРј СЃ РґР°РІР»РµРЅРёРµРј)
                    Expanded(
                      flex: 3,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Flexible(
                            child: Text(
                              '${record.systolic}/${record.diastolic}',
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: valueStyle,
                            ),
                          ),
                          SizedBox(width: iconGap),
                          SvgPicture.asset(
                            'assets/arrow-up-down.svg',
                            width: iconSize,
                            height: iconSize,
                            colorFilter: ColorFilter.mode(
                              AppUI.textPrimary.withValues(alpha: 0.75),
                              BlendMode.srcIn,
                            ),
                          ),
                        ],
                      ),
                    ),

                    // РџР РђР’РђРЇ Р“Р РЈРџРџРђ: РїСѓР»СЊСЃ + activity (РїСЂРёР¶Р°С‚Рѕ РІРїСЂР°РІРѕ)
                    Expanded(
                      flex: 2,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          Text(
                            '${record.pulse}',
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: valueStyle,
                          ),
                          SizedBox(width: iconGap),
                          SvgPicture.asset(
                            'assets/activity.svg',
                            width: iconSize,
                            height: iconSize,
                            colorFilter: ColorFilter.mode(
                              AppUI.textPrimary.withValues(alpha: 0.75),
                              BlendMode.srcIn,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';

import '../../../../core/theme/scale.dart';
import '../../data/blood_pressure_model.dart';

class SummaryCard extends StatelessWidget {
  final BloodPressureRecord? record;
  final double? width;
  final double? height;

  const SummaryCard({
    super.key,
    this.record,
    this.width,
    this.height,
  });

  String _hhmm(DateTime t) => DateFormat('HH:mm').format(t);

  @override
  Widget build(BuildContext context) {
    final cardW = width ?? (MediaQuery.sizeOf(context).width - 2 * dp(context, 20));
    final cardH = height ?? dp(context, 120);
    final r = dp(context, 10);

    const summaryBlue = Color(0xFF3973A2);

    if (record == null) {
      return Container(
        width: cardW,
        height: cardH,
        decoration: BoxDecoration(
          color: summaryBlue,
          borderRadius: BorderRadius.circular(r),
          boxShadow: const [
            BoxShadow(
              offset: Offset(0, 2),
              blurRadius: 4,
              color: Color(0x1A000000),
            ),
          ],
        ),
        alignment: Alignment.center,
        child: Text(
          'РќРµС‚ РґР°РЅРЅС‹С…',
          style: TextStyle(
            color: Colors.white,
            fontSize: sp(context, 18),
            fontWeight: FontWeight.w500,
            fontFamily: 'Inter',
            height: 1.0,
          ),
        ),
      );
    }

    final s = record!.systolic;
    final d = record!.diastolic;
    final p = record!.pulse;
    final t = record!.dateTime;

    final pressureStyle = TextStyle(
      fontFamily: 'Inter',
      fontSize: sp(context, 30),
      fontWeight: FontWeight.w700,
      color: Colors.white,
      height: 1.0,
    );

    final pulseNumStyle = TextStyle(
      fontFamily: 'Inter',
      fontSize: sp(context, 20),
      fontWeight: FontWeight.w600,
      color: Colors.white,
      height: 1.0,
    );

    final pulseUnitStyle = TextStyle(
      fontFamily: 'Inter',
      fontSize: sp(context, 20),
      fontWeight: FontWeight.w600,
      color: Colors.white,
      height: 1.0,
    );

    final timeStyle = TextStyle(
      fontFamily: 'Inter',
      fontSize: sp(context, 20),
      fontWeight: FontWeight.w600,
      color: Colors.white,
      height: 1.0,
    );

    return Container(
      width: cardW,
      height: cardH,
      decoration: BoxDecoration(
        color: summaryBlue,
        borderRadius: BorderRadius.circular(r),
        boxShadow: const [
          BoxShadow(
            offset: Offset(0, 2),
            blurRadius: 4,
            color: Color(0x1A000000),
          ),
        ],
      ),
      padding: EdgeInsets.fromLTRB(dp(context, 16), dp(context, 10), dp(context, 16), dp(context, 10)),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 1) Р”Р°РІР»РµРЅРёРµ + С‡РµРє
          Row(
            children: [
              Expanded(
                child: Text(
                  '$s/$d',
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: pressureStyle,
                ),
              ),
              SvgPicture.asset(
                'assets/check.svg',
                width: dp(context, 42),
                height: dp(context, 42),
                colorFilter: const ColorFilter.mode(Color(0xFF6B9DC0), BlendMode.srcIn),
              ),
            ],
          ),

          SizedBox(height: dp(context, 8)),

          // 2) РџСѓР»СЊСЃ: "65 СѓРґ/РјРёРЅ" РІ РћР”РќРЈ СЃС‚СЂРѕРєСѓ, Р±РµР· РїРµСЂРµРЅРѕСЃРѕРІ
          Row(
            crossAxisAlignment: CrossAxisAlignment.baseline,
            textBaseline: TextBaseline.alphabetic,
            children: [
              Text('$p', style: pulseNumStyle),
              SizedBox(width: dp(context, 6)),
              Text('СѓРґ/РјРёРЅ', style: pulseUnitStyle),
            ],
          ),

          const Spacer(),

          // 3) Р’СЂРµРјСЏ
          Row(
            children: [
              SvgPicture.asset(
                'assets/clock.svg',
                width: dp(context, 20),
                height: dp(context, 20),
                colorFilter: const ColorFilter.mode(Colors.white, BlendMode.srcIn),
              ),
              SizedBox(width: dp(context, 6)),
              Text(_hhmm(t), style: timeStyle),
            ],
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';

import '../../../../core/theme/app_theme.dart';
import '../../../../core/theme/scale.dart';
import '../../../../core/utils/app_strings.dart';
import '../data/blood_pressure_model.dart';
import 'bloc/home_bloc.dart';
import 'bloc/home_state.dart';
import 'widgets/summary_card.dart';
import 'widgets/record_list_item.dart';
import '../../add_record/presentation/add_record_screen.dart';

enum _FilterPeriod { today, week, month, all }

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  _FilterPeriod _period = _FilterPeriod.week;

  @override
  void initState() {
    super.initState();
  }

  String _periodLabel(_FilterPeriod p) {
    switch (p) {
      case _FilterPeriod.today:
        return AppStrings.today;
      case _FilterPeriod.week:
        return AppStrings.week;
      case _FilterPeriod.month:
        return AppStrings.month;
      case _FilterPeriod.all:
        return AppStrings.allShort;
    }
  }

  String _recordsWord(int n) => AppStrings.recordsWord(n);

  List<BloodPressureRecord> _applyFilter(List<BloodPressureRecord> records) {
    final now = DateTime.now();
    switch (_period) {
      case _FilterPeriod.today:
        final d = DateTime(now.year, now.month, now.day);
        return records.where((r) {
          final rd = DateTime(r.dateTime.year, r.dateTime.month, r.dateTime.day);
          return rd == d;
        }).toList();
      case _FilterPeriod.week:
        final from = now.subtract(const Duration(days: 7));
        return records.where((r) => r.dateTime.isAfter(from)).toList();
      case _FilterPeriod.month:
        final from = now.subtract(const Duration(days: 30));
        return records.where((r) => r.dateTime.isAfter(from)).toList();
      case _FilterPeriod.all:
        return records;
    }
  }

  void _openEdit(BuildContext context, BloodPressureRecord record) {
    Navigator.push(context, MaterialPageRoute(builder: (_) => AddRecordScreen(record: record)));
  }

  @override
  Widget build(BuildContext context) {
    final safeTop = MediaQuery.of(context).padding.top;

    // в”Ђв”Ђ Figma (360w) в†’ dp/sp в”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђв”Ђ
    final blueH = dp(context, 169);
    final lightH = dp(context, 82);
    final overlap = dp(context, 50);

    final side = dp(context, 20);

    final titleFont = sp(context, 26);
    final filterFont = sp(context, 16);

    return BlocBuilder<HomeBloc, HomeState>(
      builder: (context, state) {
        final all = state is HomeLoaded ? state.records : const <BloodPressureRecord>[];
        final records = _applyFilter(all)..sort((a, b) => b.dateTime.compareTo(a.dateTime));
        final filteredCount = records.length;

        final lastRecord = all.isNotEmpty
            ? (List<BloodPressureRecord>.from(all)..sort((a, b) => b.dateTime.compareTo(a.dateTime))).first
            : null;

        final groups = _groupByDate(records);

        // в”Ђв”Ђ РЁР°РїРєР° (С‚РµРїРµСЂСЊ РІРЅСѓС‚СЂРё BlocBuilder, С‡С‚РѕР±С‹ РІРёРґРµС‚СЊ filteredCount) в”Ђв”Ђв”Ђв”Ђ
        final header = SizedBox(
          height: blueH + lightH,
          child: Stack(
            clipBehavior: Clip.none,
            children: [
              // РЎРёРЅРёР№ С„РѕРЅ
              const Positioned.fill(child: ColoredBox(color: AppUI.headerBlue)),

              // РЎРІРµС‚Р»Р°СЏ РїРѕР»РєР°
              Positioned(
                left: 0,
                right: 0,
                top: blueH,
                height: lightH,
                child: Stack(
                  children: const [
                    Positioned.fill(child: ColoredBox(color: Color(0xFFF9F8FA))),
                    Positioned(
                      left: 0,
                      right: 0,
                      bottom: 0,
                      height: 0.5,
                      child: ColoredBox(color: Color(0x33000000)),
                    ),
                  ],
                ),
              ),

              // Р—Р°РіРѕР»РѕРІРѕРє + СЃС‡С‘С‚С‡РёРє + С„РёР»СЊС‚СЂ
              Positioned(
                left: side,
                right: side,
                top: safeTop + dp(context, 20),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            AppStrings.myDiary,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: TextStyle(
                              color: Colors.white,
                              fontSize: titleFont,
                              fontWeight: FontWeight.w600,
                              fontFamily: 'Inter',
                              height: 1.0,
                            ),
                          ),
                          SizedBox(height: dp(context, 20)),
                          Text(
                            '$filteredCount ${_recordsWord(filteredCount)}',
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: TextStyle(
                              color: const Color(0xFFBFD4E7),
                              fontSize: sp(context, 16),
                              fontWeight: FontWeight.w500,
                              fontFamily: 'Inter',
                              height: 1.0,
                            ),
                          ),
                        ],
                      ),
                    ),
                    PopupMenuButton<_FilterPeriod>(
                      onSelected: (value) {
                        setState(() => _period = value);
                      },
                      itemBuilder: (context) => const [
                        PopupMenuItem(value: _FilterPeriod.today, child: Text(AppStrings.today)),
                        PopupMenuItem(value: _FilterPeriod.week, child: Text(AppStrings.week)),
                        PopupMenuItem(value: _FilterPeriod.month, child: Text(AppStrings.month)),
                        PopupMenuItem(value: _FilterPeriod.all, child: Text(AppStrings.allTime)),
                      ],
                      offset: Offset(0, dp(context, 28)),
                      child: Container(
                        height: dp(context, 32),
                        padding: EdgeInsets.symmetric(horizontal: dp(context, 10)),
                        decoration: BoxDecoration(
                          color: Colors.white.withValues(alpha: 0.15),
                          borderRadius: BorderRadius.circular(dp(context, 5)),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              _periodLabel(_period),
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: filterFont,
                                fontWeight: FontWeight.w600,
                                fontFamily: 'Inter',
                                height: 1.0,
                              ),
                            ),
                            SizedBox(width: dp(context, 4)),
                            SvgPicture.asset(
                              'assets/arrow_drop_down.svg',
                              width: dp(context, 24),
                              height: dp(context, 24),
                              colorFilter: const ColorFilter.mode(Colors.white, BlendMode.srcIn),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        );

        final list = CustomScrollView(
          slivers: [
            if (groups.isEmpty) ...[
              SliverToBoxAdapter(
                child: Padding(
                  padding: EdgeInsets.only(top: dp(context, 24)),
                  child: Center(
                    child: Text(
                      'РќРµС‚ Р·Р°РїРёСЃРµР№ Р·Р° РІС‹Р±СЂР°РЅРЅС‹Р№ РїРµСЂРёРѕРґ',
                      style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                        color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.70),
                      ),
                    ),
                  ),
                ),
              ),
              SliverToBoxAdapter(child: SizedBox(height: dp(context, 24))),
            ] else ...[
              for (final g in groups) ...[
                // Р—Р°РіРѕР»РѕРІРѕРє РґР°С‚С‹ (Р±РµР· вЂњN Р·Р°РїРёСЃРµР№вЂќ РїРѕРґ РєР°Р¶РґРѕР№ РґР°С‚РѕР№)
                SliverToBoxAdapter(
                  child: Padding(
                    padding: EdgeInsets.only(right: side, top: dp(context, 4), bottom: dp(context, 4)),
                    child: Align(
                      alignment: Alignment.centerRight,
                      child: Text(
                        _formatDate(g.key),
                        textAlign: TextAlign.right,
                        style: TextStyle(
                          color: const Color(0xFF325674),
                          fontSize: sp(context, 16),
                          fontWeight: FontWeight.w600,
                          fontFamily: 'Inter',
                          height: 1.0,
                        ),
                      ),
                    ),
                  ),
                ),

                SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, i) {
                      final r = g.value[i];
                      return Padding(
                        padding: EdgeInsets.fromLTRB(side, dp(context, 16), side, 0),
                        child: RecordListItem(
                          record: r,
                          onTap: () => _openEdit(context, r),
                        ),
                      );
                    },
                    childCount: g.value.length,
                  ),
                ),

                SliverToBoxAdapter(child: SizedBox(height: dp(context, 12))),
              ],
            ],
          ],
        );

        return ColoredBox(
          color: const Color(0xFFF0F4F8),
          child: Column(
            children: [
              // С„РёРєСЃРёСЂРѕРІР°РЅРЅР°СЏ С€Р°РїРєР°
              SizedBox(
                height: blueH + lightH,
                child: Stack(
                  clipBehavior: Clip.none,
                  children: [
                    header,
                    // РљР°СЂС‚РѕС‡РєР° В«РїРѕСЃР»РµРґРЅРµРµ РёР·РјРµСЂРµРЅРёРµВ»
                    Positioned(
                      left: side,
                      top: blueH - overlap,
                      child: SummaryCard(record: lastRecord),
                    ),
                  ],
                ),
              ),
              Expanded(child: list),
            ],
          ),
        );
      },
    );
  }

  List<MapEntry<DateTime, List<BloodPressureRecord>>> _groupByDate(List<BloodPressureRecord> records) {
    final grouped = <DateTime, List<BloodPressureRecord>>{};
    for (final r in records) {
      final d = DateTime(r.dateTime.year, r.dateTime.month, r.dateTime.day);
      grouped.putIfAbsent(d, () => []).add(r);
    }
    final keys = grouped.keys.toList()..sort((a, b) => b.compareTo(a));
    return [for (final k in keys) MapEntry(k, grouped[k]!)];
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    if (date == today) {
      return '${AppStrings.today}, ${DateFormat('d MMMM', 'ru').format(date)}';
    }
    return DateFormat('d MMMM yyyy, EEEE', 'ru').format(date);
  }
}
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';
import '../../../../core/theme/app_theme.dart';
import '../data/blood_pressure_model.dart';
import 'bloc/home_bloc.dart';
import 'bloc/home_state.dart';
import 'bloc/statistics_cubit.dart';
import 'bloc/statistics_state.dart';

import '../../profile/presentation/bloc/profile_cubit.dart';
import '../../profile/presentation/bloc/profile_state.dart';

class StatisticsScreen extends StatelessWidget {
  const StatisticsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<ProfileCubit, ProfileState>(
      builder: (context, profileState) {
        int targetSys = 120;
        int targetDia = 80;

        if (profileState is ProfileLoaded) {
          targetSys = profileState.profile.targetSystolic;
          targetDia = profileState.profile.targetDiastolic;
        }

        return BlocBuilder<HomeBloc, HomeState>(
          builder: (context, homeState) {
            if (homeState is HomeLoaded) {
              return BlocProvider(
                create: (context) => StatisticsCubit(
                  homeState.records,
                  targetSystolic: targetSys,
                  targetDiastolic: targetDia,
                ),
                child: const _StatisticsView(),
              );
            }
            return const Scaffold(
              body: Center(child: CircularProgressIndicator()),
            );
          },
        );
      },
    );
  }
}

class _StatisticsView extends StatelessWidget {
  const _StatisticsView();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppUI.background,
      appBar: AppBar(
        title: const Text('Р“СЂР°С„РёРєРё',
            style: TextStyle(
                color: Colors.black,
                fontFamily: 'Inter',
                fontWeight: FontWeight.bold)),
        backgroundColor: Colors.white,
        elevation: 0,
        centerTitle: false,
      ),
      body: BlocBuilder<StatisticsCubit, StatisticsState>(
        builder: (context, state) {
          if (state.filteredRecords.isEmpty) {
            return const Center(child: Text("РќРµС‚ РґР°РЅРЅС‹С… Р·Р° СЌС‚РѕС‚ РїРµСЂРёРѕРґ"));
          }

          return SingleChildScrollView(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                _buildAnalyticsCards(state),
                const SizedBox(height: 24),
                _PressureChart(state: state),
                const SizedBox(height: 24),
                _buildPeriodSelector(context, state.period),
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildAnalyticsCards(StatisticsState state) {
    return Row(
      children: [
        _AnalyticsCard(
          title: "РњРёРЅ",
          sys: state.minSys.toInt(),
          dia: state.minDia.toInt(),
          color: Colors.blueAccent,
        ),
        const SizedBox(width: 12),
        _AnalyticsCard(
          title: "РЎСЂРµРґ",
          sys: state.avgSys.toInt(),
          dia: state.avgDia.toInt(),
          color: Colors.green,
        ),
        const SizedBox(width: 12),
        _AnalyticsCard(
          title: "РњР°РєСЃ",
          sys: state.maxSys.toInt(),
          dia: state.maxDia.toInt(),
          color: Colors.redAccent,
        ),
      ],
    );
  }

  Widget _buildPeriodSelector(BuildContext context, StatisticsPeriod current) {
    return Container(
      padding: const EdgeInsets.all(4),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [AppUI.shadow4x2],
      ),
      child: Row(
        children: [
          _PeriodButton(
            title: "7 РґРЅРµР№",
            isSelected: current == StatisticsPeriod.sevenDays,
            onTap: () => context
                .read<StatisticsCubit>()
                .updatePeriod(StatisticsPeriod.sevenDays),
          ),
          _PeriodButton(
            title: "30 РґРЅРµР№",
            isSelected: current == StatisticsPeriod.thirtyDays,
            onTap: () => context
                .read<StatisticsCubit>()
                .updatePeriod(StatisticsPeriod.thirtyDays),
          ),
          _PeriodButton(
            title: "Р’СЃРµ",
            isSelected: current == StatisticsPeriod.all,
            onTap: () => context
                .read<StatisticsCubit>()
                .updatePeriod(StatisticsPeriod.all),
          ),
        ],
      ),
    );
  }
}

class _AnalyticsCard extends StatelessWidget {
  final String title;
  final int sys;
  final int dia;
  final Color color;

  const _AnalyticsCard({
    required this.title,
    required this.sys,
    required this.dia,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(12),
          boxShadow: [AppUI.shadow4x2],
        ),
        child: Column(
          children: [
            Text(title,
                style: TextStyle(
                    fontSize: 12, color: Colors.grey[600], fontFamily: 'Inter')),
            const SizedBox(height: 4),
            Text("$sys/$dia",
                style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: color,
                    fontFamily: 'Inter')),
          ],
        ),
      ),
    );
  }
}

class _PeriodButton extends StatelessWidget {
  final String title;
  final bool isSelected;
  final VoidCallback onTap;

  const _PeriodButton({
    required this.title,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 8),
          decoration: BoxDecoration(
            color: isSelected ? AppUI.primaryBlue : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              title,
              style: TextStyle(
                color: isSelected ? Colors.white : Colors.grey[600],
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                fontFamily: 'Inter',
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _PressureChart extends StatelessWidget {
  final StatisticsState state;
  const _PressureChart({required this.state});

  @override
  Widget build(BuildContext context) {
    final records = state.filteredRecords;
    
    final spotsSys = records.asMap().entries.map((e) {
      return FlSpot(e.key.toDouble(), e.value.systolic.toDouble());
    }).toList();

    final spotsDia = records.asMap().entries.map((e) {
      return FlSpot(e.key.toDouble(), e.value.diastolic.toDouble());
    }).toList();

    return Container(
      height: 350,
      padding: const EdgeInsets.only(right: 16, top: 16, bottom: 8),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [AppUI.shadow4x2],
      ),
      child: LineChart(
        LineChartData(
          gridData: FlGridData(
            show: true,
            drawVerticalLine: false,
            horizontalInterval: 20,
            getDrawingHorizontalLine: (value) {
              return FlLine(
                color: Colors.grey.withOpacity(0.1),
                strokeWidth: 1,
              );
            },
          ),
          titlesData: FlTitlesData(
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                getTitlesWidget: (value, meta) {
                  final index = value.toInt();
                  if (index >= 0 && index < records.length) {
                    if (index == 0 || index == records.length - 1 || (records.length > 5 && index % (records.length ~/ 4) == 0)) {
                      return Padding(
                        padding: const EdgeInsets.only(top: 8.0),
                        child: Text(
                          DateFormat('d.MM').format(records[index].dateTime),
                          style: TextStyle(fontSize: 10, color: Colors.grey[600]),
                        ),
                      );
                    }
                  }
                  return const SizedBox.shrink();
                },
                interval: 1,
              ),
            ),
            leftTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true, 
                reservedSize: 40,
                getTitlesWidget: (value, meta) {
                  return Text(value.toInt().toString(),
                    style: TextStyle(fontSize: 10, color: Colors.grey[600]));
                }
              ),
            ),
            topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
            rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          ),
          borderData: FlBorderData(show: false),
          minX: 0,
          maxX: (records.length - 1).toDouble(),
          minY: 40,
          maxY: 200,
          extraLinesData: ExtraLinesData(
            horizontalLines: [
              HorizontalLine(
                y: state.targetSystolic.toDouble(),
                color: Colors.redAccent.withOpacity(0.5),
                strokeWidth: 1,
                dashArray: [5, 5],
                label: HorizontalLineLabel(
                  show: true,
                  alignment: Alignment.topRight,
                  padding: const EdgeInsets.only(right: 5, bottom: 2),
                  style: const TextStyle(fontSize: 9, color: Colors.redAccent),
                  labelResolver: (line) => '${state.targetSystolic}',
                ),
              ),
              HorizontalLine(
                y: state.targetDiastolic.toDouble(),
                color: Colors.blueAccent.withOpacity(0.5),
                strokeWidth: 1,
                dashArray: [5, 5],
                label: HorizontalLineLabel(
                  show: true,
                  alignment: Alignment.topRight,
                  padding: const EdgeInsets.only(right: 5, bottom: 2),
                  style: const TextStyle(fontSize: 9, color: Colors.blueAccent),
                  labelResolver: (line) => '${state.targetDiastolic}',
                ),
              ),
            ],
          ),
          lineBarsData: [
            LineChartBarData(
              spots: spotsSys,
              isCurved: true,
              color: Colors.redAccent,
              barWidth: 3,
              isStrokeCapRound: true,
              dotData: FlDotData(
                show: true,
                getDotPainter: (spot, percent, barData, index) => FlDotCirclePainter(
                  radius: 3,
                  color: Colors.white,
                  strokeWidth: 2,
                  strokeColor: Colors.redAccent,
                ),
              ),
              belowBarData: BarAreaData(
                show: true,
                gradient: LinearGradient(
                  colors: [
                    Colors.redAccent.withOpacity(0.2),
                    Colors.redAccent.withOpacity(0.0),
                  ],
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                ),
              ),
            ),
            LineChartBarData(
              spots: spotsDia,
              isCurved: true,
              color: Colors.blueAccent,
              barWidth: 3,
              isStrokeCapRound: true,
              dotData: FlDotData(
                show: true,
                getDotPainter: (spot, percent, barData, index) => FlDotCirclePainter(
                  radius: 3,
                  color: Colors.white,
                  strokeWidth: 2,
                  strokeColor: Colors.blueAccent,
                ),
              ),
              belowBarData: BarAreaData(
                show: true,
                gradient: LinearGradient(
                  colors: [
                    Colors.blueAccent.withOpacity(0.2),
                    Colors.blueAccent.withOpacity(0.0),
                  ],
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                ),
              ),
            ),
          ],
          lineTouchData: LineTouchData(
            touchTooltipData: LineTouchTooltipData(
              getTooltipColor: (touchedSpot) => Colors.blueGrey.withOpacity(0.8),
              getTooltipItems: (touchedSpots) {
                return touchedSpots.map((spot) {
                  final record = records[spot.x.toInt()];
                  final dateStr = DateFormat('dd.MM HH:mm').format(record.dateTime);
                  return LineTooltipItem(
                    '$dateStr\n${spot.y.toInt()} mmHg',
                    const TextStyle(color: Colors.white, fontSize: 10),
                  );
                }).toList();
              },
            ),
          ),
        ),
      ),
    );
  }
}
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:isar/isar.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';
import 'package:blood_pressure_diary/features/profile/presentation/bloc/profile_state.dart';

class ProfileCubit extends Cubit<ProfileState> {
  final Isar isar;

  ProfileCubit(this.isar) : super(ProfileInitial());

  Future<void> loadProfile() async {
    emit(ProfileLoading());
    try {
      final profile = await isar.userProfiles.get(0);
      if (profile != null) {
        emit(ProfileLoaded(profile));
      } else {
        final defaultProfile = UserProfile();
        await isar.writeTxn(() async {
          await isar.userProfiles.put(defaultProfile);
        });
        emit(ProfileLoaded(defaultProfile));
      }
    } catch (e) {
      emit(ProfileError(e.toString()));
    }
  }

  Future<void> updateProfile({
    String? name,
    int? age,
    String? gender,
    double? weight,
    int? targetSystolic,
    int? targetDiastolic,
  }) async {
    if (state is ProfileLoaded) {
      final currentProfile = (state as ProfileLoaded).profile;
      
      final updatedProfile = UserProfile()
        ..id = 0
        ..name = name ?? currentProfile.name
        ..age = age ?? currentProfile.age
        ..gender = gender ?? currentProfile.gender
        ..weight = weight ?? currentProfile.weight
        ..targetSystolic = targetSystolic ?? currentProfile.targetSystolic
        ..targetDiastolic = targetDiastolic ?? currentProfile.targetDiastolic;

      await isar.writeTxn(() async {
        await isar.userProfiles.put(updatedProfile);
      });
      
      emit(ProfileLoaded(updatedProfile));
    }
  }
}
import 'package:equatable/equatable.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';

abstract class ProfileState extends Equatable {
  const ProfileState();

  @override
  List<Object?> get props => [];
}

class ProfileInitial extends ProfileState {}

class ProfileLoading extends ProfileState {}

class ProfileLoaded extends ProfileState {
  final UserProfile profile;

  const ProfileLoaded(this.profile);

  @override
  List<Object?> get props => [profile.name, profile.age, profile.gender, profile.weight, profile.targetSystolic, profile.targetDiastolic];
}

class ProfileError extends ProfileState {
  final String message;

  const ProfileError(this.message);

  @override
  List<Object?> get props => [message];
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:blood_pressure_diary/core/di/service_locator.dart';
import 'package:blood_pressure_diary/core/theme/app_theme.dart';
import 'package:blood_pressure_diary/features/profile/presentation/bloc/profile_cubit.dart';
import 'package:blood_pressure_diary/features/profile/presentation/bloc/profile_state.dart';
import 'package:blood_pressure_diary/l10n/generated/app_localizations.dart';

class ProfileScreen extends StatelessWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const ProfileView();
  }
}

class ProfileView extends StatefulWidget {
  const ProfileView({super.key});

  @override
  State<ProfileView> createState() => _ProfileViewState();
}

class _ProfileViewState extends State<ProfileView> {
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _ageController = TextEditingController();
  final TextEditingController _weightController = TextEditingController();

  @override
  void dispose() {
    _nameController.dispose();
    _ageController.dispose();
    _weightController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: AppUI.background,
      appBar: AppBar(
        title: Text(
          l10n.profile,
          style: const TextStyle(
            color: Colors.black,
            fontFamily: 'Inter',
            fontWeight: FontWeight.bold,
          ),
        ),
        backgroundColor: Colors.white,
        elevation: 0,
      ),
      body: BlocConsumer<ProfileCubit, ProfileState>(
        listener: (context, state) {
          if (state is ProfileLoaded) {
            _nameController.text = state.profile.name;
            _ageController.text = state.profile.age > 0 ? state.profile.age.toString() : '';
            _weightController.text = state.profile.weight > 0 ? state.profile.weight.toString() : '';
          }
        },
        builder: (context, state) {
          if (state is ProfileLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          if (state is ProfileLoaded) {
            final profile = state.profile;
            return SingleChildScrollView(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  const SizedBox(height: 20),
                  const CircleAvatar(
                    radius: 50,
                    backgroundColor: AppUI.headerBlue,
                    child: Icon(Icons.person, size: 60, color: Colors.white),
                  ),
                  const SizedBox(height: 16),
                  TextField(
                    controller: _nameController,
                    textAlign: TextAlign.center,
                    decoration: InputDecoration(
                      hintText: l10n.name,
                      border: InputBorder.none,
                      hintStyle: const TextStyle(fontFamily: 'Inter'),
                    ),
                    style: const TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      fontFamily: 'Inter',
                    ),
                    onChanged: (value) => context.read<ProfileCubit>().updateProfile(name: value),
                  ),
                  const SizedBox(height: 32),
                  _buildProfileFields(context, profile, l10n),
                  const SizedBox(height: 32),
                  _buildGoalSection(context, profile, l10n),
                  const SizedBox(height: 32),
                  _buildPremiumCard(l10n),
                  const SizedBox(height: 40),
                ],
              ),
            );
          }

          return const SizedBox.shrink();
        },
      ),
    );
  }

  Widget _buildProfileFields(BuildContext context, dynamic profile, AppLocalizations l10n) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          _buildFieldRow(
            l10n.age,
            TextField(
              controller: _ageController,
              keyboardType: TextInputType.number,
              textAlign: TextAlign.end,
              decoration: const InputDecoration(border: InputBorder.none),
              onChanged: (value) {
                final age = int.tryParse(value) ?? 0;
                context.read<ProfileCubit>().updateProfile(age: age);
              },
            ),
          ),
          const Divider(),
          _buildFieldRow(
            l10n.weight,
            TextField(
              controller: _weightController,
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              textAlign: TextAlign.end,
              decoration: const InputDecoration(border: InputBorder.none),
              onChanged: (value) {
                final weight = double.tryParse(value) ?? 0.0;
                context.read<ProfileCubit>().updateProfile(weight: weight);
              },
            ),
          ),
          const Divider(),
          _buildFieldRow(
            l10n.gender,
            DropdownButton<String>(
              value: profile.gender,
              underline: const SizedBox(),
              items: [
                DropdownMenuItem(value: 'male', child: Text(l10n.male)),
                DropdownMenuItem(value: 'female', child: Text(l10n.female)),
                DropdownMenuItem(value: 'other', child: Text(l10n.other)),
              ],
              onChanged: (value) {
                if (value != null) {
                  context.read<ProfileCubit>().updateProfile(gender: value);
                }
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFieldRow(String label, Widget trailing) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(
              fontFamily: 'Inter',
              fontSize: 16,
              color: Colors.grey,
            ),
          ),
          SizedBox(width: 100, child: trailing),
        ],
      ),
    );
  }

  Widget _buildGoalSection(BuildContext context, dynamic profile, AppLocalizations l10n) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 4, bottom: 12),
          child: Text(
            l10n.myGoal,
            style: const TextStyle(
              fontFamily: 'Inter',
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: AppUI.headerBlue,
            ),
          ),
        ),
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              _buildTargetInput(
                context,
                l10n.systolic,
                profile.targetSystolic,
                (val) => context.read<ProfileCubit>().updateProfile(targetSystolic: val),
              ),
              const Divider(),
              _buildTargetInput(
                context,
                l10n.diastolic,
                profile.targetDiastolic,
                (val) => context.read<ProfileCubit>().updateProfile(targetDiastolic: val),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTargetInput(BuildContext context, String label, int value, Function(int) onChanged) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label, style: const TextStyle(fontFamily: 'Inter')),
        Row(
          children: [
            IconButton(
              icon: const Icon(Icons.remove_circle_outline),
              onPressed: () => onChanged(value - 1),
            ),
            Text(
              '$value',
              style: const TextStyle(
                fontFamily: 'Inter',
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            IconButton(
              icon: const Icon(Icons.add_circle_outline),
              onPressed: () => onChanged(value + 1),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildPremiumCard(AppLocalizations l10n) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [AppUI.headerBlue, Color(0xFF64B5F6)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: AppUI.headerBlue.withOpacity(0.3),
            blurRadius: 15,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.star, color: Colors.amber, size: 30),
              const SizedBox(width: 8),
              Text(
                l10n.premium,
                style: const TextStyle(
                  fontFamily: 'Inter',
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            l10n.oneTimePayment,
            style: const TextStyle(
              fontFamily: 'Inter',
              color: Colors.white,
              fontSize: 16,
            ),
          ),
          const SizedBox(height: 20),
          ElevatedButton(
            onPressed: () {},
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.white,
              foregroundColor: AppUI.headerBlue,
              minimumSize: const Size(double.infinity, 50),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              elevation: 0,
            ),
            child: Text(
              l10n.buyPremium,
              style: const TextStyle(
                fontFamily: 'Inter',
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:isar/isar.dart';

part 'settings_model.g.dart';

@collection
class AppSettings {
  Id id = 0; // Р’СЃРµРіРґР° 0, С‚Р°Рє РєР°Рє Сѓ РЅР°СЃ С‚РѕР»СЊРєРѕ РѕРґРЅР° Р·Р°РїРёСЃСЊ РЅР°СЃС‚СЂРѕРµРє

  @enumerated
  AppThemeMode themeMode = AppThemeMode.light;

  String languageCode = 'ru';

  List<String> reminders = [];

  bool notificationsEnabled = false;

  AppSettings({
    this.themeMode = AppThemeMode.light,
    this.languageCode = 'ru',
    this.reminders = const [],
    this.notificationsEnabled = false,
  });
}

enum AppThemeMode {
  light,
  dark,
  system,
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'settings_model.dart';

// **************************************************************************
// IsarCollectionGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: duplicate_ignore, non_constant_identifier_names, constant_identifier_names, invalid_use_of_protected_member, unnecessary_cast, prefer_const_constructors, lines_longer_than_80_chars, require_trailing_commas, inference_failure_on_function_invocation, unnecessary_parenthesis, unnecessary_raw_strings, unnecessary_null_checks, join_return_with_assignment, prefer_final_locals, avoid_js_rounded_ints, avoid_positional_boolean_parameters, always_specify_types

extension GetAppSettingsCollection on Isar {
  IsarCollection<AppSettings> get appSettings => this.collection();
}

const AppSettingsSchema = CollectionSchema(
  name: r'AppSettings',
  id: -5633561779022347008,
  properties: {
    r'languageCode': PropertySchema(
      id: 0,
      name: r'languageCode',
      type: IsarType.string,
    ),
    r'notificationsEnabled': PropertySchema(
      id: 1,
      name: r'notificationsEnabled',
      type: IsarType.bool,
    ),
    r'reminders': PropertySchema(
      id: 2,
      name: r'reminders',
      type: IsarType.stringList,
    ),
    r'themeMode': PropertySchema(
      id: 3,
      name: r'themeMode',
      type: IsarType.byte,
      enumMap: _AppSettingsthemeModeEnumValueMap,
    )
  },
  estimateSize: _appSettingsEstimateSize,
  serialize: _appSettingsSerialize,
  deserialize: _appSettingsDeserialize,
  deserializeProp: _appSettingsDeserializeProp,
  idName: r'id',
  indexes: {},
  links: {},
  embeddedSchemas: {},
  getId: _appSettingsGetId,
  getLinks: _appSettingsGetLinks,
  attach: _appSettingsAttach,
  version: '3.1.0+1',
);

int _appSettingsEstimateSize(
  AppSettings object,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  var bytesCount = offsets.last;
  bytesCount += 3 + object.languageCode.length * 3;
  bytesCount += 3 + object.reminders.length * 3;
  {
    for (var i = 0; i < object.reminders.length; i++) {
      final value = object.reminders[i];
      bytesCount += value.length * 3;
    }
  }
  return bytesCount;
}

void _appSettingsSerialize(
  AppSettings object,
  IsarWriter writer,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  writer.writeString(offsets[0], object.languageCode);
  writer.writeBool(offsets[1], object.notificationsEnabled);
  writer.writeStringList(offsets[2], object.reminders);
  writer.writeByte(offsets[3], object.themeMode.index);
}

AppSettings _appSettingsDeserialize(
  Id id,
  IsarReader reader,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  final object = AppSettings(
    languageCode: reader.readStringOrNull(offsets[0]) ?? 'ru',
    notificationsEnabled: reader.readBoolOrNull(offsets[1]) ?? false,
    reminders: reader.readStringList(offsets[2]) ?? const [],
    themeMode:
        _AppSettingsthemeModeValueEnumMap[reader.readByteOrNull(offsets[3])] ??
            AppThemeMode.light,
  );
  object.id = id;
  return object;
}

P _appSettingsDeserializeProp<P>(
  IsarReader reader,
  int propertyId,
  int offset,
  Map<Type, List<int>> allOffsets,
) {
  switch (propertyId) {
    case 0:
      return (reader.readStringOrNull(offset) ?? 'ru') as P;
    case 1:
      return (reader.readBoolOrNull(offset) ?? false) as P;
    case 2:
      return (reader.readStringList(offset) ?? const []) as P;
    case 3:
      return (_AppSettingsthemeModeValueEnumMap[
              reader.readByteOrNull(offset)] ??
          AppThemeMode.light) as P;
    default:
      throw IsarError('Unknown property with id $propertyId');
  }
}

const _AppSettingsthemeModeEnumValueMap = {
  'light': 0,
  'dark': 1,
  'system': 2,
};
const _AppSettingsthemeModeValueEnumMap = {
  0: AppThemeMode.light,
  1: AppThemeMode.dark,
  2: AppThemeMode.system,
};

Id _appSettingsGetId(AppSettings object) {
  return object.id;
}

List<IsarLinkBase<dynamic>> _appSettingsGetLinks(AppSettings object) {
  return [];
}

void _appSettingsAttach(
    IsarCollection<dynamic> col, Id id, AppSettings object) {
  object.id = id;
}

extension AppSettingsQueryWhereSort
    on QueryBuilder<AppSettings, AppSettings, QWhere> {
  QueryBuilder<AppSettings, AppSettings, QAfterWhere> anyId() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(const IdWhereClause.any());
    });
  }
}

extension AppSettingsQueryWhere
    on QueryBuilder<AppSettings, AppSettings, QWhereClause> {
  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: id,
        upper: id,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idNotEqualTo(
      Id id) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            )
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            );
      } else {
        return query
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            )
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            );
      }
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idGreaterThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.greaterThan(lower: id, includeLower: include),
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idLessThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.lessThan(upper: id, includeUpper: include),
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idBetween(
    Id lowerId,
    Id upperId, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: lowerId,
        includeLower: includeLower,
        upper: upperId,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension AppSettingsQueryFilter
    on QueryBuilder<AppSettings, AppSettings, QFilterCondition> {
  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idEqualTo(
      Id value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idGreaterThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idLessThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idBetween(
    Id lower,
    Id upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'id',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'languageCode',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'languageCode',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'languageCode',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'languageCode',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      notificationsEnabledEqualTo(bool value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'notificationsEnabled',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'reminders',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'reminders',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'reminders',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'reminders',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthEqualTo(int length) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        length,
        true,
        length,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        0,
        true,
        0,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        0,
        false,
        999999,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthLessThan(
    int length, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        0,
        true,
        length,
        include,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthGreaterThan(
    int length, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        length,
        include,
        999999,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        lower,
        includeLower,
        upper,
        includeUpper,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeEqualTo(AppThemeMode value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'themeMode',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeGreaterThan(
    AppThemeMode value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'themeMode',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeLessThan(
    AppThemeMode value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'themeMode',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeBetween(
    AppThemeMode lower,
    AppThemeMode upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'themeMode',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension AppSettingsQueryObject
    on QueryBuilder<AppSettings, AppSettings, QFilterCondition> {}

extension AppSettingsQueryLinks
    on QueryBuilder<AppSettings, AppSettings, QFilterCondition> {}

extension AppSettingsQuerySortBy
    on QueryBuilder<AppSettings, AppSettings, QSortBy> {
  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByLanguageCode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByLanguageCodeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByNotificationsEnabled() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByNotificationsEnabledDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByThemeMode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByThemeModeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.desc);
    });
  }
}

extension AppSettingsQuerySortThenBy
    on QueryBuilder<AppSettings, AppSettings, QSortThenBy> {
  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenById() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByIdDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByLanguageCode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByLanguageCodeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByNotificationsEnabled() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByNotificationsEnabledDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByThemeMode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByThemeModeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.desc);
    });
  }
}

extension AppSettingsQueryWhereDistinct
    on QueryBuilder<AppSettings, AppSettings, QDistinct> {
  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByLanguageCode(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'languageCode', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct>
      distinctByNotificationsEnabled() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'notificationsEnabled');
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByReminders() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'reminders');
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByThemeMode() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'themeMode');
    });
  }
}

extension AppSettingsQueryProperty
    on QueryBuilder<AppSettings, AppSettings, QQueryProperty> {
  QueryBuilder<AppSettings, int, QQueryOperations> idProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'id');
    });
  }

  QueryBuilder<AppSettings, String, QQueryOperations> languageCodeProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'languageCode');
    });
  }

  QueryBuilder<AppSettings, bool, QQueryOperations>
      notificationsEnabledProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'notificationsEnabled');
    });
  }

  QueryBuilder<AppSettings, List<String>, QQueryOperations>
      remindersProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'reminders');
    });
  }

  QueryBuilder<AppSettings, AppThemeMode, QQueryOperations>
      themeModeProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'themeMode');
    });
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:isar/isar.dart';
import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';
import 'package:blood_pressure_diary/features/home/presentation/bloc/home_bloc.dart';
import 'package:blood_pressure_diary/features/home/presentation/bloc/home_event.dart';
import 'package:blood_pressure_diary/features/settings/data/models/settings_model.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_state.dart';
import 'package:blood_pressure_diary/core/services/export_service.dart';
import 'package:blood_pressure_diary/core/services/notification_service.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:in_app_review/in_app_review.dart';

class SettingsCubit extends Cubit<SettingsState> {
  final Isar isar;
  final ExportService _exportService;
  final NotificationService _notificationService;
  final HomeBloc? _homeBloc;

  SettingsCubit(this.isar, this._exportService, this._notificationService, {HomeBloc? homeBloc})
      : _homeBloc = homeBloc,
        super(SettingsState(AppSettings())) {
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final settings = await isar.appSettings.get(0);
    if (settings != null) {
      emit(SettingsState(settings));
    } else {
      final defaultSettings = AppSettings();
      await isar.writeTxn(() async {
        await isar.appSettings.put(defaultSettings);
      });
      emit(SettingsState(defaultSettings));
    }
  }

  Future<void> changeLanguage(String langCode) async {
    final newSettings = AppSettings(
      themeMode: state.settings.themeMode,
      languageCode: langCode,
      reminders: state.settings.reminders,
      notificationsEnabled: state.settings.notificationsEnabled,
    );
    await isar.writeTxn(() async {
      await isar.appSettings.put(newSettings);
    });
    emit(SettingsState(newSettings));
  }

  Future<void> setThemeMode(AppThemeMode mode) async {
    final newSettings = AppSettings(
      themeMode: mode,
      languageCode: state.settings.languageCode,
      reminders: state.settings.reminders,
      notificationsEnabled: state.settings.notificationsEnabled,
    );
    await isar.writeTxn(() async {
      await isar.appSettings.put(newSettings);
    });
    emit(SettingsState(newSettings));
  }

  Future<void> addReminder(TimeOfDay time) async {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    final timeStr = "$hour:$minute";

    if (state.settings.reminders.contains(timeStr)) return;

    final newList = List<String>.from(state.settings.reminders)..add(timeStr);
    newList.sort();

    final newSettings = AppSettings(
      themeMode: state.settings.themeMode,
      languageCode: state.settings.languageCode,
      reminders: newList,
      notificationsEnabled: state.settings.notificationsEnabled,
    );

    await isar.writeTxn(() async {
      await isar.appSettings.put(newSettings);
    });
    
    if (state.settings.notificationsEnabled) {
      final id = timeStr.hashCode;
      await _notificationService.scheduleDailyNotification(id, time);
    }
    
    emit(SettingsState(newSettings));
  }

  Future<void> removeReminder(int index) async {
    final timeStr = state.settings.reminders[index];
    final newList = List<String>.from(state.settings.reminders)..removeAt(index);

    final newSettings = AppSettings(
      themeMode: state.settings.themeMode,
      languageCode: state.settings.languageCode,
      reminders: newList,
      notificationsEnabled: state.settings.notificationsEnabled,
    );

    await isar.writeTxn(() async {
      await isar.appSettings.put(newSettings);
    });
    
    if (state.settings.notificationsEnabled) {
      await _notificationService.cancelNotification(timeStr.hashCode);
    }
    
    emit(SettingsState(newSettings));
  }

  Future<void> toggleNotifications(bool enabled) async {
    if (enabled) {
      final granted = await _notificationService.requestPermissions();
      if (!granted) {
        final message = state.settings.languageCode == 'ru' 
            ? 'Р Р°Р·СЂРµС€РµРЅРёРµ РЅР° СѓРІРµРґРѕРјР»РµРЅРёСЏ РЅРµ РїРѕР»СѓС‡РµРЅРѕ' 
            : 'Notification permission not granted';
        emit(state.copyWith(errorMessage: message));
        emit(state.copyWith(errorMessage: null));
        return;
      }
    }

    final newSettings = AppSettings(
      themeMode: state.settings.themeMode,
      languageCode: state.settings.languageCode,
      reminders: state.settings.reminders,
      notificationsEnabled: enabled,
    );

    await isar.writeTxn(() async {
      await isar.appSettings.put(newSettings);
    });

    if (enabled) {
      await _syncAllNotifications(state.settings.reminders);
    } else {
      await _notificationService.cancelAllNotifications();
    }

    emit(SettingsState(newSettings));
  }

  Future<void> _syncAllNotifications(List<String> reminders) async {
    await _notificationService.cancelAllNotifications();
    for (final timeStr in reminders) {
      final parts = timeStr.split(':');
      final time = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
      await _notificationService.scheduleDailyNotification(timeStr.hashCode, time);
    }
  }

  Future<void> exportData(ExportFormat format) async {
    final records = await isar.bloodPressureRecords.where().sortByDateTimeDesc().findAll();
    
    if (records.isEmpty) {
      final message = state.settings.languageCode == 'ru' 
          ? 'РќРµС‚ РґР°РЅРЅС‹С… РґР»СЏ СЌРєСЃРїРѕСЂС‚Р°' 
          : 'No data to export';
      emit(state.copyWith(errorMessage: message));
      // РЎР±СЂР°СЃС‹РІР°РµРј РѕС€РёР±РєСѓ СЃСЂР°Р·Сѓ, С‡С‚РѕР±С‹ SnackBar РЅРµ РїРѕРєР°Р·С‹РІР°Р»СЃСЏ РїРѕРІС‚РѕСЂРЅРѕ РїСЂРё РґСЂСѓРіРёС… РґРµР№СЃС‚РІРёСЏС…
      emit(state.copyWith(errorMessage: null));
      return;
    }

    emit(state.copyWith(isExporting: true));
    try {
      await _exportService.exportData(records, format, state.settings.languageCode);
    } catch (e) {
      final message = state.settings.languageCode == 'ru' 
          ? 'РћС€РёР±РєР° РїСЂРё СЌРєСЃРїРѕСЂС‚Рµ: $e' 
          : 'Export error: $e';
      emit(state.copyWith(errorMessage: message));
      emit(state.copyWith(errorMessage: null));
    } finally {
      emit(state.copyWith(isExporting: false));
    }
  }

  Future<void> clearAllData() async {
    await isar.writeTxn(() async {
      await isar.bloodPressureRecords.clear();
    });
    _homeBloc?.add(LoadHomeData());
  }

  Future<void> contactSupport() async {
    final Uri emailLaunchUri = Uri(
      scheme: 'mailto',
      path: 'your_email@mail.com',
      query: 'subject=Blood Pressure Diary Feedback',
    );
    if (await canLaunchUrl(emailLaunchUri)) {
      await launchUrl(emailLaunchUri);
    }
  }

  Future<void> rateApp() async {
    final InAppReview inAppReview = InAppReview.instance;
    if (await inAppReview.isAvailable()) {
      await inAppReview.requestReview();
    } else {
      await inAppReview.openStoreListing();
    }
  }
}
import 'package:equatable/equatable.dart';
import '../../data/models/settings_model.dart';

class SettingsState extends Equatable {
  final AppSettings settings;
  final String? errorMessage;
  final bool isExporting;

  const SettingsState(this.settings, {this.errorMessage, this.isExporting = false});

  SettingsState copyWith({
    AppSettings? settings,
    String? errorMessage,
    bool? isExporting,
  }) {
    return SettingsState(
      settings ?? this.settings,
      errorMessage: errorMessage,
      isExporting: isExporting ?? this.isExporting,
    );
  }

  @override
  List<Object?> get props => [settings.themeMode, settings.languageCode, errorMessage, isExporting];
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:blood_pressure_diary/l10n/generated/app_localizations.dart';
import 'package:blood_pressure_diary/core/theme/app_theme.dart';
import 'package:blood_pressure_diary/features/settings/data/models/settings_model.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_cubit.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_state.dart';
import 'package:blood_pressure_diary/core/services/export_service.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return BlocListener<SettingsCubit, SettingsState>(
      listener: (context, state) {
        if (state.errorMessage != null) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(state.errorMessage!),
              backgroundColor: state.errorMessage!.contains('РћС€РёР±РєР°') || state.errorMessage!.contains('error') 
                  ? Colors.red 
                  : Colors.orange,
            ),
          );
        }
      },
      child: BlocBuilder<SettingsCubit, SettingsState>(
        builder: (context, state) {
          return Scaffold(
            backgroundColor: AppUI.background,
            appBar: AppBar(
              title: Text(
                l10n.settings,
                style: const TextStyle(
                  color: Colors.black,
                  fontFamily: 'Inter',
                  fontWeight: FontWeight.bold,
                ),
              ),
              backgroundColor: Colors.white,
              elevation: 0,
              leading: IconButton(
                icon: const Icon(Icons.arrow_back, color: Colors.black),
                onPressed: () => Navigator.pop(context),
              ),
            ),
            body: Stack(
              children: [
                ListView(
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
                  children: [
                    _buildSectionTitle(l10n.theme),
                    _buildThemeSelector(context, state.settings.themeMode, l10n),
                    const Divider(),
                    SwitchListTile(
                      title: Text(
                        l10n.notifications,
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                      value: state.settings.notificationsEnabled,
                      onChanged: (bool value) {
                        context.read<SettingsCubit>().toggleNotifications(value);
                      },
                      activeColor: AppUI.headerBlue,
                    ),
                    _buildSectionTitle(l10n.reminders),
                    ...state.settings.reminders.asMap().entries.map((entry) {
                      return ListTile(
                        title: Text(entry.value),
                        trailing: IconButton(
                          icon: const Icon(Icons.delete_outline, color: Colors.red),
                          onPressed: () => context.read<SettingsCubit>().removeReminder(entry.key),
                        ),
                      );
                    }),
                    ListTile(
                      leading: const Icon(Icons.add),
                      title: Text(l10n.addReminder),
                      onTap: () async {
                        final time = await showTimePicker(
                          context: context,
                          initialTime: TimeOfDay.now(),
                        );
                        if (time != null && context.mounted) {
                          context.read<SettingsCubit>().addReminder(time);
                        }
                      },
                    ),
                    const Divider(),
                    _buildSectionTitle(l10n.export),
                    ListTile(
                      leading: const Icon(Icons.share_outlined),
                      title: Text(l10n.export),
                      onTap: state.isExporting ? null : () => _showExportBottomSheet(context, l10n),
                      trailing: state.isExporting ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)) : null,
                    ),
                    const Divider(),
                    _buildSectionTitle(l10n.contactSupport),
                    ListTile(
                      leading: const Icon(Icons.mail_outline),
                      title: Text(l10n.contactSupport),
                      onTap: () => context.read<SettingsCubit>().contactSupport(),
                    ),
                    ListTile(
                      leading: const Icon(Icons.star_outline),
                      title: Text(l10n.rateApp),
                      onTap: () => context.read<SettingsCubit>().rateApp(),
                    ),
                    const Divider(),
                    ListTile(
                      leading: const Icon(Icons.delete_forever, color: Colors.red),
                      title: Text(
                        l10n.clearData,
                        style: const TextStyle(color: Colors.red),
                      ),
                      onTap: () => _showClearDataDialog(context, l10n),
                    ),
                    const SizedBox(height: 40),
                    Center(
                      child: Text(
                        l10n.version('1.0.0'),
                        style: TextStyle(color: Colors.grey[600], fontSize: 14),
                      ),
                    ),
                  ],
                ),
                if (state.isExporting)
                  Container(
                    color: Colors.black.withOpacity(0.1),
                    child: const Center(
                      child: CircularProgressIndicator(),
                    ),
                  ),
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 14,
          fontWeight: FontWeight.bold,
          color: AppUI.headerBlue,
        ),
      ),
    );
  }

  Widget _buildThemeSelector(BuildContext context, AppThemeMode currentMode, AppLocalizations l10n) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: SegmentedButton<AppThemeMode>(
        segments: [
          ButtonSegment(value: AppThemeMode.light, label: Text(l10n.light)),
          ButtonSegment(value: AppThemeMode.dark, label: Text(l10n.dark)),
          ButtonSegment(value: AppThemeMode.system, label: Text(l10n.system)),
        ],
        selected: {currentMode},
        onSelectionChanged: (Set<AppThemeMode> newSelection) {
          context.read<SettingsCubit>().setThemeMode(newSelection.first);
        },
      ),
    );
  }

  void _showExportBottomSheet(BuildContext context, AppLocalizations l10n) {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(
                l10n.export,
                style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
            ),
            ListTile(
              leading: const Icon(Icons.picture_as_pdf_outlined, color: AppUI.accentRed),
              title: Text(l10n.exportPDF),
              onTap: () {
                Navigator.pop(context);
                context.read<SettingsCubit>().exportData(ExportFormat.pdf);
              },
            ),
            ListTile(
              leading: const Icon(Icons.description_outlined, color: Colors.green),
              title: Text(l10n.exportCSV),
              onTap: () {
                Navigator.pop(context);
                context.read<SettingsCubit>().exportData(ExportFormat.csv);
              },
            ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }

  void _showClearDataDialog(BuildContext context, AppLocalizations l10n) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.clearData),
        content: Text(l10n.clearDataConfirm),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: Text(l10n.no),
          ),
          TextButton(
            onPressed: () {
              context.read<SettingsCubit>().clearAllData();
              Navigator.pop(ctx);
            },
            child: Text(
              l10n.yes,
              style: const TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );
  }
}
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_en.dart';
import 'app_localizations_ru.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'generated/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, youвЂ™ll need to edit this
/// file.
///
/// First, open your projectвЂ™s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// projectвЂ™s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
    : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
        delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('en'),
    Locale('ru'),
  ];

  /// No description provided for @settings.
  ///
  /// In ru, this message translates to:
  /// **'РќР°СЃС‚СЂРѕР№РєРё'**
  String get settings;

  /// No description provided for @selectLanguage.
  ///
  /// In ru, this message translates to:
  /// **'Р’С‹Р±РѕСЂ СЏР·С‹РєР°'**
  String get selectLanguage;

  /// No description provided for @appTitle.
  ///
  /// In ru, this message translates to:
  /// **'Р”РЅРµРІРЅРёРє РґР°РІР»РµРЅРёСЏ'**
  String get appTitle;

  /// No description provided for @notifications.
  ///
  /// In ru, this message translates to:
  /// **'РЈРІРµРґРѕРјР»РµРЅРёСЏ'**
  String get notifications;

  /// No description provided for @clearData.
  ///
  /// In ru, this message translates to:
  /// **'РћС‡РёСЃС‚РёС‚СЊ РґР°РЅРЅС‹Рµ'**
  String get clearData;

  /// No description provided for @aboutApp.
  ///
  /// In ru, this message translates to:
  /// **'Рћ РїСЂРёР»РѕР¶РµРЅРёРё'**
  String get aboutApp;

  /// No description provided for @version.
  ///
  /// In ru, this message translates to:
  /// **'Р’РµСЂСЃРёСЏ {version}'**
  String version(String version);

  /// No description provided for @functionInDevelopment.
  ///
  /// In ru, this message translates to:
  /// **'Р¤СѓРЅРєС†РёСЏ РІ СЂР°Р·СЂР°Р±РѕС‚РєРµ'**
  String get functionInDevelopment;

  /// No description provided for @deleteRecordQ.
  ///
  /// In ru, this message translates to:
  /// **'РЈРґР°Р»РёС‚СЊ Р·Р°РїРёСЃСЊ?'**
  String get deleteRecordQ;

  /// No description provided for @cannotUndo.
  ///
  /// In ru, this message translates to:
  /// **'Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.'**
  String get cannotUndo;

  /// No description provided for @cancel.
  ///
  /// In ru, this message translates to:
  /// **'РћС‚РјРµРЅР°'**
  String get cancel;

  /// No description provided for @delete.
  ///
  /// In ru, this message translates to:
  /// **'РЈРґР°Р»РёС‚СЊ'**
  String get delete;

  /// No description provided for @theme.
  ///
  /// In ru, this message translates to:
  /// **'РўРµРјР°'**
  String get theme;

  /// No description provided for @light.
  ///
  /// In ru, this message translates to:
  /// **'РЎРІРµС‚Р»Р°СЏ'**
  String get light;

  /// No description provided for @dark.
  ///
  /// In ru, this message translates to:
  /// **'РўРµРјРЅР°СЏ'**
  String get dark;

  /// No description provided for @system.
  ///
  /// In ru, this message translates to:
  /// **'РЎРёСЃС‚РµРјРЅР°СЏ'**
  String get system;

  /// No description provided for @reminders.
  ///
  /// In ru, this message translates to:
  /// **'РќР°РїРѕРјРёРЅР°РЅРёСЏ'**
  String get reminders;

  /// No description provided for @addReminder.
  ///
  /// In ru, this message translates to:
  /// **'Р”РѕР±Р°РІРёС‚СЊ РІСЂРµРјСЏ'**
  String get addReminder;

  /// No description provided for @clearDataConfirm.
  ///
  /// In ru, this message translates to:
  /// **'Р’С‹ СѓРІРµСЂРµРЅС‹, С‡С‚Рѕ С…РѕС‚РёС‚Рµ СѓРґР°Р»РёС‚СЊ РІСЃРµ Р·Р°РїРёСЃРё? Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.'**
  String get clearDataConfirm;

  /// No description provided for @yes.
  ///
  /// In ru, this message translates to:
  /// **'Р”Р°'**
  String get yes;

  /// No description provided for @no.
  ///
  /// In ru, this message translates to:
  /// **'РќРµС‚'**
  String get no;

  /// No description provided for @export.
  ///
  /// In ru, this message translates to:
  /// **'Р­РєСЃРїРѕСЂС‚ РґР°РЅРЅС‹С…'**
  String get export;

  /// No description provided for @exportCSV.
  ///
  /// In ru, this message translates to:
  /// **'CSV РўР°Р±Р»РёС†Р°'**
  String get exportCSV;

  /// No description provided for @exportPDF.
  ///
  /// In ru, this message translates to:
  /// **'PDF РћС‚С‡РµС‚'**
  String get exportPDF;

  /// No description provided for @contactSupport.
  ///
  /// In ru, this message translates to:
  /// **'РќР°РїРёСЃР°С‚СЊ РЅР°Рј'**
  String get contactSupport;

  /// No description provided for @rateApp.
  ///
  /// In ru, this message translates to:
  /// **'РћС†РµРЅРёС‚СЊ РїСЂРёР»РѕР¶РµРЅРёРµ'**
  String get rateApp;

  /// No description provided for @supportEmail.
  ///
  /// In ru, this message translates to:
  /// **'your_email@mail.com'**
  String get supportEmail;

  /// No description provided for @profile.
  ///
  /// In ru, this message translates to:
  /// **'РџСЂРѕС„РёР»СЊ'**
  String get profile;

  /// No description provided for @name.
  ///
  /// In ru, this message translates to:
  /// **'РРјСЏ'**
  String get name;

  /// No description provided for @age.
  ///
  /// In ru, this message translates to:
  /// **'Р’РѕР·СЂР°СЃС‚'**
  String get age;

  /// No description provided for @gender.
  ///
  /// In ru, this message translates to:
  /// **'РџРѕР»'**
  String get gender;

  /// No description provided for @weight.
  ///
  /// In ru, this message translates to:
  /// **'Р’РµСЃ'**
  String get weight;

  /// No description provided for @male.
  ///
  /// In ru, this message translates to:
  /// **'РњСѓР¶СЃРєРѕР№'**
  String get male;

  /// No description provided for @female.
  ///
  /// In ru, this message translates to:
  /// **'Р–РµРЅСЃРєРёР№'**
  String get female;

  /// No description provided for @other.
  ///
  /// In ru, this message translates to:
  /// **'Р”СЂСѓРіРѕР№'**
  String get other;

  /// No description provided for @myGoal.
  ///
  /// In ru, this message translates to:
  /// **'РњРѕСЏ С†РµР»СЊ'**
  String get myGoal;

  /// No description provided for @targetPressure.
  ///
  /// In ru, this message translates to:
  /// **'Р¦РµР»РµРІРѕРµ РґР°РІР»РµРЅРёРµ'**
  String get targetPressure;

  /// No description provided for @systolic.
  ///
  /// In ru, this message translates to:
  /// **'РЎРёСЃС‚РѕР»РёС‡РµСЃРєРѕРµ'**
  String get systolic;

  /// No description provided for @diastolic.
  ///
  /// In ru, this message translates to:
  /// **'Р”РёР°СЃС‚РѕР»РёС‡РµСЃРєРѕРµ'**
  String get diastolic;

  /// No description provided for @premium.
  ///
  /// In ru, this message translates to:
  /// **'РџСЂРµРјРёСѓРј'**
  String get premium;

  /// No description provided for @oneTimePayment.
  ///
  /// In ru, this message translates to:
  /// **'Р Р°Р·РѕРІС‹Р№ РїР»Р°С‚РµР¶ 2,99 в‚¬'**
  String get oneTimePayment;

  /// No description provided for @buyPremium.
  ///
  /// In ru, this message translates to:
  /// **'РљСѓРїРёС‚СЊ РџСЂРµРјРёСѓРј'**
  String get buyPremium;

  /// No description provided for @save.
  ///
  /// In ru, this message translates to:
  /// **'РЎРѕС…СЂР°РЅРёС‚СЊ'**
  String get save;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['en', 'ru'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'en':
      return AppLocalizationsEn();
    case 'ru':
      return AppLocalizationsRu();
  }

  throw FlutterError(
    'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
    'an issue with the localizations generation tool. Please file an issue '
    'on GitHub with a reproducible sample app and the gen-l10n configuration '
    'that was used.',
  );
}
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get settings => 'Settings';

  @override
  String get selectLanguage => 'Select Language';

  @override
  String get appTitle => 'Blood Pressure Diary';

  @override
  String get notifications => 'Notifications';

  @override
  String get clearData => 'Clear Data';

  @override
  String get aboutApp => 'About App';

  @override
  String version(String version) {
    return 'Version $version';
  }

  @override
  String get functionInDevelopment => 'Function in development';

  @override
  String get deleteRecordQ => 'Delete record?';

  @override
  String get cannotUndo => 'This action cannot be undone.';

  @override
  String get cancel => 'Cancel';

  @override
  String get delete => 'Delete';

  @override
  String get theme => 'Theme';

  @override
  String get light => 'Light';

  @override
  String get dark => 'Dark';

  @override
  String get system => 'System';

  @override
  String get reminders => 'Reminders';

  @override
  String get addReminder => 'Add time';

  @override
  String get clearDataConfirm =>
      'Are you sure you want to delete all records? This action cannot be undone.';

  @override
  String get yes => 'Yes';

  @override
  String get no => 'No';

  @override
  String get export => 'Export Data';

  @override
  String get exportCSV => 'CSV Spreadsheet';

  @override
  String get exportPDF => 'PDF Report';

  @override
  String get contactSupport => 'Contact Support';

  @override
  String get rateApp => 'Rate App';

  @override
  String get supportEmail => 'your_email@mail.com';

  @override
  String get profile => 'Profile';

  @override
  String get name => 'Name';

  @override
  String get age => 'Age';

  @override
  String get gender => 'Gender';

  @override
  String get weight => 'Weight';

  @override
  String get male => 'Male';

  @override
  String get female => 'Female';

  @override
  String get other => 'Other';

  @override
  String get myGoal => 'My Goal';

  @override
  String get targetPressure => 'Target Pressure';

  @override
  String get systolic => 'Systolic';

  @override
  String get diastolic => 'Diastolic';

  @override
  String get premium => 'Premium';

  @override
  String get oneTimePayment => 'One-time payment 2,99 в‚¬';

  @override
  String get buyPremium => 'Buy Premium';

  @override
  String get save => 'Save';
}
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Russian (`ru`).
class AppLocalizationsRu extends AppLocalizations {
  AppLocalizationsRu([String locale = 'ru']) : super(locale);

  @override
  String get settings => 'РќР°СЃС‚СЂРѕР№РєРё';

  @override
  String get selectLanguage => 'Р’С‹Р±РѕСЂ СЏР·С‹РєР°';

  @override
  String get appTitle => 'Р”РЅРµРІРЅРёРє РґР°РІР»РµРЅРёСЏ';

  @override
  String get notifications => 'РЈРІРµРґРѕРјР»РµРЅРёСЏ';

  @override
  String get clearData => 'РћС‡РёСЃС‚РёС‚СЊ РґР°РЅРЅС‹Рµ';

  @override
  String get aboutApp => 'Рћ РїСЂРёР»РѕР¶РµРЅРёРё';

  @override
  String version(String version) {
    return 'Р’РµСЂСЃРёСЏ $version';
  }

  @override
  String get functionInDevelopment => 'Р¤СѓРЅРєС†РёСЏ РІ СЂР°Р·СЂР°Р±РѕС‚РєРµ';

  @override
  String get deleteRecordQ => 'РЈРґР°Р»РёС‚СЊ Р·Р°РїРёСЃСЊ?';

  @override
  String get cannotUndo => 'Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.';

  @override
  String get cancel => 'РћС‚РјРµРЅР°';

  @override
  String get delete => 'РЈРґР°Р»РёС‚СЊ';

  @override
  String get theme => 'РўРµРјР°';

  @override
  String get light => 'РЎРІРµС‚Р»Р°СЏ';

  @override
  String get dark => 'РўРµРјРЅР°СЏ';

  @override
  String get system => 'РЎРёСЃС‚РµРјРЅР°СЏ';

  @override
  String get reminders => 'РќР°РїРѕРјРёРЅР°РЅРёСЏ';

  @override
  String get addReminder => 'Р”РѕР±Р°РІРёС‚СЊ РІСЂРµРјСЏ';

  @override
  String get clearDataConfirm =>
      'Р’С‹ СѓРІРµСЂРµРЅС‹, С‡С‚Рѕ С…РѕС‚РёС‚Рµ СѓРґР°Р»РёС‚СЊ РІСЃРµ Р·Р°РїРёСЃРё? Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.';

  @override
  String get yes => 'Р”Р°';

  @override
  String get no => 'РќРµС‚';

  @override
  String get export => 'Р­РєСЃРїРѕСЂС‚ РґР°РЅРЅС‹С…';

  @override
  String get exportCSV => 'CSV РўР°Р±Р»РёС†Р°';

  @override
  String get exportPDF => 'PDF РћС‚С‡РµС‚';

  @override
  String get contactSupport => 'РќР°РїРёСЃР°С‚СЊ РЅР°Рј';

  @override
  String get rateApp => 'РћС†РµРЅРёС‚СЊ РїСЂРёР»РѕР¶РµРЅРёРµ';

  @override
  String get supportEmail => 'your_email@mail.com';

  @override
  String get profile => 'РџСЂРѕС„РёР»СЊ';

  @override
  String get name => 'РРјСЏ';

  @override
  String get age => 'Р’РѕР·СЂР°СЃС‚';

  @override
  String get gender => 'РџРѕР»';

  @override
  String get weight => 'Р’РµСЃ';

  @override
  String get male => 'РњСѓР¶СЃРєРѕР№';

  @override
  String get female => 'Р–РµРЅСЃРєРёР№';

  @override
  String get other => 'Р”СЂСѓРіРѕР№';

  @override
  String get myGoal => 'РњРѕСЏ С†РµР»СЊ';

  @override
  String get targetPressure => 'Р¦РµР»РµРІРѕРµ РґР°РІР»РµРЅРёРµ';

  @override
  String get systolic => 'РЎРёСЃС‚РѕР»РёС‡РµСЃРєРѕРµ';

  @override
  String get diastolic => 'Р”РёР°СЃС‚РѕР»РёС‡РµСЃРєРѕРµ';

  @override
  String get premium => 'РџСЂРµРјРёСѓРј';

  @override
  String get oneTimePayment => 'Р Р°Р·РѕРІС‹Р№ РїР»Р°С‚РµР¶ 2,99 в‚¬';

  @override
  String get buyPremium => 'РљСѓРїРёС‚СЊ РџСЂРµРјРёСѓРј';

  @override
  String get save => 'РЎРѕС…СЂР°РЅРёС‚СЊ';
}
import 'package:flutter/material.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:blood_pressure_diary/core/di/service_locator.dart';
import 'package:blood_pressure_diary/core/theme/app_theme.dart';
import 'package:blood_pressure_diary/core/navigation/app_navigation.dart';
import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';
import 'package:blood_pressure_diary/features/settings/data/models/settings_model.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_cubit.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_state.dart';
import 'package:blood_pressure_diary/l10n/generated/app_localizations.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  final dir = await getApplicationDocumentsDirectory();
  final isar = await Isar.open(
    [BloodPressureRecordSchema, AppSettingsSchema, UserProfileSchema],
    directory: dir.path,
  );

  await setupLocator(isar);
  await initializeDateFormatting('ru');

  runApp(const BloodPressureApp());
}

class BloodPressureApp extends StatelessWidget {
  const BloodPressureApp({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => getIt<SettingsCubit>(),
      child: BlocBuilder<SettingsCubit, SettingsState>(
        builder: (context, state) {
          return MaterialApp(
            debugShowCheckedModeBanner: false,
            onGenerateTitle: (context) => AppLocalizations.of(context)!.appTitle,
            theme: AppTheme.lightTheme,
            darkTheme: ThemeData.dark(), // РњРѕР¶РЅРѕ РЅР°СЃС‚СЂРѕРёС‚СЊ РїРѕР·Р¶Рµ
            themeMode: _getThemeMode(state.settings.themeMode),
            locale: Locale(state.settings.languageCode),
            localizationsDelegates: [
              AppLocalizations.delegate,
              GlobalMaterialLocalizations.delegate,
              GlobalWidgetsLocalizations.delegate,
              GlobalCupertinoLocalizations.delegate,
            ],
            supportedLocales: AppLocalizations.supportedLocales,
            home: const AppNavigation(),
          );
        },
      ),
    );
  }

  ThemeMode _getThemeMode(AppThemeMode mode) {
    switch (mode) {
      case AppThemeMode.light:
        return ThemeMode.light;
      case AppThemeMode.dark:
        return ThemeMode.dark;
      case AppThemeMode.system:
        return ThemeMode.system;
    }
  }
}
