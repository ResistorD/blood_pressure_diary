import 'package:isar/isar.dart';

part 'user_profile.g.dart';

@collection
class UserProfile {
  Id id = 0; // Р’СЃРµРіРґР° 0 РґР»СЏ РµРґРёРЅСЃС‚РІРµРЅРЅРѕР№ Р·Р°РїРёСЃРё РїСЂРѕС„РёР»СЏ

  String name = '';
  int age = 0;
  String gender = 'male'; // 'male', 'female', 'other'
  double weight = 0.0;

  int targetSystolic = 120;
  int targetDiastolic = 80;

  // --- Account link (Р»РѕРєР°Р»СЊРЅР°СЏ РїСЂРёРІСЏР·РєР°, СЂРµР°Р»СЊРЅР°СЏ: С…СЂР°РЅРёС‚СЃСЏ РІ Isar)
  bool accountLinked = false;
  String accountEmail = '';
  String accountProvider = ''; // 'email' | 'google' | 'apple'

  UserProfile({
    this.name = '',
    this.age = 0,
    this.gender = 'male',
    this.weight = 0.0,
    this.targetSystolic = 120,
    this.targetDiastolic = 80,
    this.accountLinked = false,
    this.accountEmail = '',
    this.accountProvider = '',
  });
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile.dart';

// **************************************************************************
// IsarCollectionGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: duplicate_ignore, non_constant_identifier_names, constant_identifier_names, invalid_use_of_protected_member, unnecessary_cast, prefer_const_constructors, lines_longer_than_80_chars, require_trailing_commas, inference_failure_on_function_invocation, unnecessary_parenthesis, unnecessary_raw_strings, unnecessary_null_checks, join_return_with_assignment, prefer_final_locals, avoid_js_rounded_ints, avoid_positional_boolean_parameters, always_specify_types

extension GetUserProfileCollection on Isar {
  IsarCollection<UserProfile> get userProfiles => this.collection();
}

const UserProfileSchema = CollectionSchema(
  name: r'UserProfile',
  id: 4738427352541298891,
  properties: {
    r'accountEmail': PropertySchema(
      id: 0,
      name: r'accountEmail',
      type: IsarType.string,
    ),
    r'accountLinked': PropertySchema(
      id: 1,
      name: r'accountLinked',
      type: IsarType.bool,
    ),
    r'accountProvider': PropertySchema(
      id: 2,
      name: r'accountProvider',
      type: IsarType.string,
    ),
    r'age': PropertySchema(
      id: 3,
      name: r'age',
      type: IsarType.long,
    ),
    r'gender': PropertySchema(
      id: 4,
      name: r'gender',
      type: IsarType.string,
    ),
    r'name': PropertySchema(
      id: 5,
      name: r'name',
      type: IsarType.string,
    ),
    r'targetDiastolic': PropertySchema(
      id: 6,
      name: r'targetDiastolic',
      type: IsarType.long,
    ),
    r'targetSystolic': PropertySchema(
      id: 7,
      name: r'targetSystolic',
      type: IsarType.long,
    ),
    r'weight': PropertySchema(
      id: 8,
      name: r'weight',
      type: IsarType.double,
    )
  },
  estimateSize: _userProfileEstimateSize,
  serialize: _userProfileSerialize,
  deserialize: _userProfileDeserialize,
  deserializeProp: _userProfileDeserializeProp,
  idName: r'id',
  indexes: {},
  links: {},
  embeddedSchemas: {},
  getId: _userProfileGetId,
  getLinks: _userProfileGetLinks,
  attach: _userProfileAttach,
  version: '3.1.0+1',
);

int _userProfileEstimateSize(
  UserProfile object,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  var bytesCount = offsets.last;
  bytesCount += 3 + object.accountEmail.length * 3;
  bytesCount += 3 + object.accountProvider.length * 3;
  bytesCount += 3 + object.gender.length * 3;
  bytesCount += 3 + object.name.length * 3;
  return bytesCount;
}

void _userProfileSerialize(
  UserProfile object,
  IsarWriter writer,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  writer.writeString(offsets[0], object.accountEmail);
  writer.writeBool(offsets[1], object.accountLinked);
  writer.writeString(offsets[2], object.accountProvider);
  writer.writeLong(offsets[3], object.age);
  writer.writeString(offsets[4], object.gender);
  writer.writeString(offsets[5], object.name);
  writer.writeLong(offsets[6], object.targetDiastolic);
  writer.writeLong(offsets[7], object.targetSystolic);
  writer.writeDouble(offsets[8], object.weight);
}

UserProfile _userProfileDeserialize(
  Id id,
  IsarReader reader,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  final object = UserProfile(
    accountEmail: reader.readStringOrNull(offsets[0]) ?? '',
    accountLinked: reader.readBoolOrNull(offsets[1]) ?? false,
    accountProvider: reader.readStringOrNull(offsets[2]) ?? '',
    age: reader.readLongOrNull(offsets[3]) ?? 0,
    gender: reader.readStringOrNull(offsets[4]) ?? 'male',
    name: reader.readStringOrNull(offsets[5]) ?? '',
    targetDiastolic: reader.readLongOrNull(offsets[6]) ?? 80,
    targetSystolic: reader.readLongOrNull(offsets[7]) ?? 120,
    weight: reader.readDoubleOrNull(offsets[8]) ?? 0.0,
  );
  object.id = id;
  return object;
}

P _userProfileDeserializeProp<P>(
  IsarReader reader,
  int propertyId,
  int offset,
  Map<Type, List<int>> allOffsets,
) {
  switch (propertyId) {
    case 0:
      return (reader.readStringOrNull(offset) ?? '') as P;
    case 1:
      return (reader.readBoolOrNull(offset) ?? false) as P;
    case 2:
      return (reader.readStringOrNull(offset) ?? '') as P;
    case 3:
      return (reader.readLongOrNull(offset) ?? 0) as P;
    case 4:
      return (reader.readStringOrNull(offset) ?? 'male') as P;
    case 5:
      return (reader.readStringOrNull(offset) ?? '') as P;
    case 6:
      return (reader.readLongOrNull(offset) ?? 80) as P;
    case 7:
      return (reader.readLongOrNull(offset) ?? 120) as P;
    case 8:
      return (reader.readDoubleOrNull(offset) ?? 0.0) as P;
    default:
      throw IsarError('Unknown property with id $propertyId');
  }
}

Id _userProfileGetId(UserProfile object) {
  return object.id;
}

List<IsarLinkBase<dynamic>> _userProfileGetLinks(UserProfile object) {
  return [];
}

void _userProfileAttach(
    IsarCollection<dynamic> col, Id id, UserProfile object) {
  object.id = id;
}

extension UserProfileQueryWhereSort
    on QueryBuilder<UserProfile, UserProfile, QWhere> {
  QueryBuilder<UserProfile, UserProfile, QAfterWhere> anyId() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(const IdWhereClause.any());
    });
  }
}

extension UserProfileQueryWhere
    on QueryBuilder<UserProfile, UserProfile, QWhereClause> {
  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: id,
        upper: id,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idNotEqualTo(
      Id id) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            )
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            );
      } else {
        return query
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            )
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            );
      }
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idGreaterThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.greaterThan(lower: id, includeLower: include),
      );
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idLessThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.lessThan(upper: id, includeUpper: include),
      );
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterWhereClause> idBetween(
    Id lowerId,
    Id upperId, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: lowerId,
        includeLower: includeLower,
        upper: upperId,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension UserProfileQueryFilter
    on QueryBuilder<UserProfile, UserProfile, QFilterCondition> {
  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'accountEmail',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'accountEmail',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountEmail',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountEmailIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'accountEmail',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountLinkedEqualTo(bool value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountLinked',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'accountProvider',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'accountProvider',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountProvider',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      accountProviderIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'accountProvider',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageEqualTo(
      int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'age',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'age',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'age',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> ageBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'age',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'gender',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderContains(
      String value,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'gender',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> genderMatches(
      String pattern,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'gender',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'gender',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      genderIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'gender',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idEqualTo(
      Id value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idGreaterThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idLessThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> idBetween(
    Id lower,
    Id upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'id',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'name',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameContains(
      String value,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'name',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameMatches(
      String pattern,
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'name',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> nameIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'name',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      nameIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'name',
        value: '',
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'targetDiastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'targetDiastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'targetDiastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetDiastolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'targetDiastolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'targetSystolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'targetSystolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'targetSystolic',
        value: value,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      targetSystolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'targetSystolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> weightEqualTo(
    double value, {
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'weight',
        value: value,
        epsilon: epsilon,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition>
      weightGreaterThan(
    double value, {
    bool include = false,
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'weight',
        value: value,
        epsilon: epsilon,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> weightLessThan(
    double value, {
    bool include = false,
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'weight',
        value: value,
        epsilon: epsilon,
      ));
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterFilterCondition> weightBetween(
    double lower,
    double upper, {
    bool includeLower = true,
    bool includeUpper = true,
    double epsilon = Query.epsilon,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'weight',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        epsilon: epsilon,
      ));
    });
  }
}

extension UserProfileQueryObject
    on QueryBuilder<UserProfile, UserProfile, QFilterCondition> {}

extension UserProfileQueryLinks
    on QueryBuilder<UserProfile, UserProfile, QFilterCondition> {}

extension UserProfileQuerySortBy
    on QueryBuilder<UserProfile, UserProfile, QSortBy> {
  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByAccountEmail() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      sortByAccountEmailDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByAccountLinked() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      sortByAccountLinkedDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByAccountProvider() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      sortByAccountProviderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByAge() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByAgeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByGender() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByGenderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByName() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByNameDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByTargetDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      sortByTargetDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByTargetSystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      sortByTargetSystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByWeight() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> sortByWeightDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.desc);
    });
  }
}

extension UserProfileQuerySortThenBy
    on QueryBuilder<UserProfile, UserProfile, QSortThenBy> {
  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByAccountEmail() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      thenByAccountEmailDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByAccountLinked() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      thenByAccountLinkedDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByAccountProvider() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      thenByAccountProviderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByAge() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByAgeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'age', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByGender() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByGenderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'gender', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenById() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByIdDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByName() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByNameDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'name', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByTargetDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      thenByTargetDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetDiastolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByTargetSystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy>
      thenByTargetSystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'targetSystolic', Sort.desc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByWeight() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.asc);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QAfterSortBy> thenByWeightDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'weight', Sort.desc);
    });
  }
}

extension UserProfileQueryWhereDistinct
    on QueryBuilder<UserProfile, UserProfile, QDistinct> {
  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByAccountEmail(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'accountEmail', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByAccountLinked() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'accountLinked');
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByAccountProvider(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'accountProvider',
          caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByAge() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'age');
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByGender(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'gender', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByName(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'name', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct>
      distinctByTargetDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'targetDiastolic');
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByTargetSystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'targetSystolic');
    });
  }

  QueryBuilder<UserProfile, UserProfile, QDistinct> distinctByWeight() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'weight');
    });
  }
}

extension UserProfileQueryProperty
    on QueryBuilder<UserProfile, UserProfile, QQueryProperty> {
  QueryBuilder<UserProfile, int, QQueryOperations> idProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'id');
    });
  }

  QueryBuilder<UserProfile, String, QQueryOperations> accountEmailProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'accountEmail');
    });
  }

  QueryBuilder<UserProfile, bool, QQueryOperations> accountLinkedProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'accountLinked');
    });
  }

  QueryBuilder<UserProfile, String, QQueryOperations>
      accountProviderProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'accountProvider');
    });
  }

  QueryBuilder<UserProfile, int, QQueryOperations> ageProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'age');
    });
  }

  QueryBuilder<UserProfile, String, QQueryOperations> genderProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'gender');
    });
  }

  QueryBuilder<UserProfile, String, QQueryOperations> nameProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'name');
    });
  }

  QueryBuilder<UserProfile, int, QQueryOperations> targetDiastolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'targetDiastolic');
    });
  }

  QueryBuilder<UserProfile, int, QQueryOperations> targetSystolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'targetSystolic');
    });
  }

  QueryBuilder<UserProfile, double, QQueryOperations> weightProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'weight');
    });
  }
}
import 'dart:async';

import 'package:isar/isar.dart';

import '../../features/home/data/blood_pressure_model.dart';
import '../../features/settings/data/models/settings_model.dart';
import '../database/models/user_profile.dart';

class IsarService {
  final Isar _isar;

  IsarService(this._isar);

  // --- Records ---
  Stream<List<BloodPressureRecord>> listenToRecords() {
    return _isar.bloodPressureRecords
        .where()
        .sortByDateTimeDesc()
        .watch(fireImmediately: true);
  }

  Future<List<BloodPressureRecord>> getAllRecords() async {
    return await _isar.bloodPressureRecords.where().sortByDateTimeDesc().findAll();
  }

  Future<void> saveRecord(BloodPressureRecord record) async {
    await _isar.writeTxn(() async {
      await _isar.bloodPressureRecords.put(record);
    });
  }

  Future<void> saveRecords(List<BloodPressureRecord> records) async {
    await _isar.writeTxn(() async {
      await _isar.bloodPressureRecords.putAll(records);
    });
  }

  Future<void> deleteRecord(int id) async {
    await _isar.writeTxn(() async {
      await _isar.bloodPressureRecords.delete(id);
    });
  }

  Future<void> deleteAllRecords() async {
    await _isar.writeTxn(() async {
      await _isar.bloodPressureRecords.clear();
    });
  }

  // --- Settings (singleton, id=0) ---

  /// Р РµР°РєС‚РёРІРЅРѕРµ РЅР°Р±Р»СЋРґРµРЅРёРµ Р·Р° singleton-РЅР°СЃС‚СЂРѕР№РєР°РјРё (id=0).
  /// Р’Р°Р¶РЅРѕ: Р·Р°РїРёСЃСЊ РґРѕР»Р¶РЅР° СЃСѓС‰РµСЃС‚РІРѕРІР°С‚СЊ (СЃРѕР·РґР°С‘С‚СЃСЏ С‡РµСЂРµР· [getOrCreateSettings]).
  Stream<AppSettings> watchSettings() {
    return _isar.appSettings
        .watchObject(0, fireImmediately: true)
        .where((s) => s != null)
        .cast<AppSettings>();
  }

  Future<AppSettings> getOrCreateSettings() async {
    final byId = await _isar.appSettings.get(0);
    if (byId != null) return byId;

    // Р•СЃР»Рё РІ Р±Р°Р·Рµ РµСЃС‚СЊ "РєР°РєР°СЏ-С‚Рѕ" Р·Р°РїРёСЃСЊ РЅР°СЃС‚СЂРѕРµРє (РїРѕСЃР»Рµ СЃС‚Р°СЂС‹С… СЌРєСЃРїРµСЂРёРјРµРЅС‚РѕРІ),
    // РїРѕРґРЅРёРјР°РµРј РµС‘ Рё РЅР°СЃРёР»СЊРЅРѕ РґРµР»Р°РµРј singleton id=0.
    final any = await _isar.appSettings.where().findFirst();
    if (any != null) {
      any.id = 0;
      await _isar.writeTxn(() async {
        await _isar.appSettings.put(any);
      });
      return any;
    }

    final created = AppSettings()..id = 0;
    await _isar.writeTxn(() async {
      await _isar.appSettings.put(created);
    });
    return created;
  }

  Future<AppSettings?> getSettings() async {
    return await getOrCreateSettings();
  }

  Future<void> saveSettings(AppSettings settings) async {
    await _isar.writeTxn(() async {
      settings.id = 0;
      await _isar.appSettings.put(settings);
    });
  }

  // --- Profile (singleton, id=0) ---

  /// Р РµР°РєС‚РёРІРЅРѕРµ РЅР°Р±Р»СЋРґРµРЅРёРµ Р·Р° singleton-РїСЂРѕС„РёР»РµРј (id=0).
  /// Р’Р°Р¶РЅРѕ: Р·Р°РїРёСЃСЊ РґРѕР»Р¶РЅР° СЃСѓС‰РµСЃС‚РІРѕРІР°С‚СЊ (СЃРѕР·РґР°С‘С‚СЃСЏ С‡РµСЂРµР· [getOrCreateProfile]).
  Stream<UserProfile> watchProfile() {
    return _isar.userProfiles
        .watchObject(0, fireImmediately: true)
        .where((p) => p != null)
        .cast<UserProfile>();
  }

  Future<UserProfile> getOrCreateProfile() async {
    final byId = await _isar.userProfiles.get(0);
    if (byId != null) return byId;

    final any = await _isar.userProfiles.where().findFirst();
    if (any != null) {
      any.id = 0;
      await _isar.writeTxn(() async {
        await _isar.userProfiles.put(any);
      });
      return any;
    }

    final created = UserProfile()..id = 0;
    await _isar.writeTxn(() async {
      await _isar.userProfiles.put(created);
    });
    return created;
  }

  Future<UserProfile?> getProfile() async {
    return await getOrCreateProfile();
  }

  Future<void> saveProfile(UserProfile profile) async {
    await _isar.writeTxn(() async {
      profile.id = 0;
      await _isar.userProfiles.put(profile);
    });
  }

  /// РџРѕР»РЅР°СЏ Р·Р°РјРµРЅР° РґР°РЅРЅС‹С… РїСЂРёР»РѕР¶РµРЅРёСЏ (РґР»СЏ restore):
  /// - settings/profile РїРµСЂРµР·Р°РїРёСЃС‹РІР°РµРј
  /// - Р·Р°РїРёСЃРё РґР°РІР»РµРЅРёСЏ РїРѕР»РЅРѕСЃС‚СЊСЋ Р·Р°РјРµРЅСЏРµРј
  Future<void> replaceAllData({
    required AppSettings settings,
    required UserProfile profile,
    required List<BloodPressureRecord> records,
  }) async {
    await _isar.writeTxn(() async {
      settings.id = 0;
      profile.id = 0;

      await _isar.appSettings.put(settings);
      await _isar.userProfiles.put(profile);

      await _isar.bloodPressureRecords.clear();
      await _isar.bloodPressureRecords.putAll(records);
    });
  }
}
import 'package:get_it/get_it.dart';
import 'package:isar/isar.dart';
import 'package:blood_pressure_diary/features/home/presentation/bloc/home_bloc.dart';
import 'package:blood_pressure_diary/core/database/isar_service.dart';
import 'package:blood_pressure_diary/core/repositories/pressure_repository.dart';
import 'package:blood_pressure_diary/features/add_record/presentation/bloc/add_record_bloc.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_cubit.dart';
import 'package:blood_pressure_diary/features/profile/presentation/bloc/profile_cubit.dart';
import 'package:blood_pressure_diary/core/services/export_service.dart';
import 'package:blood_pressure_diary/core/services/notification_service.dart';

final getIt = GetIt.instance;

Future<void> setupLocator(Isar isar) async {
  getIt.registerSingleton<Isar>(isar);
  getIt.registerSingleton<IsarService>(IsarService(isar));
  getIt.registerSingleton<ExportService>(ExportService());
  
  final notificationService = NotificationService();
  await notificationService.initialize();
  getIt.registerSingleton<NotificationService>(notificationService);

  // 2. Р РµРїРѕР·РёС‚РѕСЂРёР№ (Р·Р°РІРёСЃРёС‚ РѕС‚ IsarService)
  getIt.registerLazySingleton<PressureRepository>(
        () => PressureRepository(getIt<IsarService>()),
  );

  // 3. BLoC (Р·Р°РІРёСЃРёС‚ РѕС‚ СЂРµРїРѕР·РёС‚РѕСЂРёСЏ)
  getIt.registerFactory<HomeBloc>(() => HomeBloc(getIt<PressureRepository>()));
  
  getIt.registerFactory(() => AddRecordBloc(getIt<PressureRepository>()));
  getIt.registerSingleton<ProfileCubit>(ProfileCubit(getIt<IsarService>()));
  
  // SettingsCubit РєР°Рє СЃРёРЅРіР»С‚РѕРЅ, С‡С‚РѕР±С‹ РЅР°СЃС‚СЂРѕР№РєРё Р±С‹Р»Рё РґРѕСЃС‚СѓРїРЅС‹ РІРµР·РґРµ
  getIt.registerSingleton(SettingsCubit(
    getIt<IsarService>(),
    getIt<PressureRepository>(),
    getIt<ExportService>(),
    getIt<NotificationService>(),
  ));
}
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:get_it/get_it.dart';

import '../theme/app_theme.dart';
import '../theme/scale.dart';

import '../../features/home/presentation/home_screen.dart';
import '../../features/home/presentation/statistics_screen.dart';
import '../../features/settings/presentation/settings_screen.dart';
import '../../features/profile/presentation/profile_screen.dart';
import '../../features/add_record/presentation/add_record_screen.dart';
import '../../features/home/presentation/bloc/home_bloc.dart';
import '../../features/profile/presentation/bloc/profile_cubit.dart';
import '../../features/settings/presentation/bloc/settings_cubit.dart';

class AppNavigation extends StatefulWidget {
  const AppNavigation({super.key});

  @override
  State<AppNavigation> createState() => _AppNavigationState();
}

class _AppNavigationState extends State<AppNavigation> {
  int _selectedIndex = 0;

  void _openAddRecord() {
    Navigator.push(context, MaterialPageRoute(builder: (_) => const AddRecordScreen()));
  }

  void _onNavTap(int navIndex) {
    if (navIndex == 2) {
      _openAddRecord();
      return;
    }
    final pageIndex = (navIndex < 2) ? navIndex : (navIndex - 1);
    setState(() => _selectedIndex = pageIndex);
  }

  @override
  Widget build(BuildContext context) {
    // вњ… РџРѕРјРµРЅСЏР»Рё РјРµСЃС‚Р°РјРё: РџСЂРѕС„РёР»СЊ Рё РќР°СЃС‚СЂРѕР№РєРё
    final pages = <Widget>[
      const HomeScreen(),
      const StatisticsScreen(),
      const ProfileScreen(),
      const SettingsScreen(),
    ];

    return MultiBlocProvider(
      providers: [
        BlocProvider(create: (_) => GetIt.I<HomeBloc>()),
        BlocProvider.value(value: GetIt.I<ProfileCubit>()..loadProfile()),
        BlocProvider.value(value: GetIt.I<SettingsCubit>()),
      ],
      child: Scaffold(
        extendBody: true,
        body: IndexedStack(index: _selectedIndex, children: pages),
        bottomNavigationBar: _BottomNavBar(
          activeIndex: _selectedIndex,
          onTap: _onNavTap,
        ),
      ),
    );
  }
}

class _BottomNavBar extends StatelessWidget {
  final int activeIndex; // 0..3
  final ValueChanged<int> onTap; // 0..4 (2 is center)

  const _BottomNavBar({
    required this.activeIndex,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;

    final s = context.appSpace;

    // вњ… Р’ dark: Р°РєС‚РёРІРЅР°СЏ Р‘Р›Р•Р”РќРђРЇ, РѕСЃС‚Р°Р»СЊРЅС‹Рµ РЇР РљРР•
    final bright = isDark ? AppPalette.dark400 : AppPalette.blue900; // СЏСЂРєР°СЏ
    final pale = isDark ? AppPalette.dark600 : AppPalette.grey500; // Р±Р»РµРґРЅР°СЏ

    final barH = dp(context, s.s72 - s.s2 - s.s1); // 69
    final icon = dp(context, s.s30);

    final outer = dp(context, s.s80 + s.s6); // 86
    final inner = dp(context, s.s56 + s.s4); // 60
    final plus = dp(context, s.s48);

    final lift = outer / 2;

    // вњ… Р¤РѕРЅ РЅРёР¶РЅРµРіРѕ РјРµРЅСЋ dark: #3C3C3C
    final barBg = isDark ? AppPalette.dark800 : AppPalette.grey050;

    return SafeArea(
      top: false,
      child: SizedBox(
        height: barH + lift,
        child: Stack(
          clipBehavior: Clip.none,
          alignment: Alignment.bottomCenter,
          children: [
            // РџРѕРґР»РѕР¶РєР° РїРѕРґ РїРѕРґРЅСЏС‚СѓСЋ РєРЅРѕРїРєСѓ вЂ” РїСЂРѕР·СЂР°С‡РЅР°СЏ
            Positioned.fill(child: const ColoredBox(color: Colors.transparent)),

            Positioned(
              left: 0,
              right: 0,
              bottom: 0,
              height: barH,
              child: Container(
                color: barBg,
                child: Row(
                  children: [
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/house.svg',
                        size: icon,
                        color: activeIndex == 0 ? pale : bright,
                        onTap: () => onTap(0),
                      ),
                    ),
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/Vector.svg',
                        size: icon,
                        color: activeIndex == 1 ? pale : bright,
                        onTap: () => onTap(1),
                      ),
                    ),
                    SizedBox(width: outer),

                    // вњ… РўСЂРµС‚СЊСЏ РІРєР»Р°РґРєР° С‚РµРїРµСЂСЊ РџСЂРѕС„РёР»СЊ (activeIndex == 2)
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/user-pen.svg',
                        size: icon,
                        color: activeIndex == 2 ? pale : bright,
                        onTap: () => onTap(3),
                      ),
                    ),

                    // вњ… Р§РµС‚РІС‘СЂС‚Р°СЏ РІРєР»Р°РґРєР° С‚РµРїРµСЂСЊ РќР°СЃС‚СЂРѕР№РєРё (activeIndex == 3)
                    Expanded(
                      child: _NavItem(
                        asset: 'assets/settings.svg',
                        size: icon,
                        color: activeIndex == 3 ? pale : bright,
                        onTap: () => onTap(4),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            Positioned(
              bottom: barH - lift,
              child: GestureDetector(
                behavior: HitTestBehavior.opaque,
                onTap: () => onTap(2),
                child: SizedBox(
                  width: outer,
                  height: outer,
                  child: _Fab(
                    outer: outer,
                    inner: inner,
                    plus: plus,
                    isDark: isDark,
                    barBg: barBg,
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _NavItem extends StatelessWidget {
  final String asset;
  final double size;
  final Color color;
  final VoidCallback onTap;

  const _NavItem({
    required this.asset,
    required this.size,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final s = context.appSpace;
    final hit = dp(context, s.s56);

    return Center(
      child: GestureDetector(
        onTap: onTap,
        behavior: HitTestBehavior.opaque,
        child: SizedBox(
          width: hit,
          height: hit,
          child: Center(
            child: SvgPicture.asset(
              asset,
              width: size,
              height: size,
              colorFilter: ColorFilter.mode(color, BlendMode.srcIn),
            ),
          ),
        ),
      ),
    );
  }
}

class _Fab extends StatelessWidget {
  final double outer;
  final double inner;
  final double plus;
  final bool isDark;
  final Color barBg;

  const _Fab({
    required this.outer,
    required this.inner,
    required this.plus,
    required this.isDark,
    required this.barBg,
  });

  @override
  Widget build(BuildContext context) {
    final c = context.appColors;
    final s = context.appSpace;

    final shadow = BoxShadow(
      color: AppPalette.shadow10,
      blurRadius: dp(context, s.s4),
      offset: Offset(0, dp(context, s.s2)),
    );

    final innerBg = isDark ? AppPalette.dark900 : c.brandStrong;
    final plusColor = isDark ? AppPalette.dark400 : c.textOnBrand;

    final outerDecoration = BoxDecoration(
      shape: BoxShape.circle,
      boxShadow: [shadow],
      color: isDark ? null : barBg,
      gradient: isDark
          ? const LinearGradient(
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
        colors: [
          AppPalette.dark800, // #3C3C3C
          AppPalette.dark805, // #3D3D3D
        ],
      )
          : null,
    );

    return SizedBox(
      width: outer,
      height: outer,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Container(
            width: outer,
            height: outer,
            decoration: outerDecoration,
          ),
          Container(
            width: inner,
            height: inner,
            decoration: BoxDecoration(
              color: innerBg,
              shape: BoxShape.circle,
            ),
            child: Center(
              child: SvgPicture.asset(
                'assets/Plus.svg',
                width: plus,
                height: plus,
                colorFilter: ColorFilter.mode(plusColor, BlendMode.srcIn),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import '../database/isar_service.dart';
import '../../features/home/data/blood_pressure_model.dart';

class PressureRepository {
  final IsarService _isarService;

  PressureRepository(this._isarService);

  Stream<List<BloodPressureRecord>> getAllRecordsStream() {
    return _isarService.listenToRecords();
  }

  Future<void> addRecord(BloodPressureRecord record) async {
    await _isarService.saveRecord(record);
  }

  Future<List<BloodPressureRecord>> getAllRecords() async {
    return await _isarService.getAllRecords();
  }

  Future<void> deleteRecord(int id) async {
    await _isarService.deleteRecord(id);
  }

  Future<void> deleteAllRecords() async {
    await _isarService.deleteAllRecords();
  }
}
import 'dart:convert';

import 'package:blood_pressure_diary/core/database/isar_service.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';
import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';
import 'package:blood_pressure_diary/features/settings/data/models/settings_model.dart';

class BackupService {
  final IsarService _isar;

  BackupService(this._isar);

  static const int backupVersion = 1;

  Future<String> createBackupJson() async {
    final settings = await _isar.getSettings() ?? AppSettings();
    final profile = await _isar.getProfile() ?? UserProfile();
    final records = await _isar.getAllRecords();

    final map = <String, dynamic>{
      'version': backupVersion,
      'createdAt': DateTime.now().toUtc().toIso8601String(),
      'settings': _settingsToMap(settings),
      'profile': _profileToMap(profile),
      'records': records.map(_recordToMap).toList(growable: false),
    };

    return const JsonEncoder.withIndent('  ').convert(map);
    // (Indent РїРѕР»РµР·РµРЅ: С„Р°Р№Р» С‡РёС‚Р°РµРјС‹Р№, РїСЂРѕС‰Рµ РѕС‚Р»Р°Р¶РёРІР°С‚СЊ. РџСЂРё Р¶РµР»Р°РЅРёРё РјРѕР¶РЅРѕ СѓР±СЂР°С‚СЊ.)
  }

  Future<void> restoreFromJson(String jsonText) async {
    final dynamic decoded = jsonDecode(jsonText);
    if (decoded is! Map<String, dynamic>) {
      throw const FormatException('Backup JSON is not an object');
    }

    final version = decoded['version'];
    if (version != backupVersion) {
      throw FormatException('Unsupported backup version: $version');
    }

    final settingsMap = decoded['settings'];
    final profileMap = decoded['profile'];
    final recordsList = decoded['records'];

    if (settingsMap is! Map<String, dynamic>) {
      throw const FormatException('Backup JSON: "settings" is invalid');
    }
    if (profileMap is! Map<String, dynamic>) {
      throw const FormatException('Backup JSON: "profile" is invalid');
    }
    if (recordsList is! List) {
      throw const FormatException('Backup JSON: "records" is invalid');
    }

    final settings = _settingsFromMap(settingsMap);
    final profile = _profileFromMap(profileMap);

    final records = <BloodPressureRecord>[];
    for (final item in recordsList) {
      if (item is! Map<String, dynamic>) continue;
      records.add(_recordFromMap(item));
    }

    // Р’РѕСЃСЃС‚Р°РЅРѕРІР»РµРЅРёРµ: РїРµСЂРµР·Р°РїРёСЃС‹РІР°РµРј (settings/profile) Рё РїРѕР»РЅРѕСЃС‚СЊСЋ Р·Р°РјРµРЅСЏРµРј Р·Р°РїРёСЃРё РґР°РІР»РµРЅРёСЏ.
    await _isar.replaceAllData(
      settings: settings,
      profile: profile,
      records: records,
    );
  }

  // -------------------- MAPPERS --------------------

  Map<String, dynamic> _settingsToMap(AppSettings s) => <String, dynamic>{
    'themeMode': s.themeMode.name, // light/dark/system
    'languageCode': s.languageCode,
    'reminders': s.reminders,
    'notificationsEnabled': s.notificationsEnabled,
    'accountLinked': s.accountLinked,
    'accountEmail': s.accountEmail,
    'accountProvider': s.accountProvider,
  };

  AppSettings _settingsFromMap(Map<String, dynamic> m) {
    final themeStr = (m['themeMode'] ?? 'light').toString();
    final theme = AppThemeMode.values.firstWhere(
          (e) => e.name == themeStr,
      orElse: () => AppThemeMode.light,
    );

    final remindersRaw = m['reminders'];
    final reminders = (remindersRaw is List)
        ? remindersRaw.map((e) => e.toString()).toList(growable: false)
        : <String>[];

    return AppSettings(
      themeMode: theme,
      languageCode: (m['languageCode'] ?? 'ru').toString(),
      reminders: reminders,
      notificationsEnabled: m['notificationsEnabled'] == true,
      accountLinked: m['accountLinked'] == true,
      accountEmail: (m['accountEmail'] ?? '').toString(),
      accountProvider: (m['accountProvider'] ?? '').toString(),
    )..id = 0;
  }

  Map<String, dynamic> _profileToMap(UserProfile p) => <String, dynamic>{
    'name': p.name,
    'age': p.age,
    'gender': p.gender,
    'weight': p.weight,
    'targetSystolic': p.targetSystolic,
    'targetDiastolic': p.targetDiastolic,
  };

  UserProfile _profileFromMap(Map<String, dynamic> m) {
    return UserProfile(
      name: (m['name'] ?? '').toString(),
      age: (m['age'] is num) ? (m['age'] as num).toInt() : 0,
      gender: (m['gender'] ?? 'male').toString(),
      weight: (m['weight'] is num) ? (m['weight'] as num).toDouble() : 0.0,
      targetSystolic: (m['targetSystolic'] is num) ? (m['targetSystolic'] as num).toInt() : 120,
      targetDiastolic: (m['targetDiastolic'] is num) ? (m['targetDiastolic'] as num).toInt() : 80,
    )..id = 0;
  }

  Map<String, dynamic> _recordToMap(BloodPressureRecord r) => <String, dynamic>{
    'dateTime': r.dateTime.toUtc().toIso8601String(),
    'systolic': r.systolic,
    'diastolic': r.diastolic,
    'pulse': r.pulse,
    'note': r.note,
    'emotion': r.emotion,
  };

  BloodPressureRecord _recordFromMap(Map<String, dynamic> m) {
    final dtStr = (m['dateTime'] ?? '').toString();
    final dt = DateTime.tryParse(dtStr)?.toLocal() ?? DateTime.now();

    final r = BloodPressureRecord()
      ..dateTime = dt
      ..systolic = (m['systolic'] is num) ? (m['systolic'] as num).toInt() : 0
      ..diastolic = (m['diastolic'] is num) ? (m['diastolic'] as num).toInt() : 0
      ..pulse = (m['pulse'] is num) ? (m['pulse'] as num).toInt() : 0
      ..note = m['note']?.toString()
      ..emotion = m['emotion']?.toString();

    // id РЅРµ РїРµСЂРµРЅРѕСЃРёРј вЂ” Isar СЃР°Рј РІС‹РґР°СЃС‚ РЅРѕРІС‹Рµ id.
    return r;
  }
}
// export_service.dart вЂ” РїРѕР»РЅР°СЏ Р·Р°РјРµРЅР° (CSV + PDF doctor report)
import 'dart:io';

import 'package:csv/csv.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:share_plus/share_plus.dart';

import 'package:blood_pressure_diary/core/database/models/user_profile.dart';
import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';

enum ExportFormat { csv, pdf }

class ExportService {
  Future<void> exportData(
      List<BloodPressureRecord> records,
      ExportFormat format,
      String languageCode, {
        UserProfile? profile,
        int periodDays = 14,
      }) async {
    if (format == ExportFormat.csv) {
      await _exportToCSV(records);
      return;
    }

    await _exportToPDFDoctorReport(
      records: records,
      languageCode: languageCode,
      profile: profile,
      periodDays: periodDays,
    );
  }

  Future<void> _exportToCSV(List<BloodPressureRecord> records) async {
    final rows = <List<dynamic>>[
      ['Date', 'Time', 'Systolic', 'Diastolic', 'Pulse', 'Note'],
    ];

    for (final r in records) {
      rows.add([
        DateFormat('dd.MM.yyyy').format(r.dateTime),
        DateFormat('HH:mm').format(r.dateTime),
        r.systolic,
        r.diastolic,
        r.pulse,
        (r.note ?? '').trim(),
      ]);
    }

    final csvContent = const ListToCsvConverter().convert(rows);
    final dir = await getTemporaryDirectory();
    final file = File('${dir.path}/blood_pressure_export.csv');
    await file.writeAsString(csvContent, flush: true);

    await Share.shareXFiles(
      [XFile(file.path)],
      text: 'Blood Pressure Export (CSV)',
    );
  }

  // --------------------- PDF v1 (Doctor report, no charts) ---------------------

  static const _kMorningStart = 6 * 60;
  static const _kMorningEnd = 11 * 60;

  static const _kDayStart = 12 * 60;
  static const _kDayEnd = 17 * 60;

  static const _kEveningStart = 18 * 60;
  static const _kEveningEnd = 22 * 60;

  int _toMinutes(DateTime dt) => dt.hour * 60 + dt.minute;

  String _fmtDate(DateTime dt) => DateFormat('dd.MM.yyyy').format(dt);
  String _fmtTime(DateTime dt) => DateFormat('HH:mm').format(dt);

  DateTime? _tryParseDobFromProfile(UserProfile? profile) {
    if (profile == null) return null;

    // РџРѕРґСЃС‚СЂРѕР№ РїРѕРґ С‚РІРѕСЋ РјРѕРґРµР»СЊ РїСЂРѕС„РёР»СЏ:
    // 1) РµСЃР»Рё РµСЃС‚СЊ profile.birthDate (DateTime?) вЂ” РёСЃРїРѕР»СЊР·СѓР№ РµРіРѕ
    // 2) РµСЃР»Рё РµСЃС‚СЊ СЃС‚СЂРѕРєР° dob/birthDateStr вЂ” РїР°СЂСЃРёРј
    try {
      final dynamic p = profile;

      final bd = p.birthDate;
      if (bd is DateTime) return bd;

      final s = (p.birthDateStr ?? p.dob ?? p.birthDate ?? '')?.toString() ?? '';
      final txt = s.trim();
      if (txt.isEmpty) return null;

      // РїРѕРґРґРµСЂР¶РёРј dd.MM.yyyy / yyyy-MM-dd
      if (RegExp(r'^\d{2}\.\d{2}\.\d{4}$').hasMatch(txt)) {
        return DateFormat('dd.MM.yyyy').parseStrict(txt);
      }
      if (RegExp(r'^\d{4}-\d{2}-\d{2}$').hasMatch(txt)) {
        return DateFormat('yyyy-MM-dd').parseStrict(txt);
      }
    } catch (_) {
      // РёРіРЅРѕСЂ
    }
    return null;
  }

  int? _computeAge(UserProfile? profile) {
    final dob = _tryParseDobFromProfile(profile);
    if (dob == null) return null;

    final now = DateTime.now();
    var age = now.year - dob.year;
    final hadBirthday = (now.month > dob.month) ||
        (now.month == dob.month && now.day >= dob.day);
    if (!hadBirthday) age--;
    if (age < 0 || age > 130) return null;
    return age;
  }

  List<BloodPressureRecord> _filterByPeriod(List<BloodPressureRecord> records, int periodDays) {
    if (records.isEmpty) return const [];
    final cutoff = DateTime.now().subtract(Duration(days: periodDays));
    return records.where((r) => r.dateTime.isAfter(cutoff)).toList();
  }

  _Stats _calcStats(List<BloodPressureRecord> list, int targetSys, int targetDia) {
    if (list.isEmpty) return _Stats.empty();

    int sumSys = 0, sumDia = 0;
    int minSys = 1 << 30, minDia = 1 << 30;
    int maxSys = -1, maxDia = -1;
    int out = 0;

    for (final r in list) {
      final s = r.systolic;
      final d = r.diastolic;

      sumSys += s;
      sumDia += d;

      if (s < minSys) minSys = s;
      if (d < minDia) minDia = d;
      if (s > maxSys) maxSys = s;
      if (d > maxDia) maxDia = d;

      if (s > targetSys || d > targetDia) out++;
    }

    final n = list.length;
    final avgSys = (sumSys / n).round();
    final avgDia = (sumDia / n).round();

    return _Stats(
      n: n,
      avgSys: avgSys,
      avgDia: avgDia,
      minSys: minSys,
      maxSys: maxSys,
      minDia: minDia,
      maxDia: maxDia,
      outOfRangeCount: out,
      outOfRangePct: n == 0 ? 0 : (out * 100.0 / n),
    );
  }

  Map<String, _BucketStats> _calcBuckets(List<BloodPressureRecord> list) {
    final buckets = <String, List<BloodPressureRecord>>{
      'morning': [],
      'day': [],
      'evening': [],
      'night': [],
    };

    for (final r in list) {
      final m = _toMinutes(r.dateTime);

      if (m >= _kMorningStart && m < _kMorningEnd) {
        buckets['morning']!.add(r);
      } else if (m >= _kDayStart && m < _kDayEnd) {
        buckets['day']!.add(r);
      } else if (m >= _kEveningStart && m < _kEveningEnd) {
        buckets['evening']!.add(r);
      } else {
        buckets['night']!.add(r);
      }
    }

    _BucketStats build(List<BloodPressureRecord> xs) {
      if (xs.isEmpty) return _BucketStats.empty();
      int sumS = 0, sumD = 0;
      for (final r in xs) {
        sumS += r.systolic;
        sumD += r.diastolic;
      }
      final n = xs.length;
      return _BucketStats(n: n, avgSys: (sumS / n).round(), avgDia: (sumD / n).round());
    }

    return {
      'morning': build(buckets['morning']!),
      'day': build(buckets['day']!),
      'evening': build(buckets['evening']!),
      'night': build(buckets['night']!),
    };
  }

  String _countLabel(int n, bool isRu) {
    if (!isRu) return '$n';
    // РїСЂРѕСЃС‚Р°СЏ СЂСѓСЃСЃРєР°СЏ С„РѕСЂРјР°: "1 РёР·РјРµСЂРµРЅРёРµ / 2 РёР·РјРµСЂРµРЅРёСЏ / 5 РёР·РјРµСЂРµРЅРёР№"
    final n10 = n % 10;
    final n100 = n % 100;
    if (n10 == 1 && n100 != 11) return '$n РёР·РјРµСЂРµРЅРёРµ';
    if (n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14)) return '$n РёР·РјРµСЂРµРЅРёСЏ';
    return '$n РёР·РјРµСЂРµРЅРёР№';
  }

  Future<void> _exportToPDFDoctorReport({
    required List<BloodPressureRecord> records,
    required String languageCode,
    required UserProfile? profile,
    required int periodDays,
  }) async {
    final isRu = languageCode == 'ru';

    // 1) РЁСЂРёС„С‚С‹ (РµСЃР»Рё РЅРµС‚ вЂ” Р±СѓРґРµС‚ РёСЃРєР»СЋС‡РµРЅРёРµ, РїРѕСЌС‚РѕРјСѓ РІР°Р¶РЅРѕ, С‡С‚РѕР±С‹ Р°СЃСЃРµС‚С‹ СЂРµР°Р»СЊРЅРѕ Р±С‹Р»Рё)
    final fontData = await rootBundle.load('assets/fonts/Inter-Regular.ttf');
    final boldData = await rootBundle.load('assets/fonts/Inter-Bold.ttf');
    final ttf = pw.Font.ttf(fontData);
    final ttfBold = pw.Font.ttf(boldData);

    final filtered = _filterByPeriod(records, periodDays);

    final targetSys = profile?.targetSystolic ?? 120;
    final targetDia = profile?.targetDiastolic ?? 80;

    final nameRaw = (profile?.name ?? '').trim();
    final name = nameRaw.isEmpty ? 'вЂ”' : nameRaw;

    final age = _computeAge(profile);
    final ageText = age == null ? 'вЂ”' : age.toString();

    DateTime? maxDt, minDt;
    if (filtered.isNotEmpty) {
      maxDt = filtered.map((e) => e.dateTime).reduce((a, b) => a.isAfter(b) ? a : b);
      minDt = filtered.map((e) => e.dateTime).reduce((a, b) => a.isBefore(b) ? a : b);
    }

    final periodText = (minDt == null || maxDt == null)
        ? (isRu ? 'РџРµСЂРёРѕРґ: вЂ”' : 'Period: вЂ”')
        : (isRu
        ? 'РџРµСЂРёРѕРґ: ${_fmtDate(minDt)} вЂ” ${_fmtDate(maxDt)}'
        : 'Period: ${_fmtDate(minDt)} вЂ” ${_fmtDate(maxDt)}');

    final stats = _calcStats(filtered, targetSys, targetDia);
    final buckets = _calcBuckets(filtered);

    final title = isRu ? 'РћС‚С‡С‘С‚ РїРѕ Р°СЂС‚РµСЂРёР°Р»СЊРЅРѕРјСѓ РґР°РІР»РµРЅРёСЋ' : 'Blood Pressure Report';

    final pdf = pw.Document();

    final h1 = pw.TextStyle(font: ttfBold, fontSize: 18, color: PdfColors.blue900);
    final h2 = pw.TextStyle(font: ttfBold, fontSize: 12, color: PdfColors.blue900);
    final body = pw.TextStyle(font: ttf, fontSize: 10, color: PdfColors.black);
    final bodyBold = pw.TextStyle(font: ttfBold, fontSize: 10, color: PdfColors.black);
    final small = pw.TextStyle(font: ttf, fontSize: 8, color: PdfColors.grey700);

    pw.Widget sectionTitle(String text) => pw.Padding(
      padding: const pw.EdgeInsets.only(top: 10, bottom: 6),
      child: pw.Text(text, style: h2),
    );

    pw.Widget kvLine(String k, String v) => pw.Row(
      children: [
        pw.Expanded(child: pw.Text(k, style: body)),
        pw.Text(v, style: bodyBold),
      ],
    );

    pw.Widget statBox() {
      final avg = stats.isEmpty ? 'вЂ”' : '${stats.avgSys}/${stats.avgDia}';
      final min = stats.isEmpty ? 'вЂ”' : '${stats.minSys}/${stats.minDia}';
      final max = stats.isEmpty ? 'вЂ”' : '${stats.maxSys}/${stats.maxDia}';
      final out = stats.isEmpty
          ? 'вЂ”'
          : '${stats.outOfRangePct.toStringAsFixed(0)}% (${stats.outOfRangeCount}/${stats.n})';

      final avgLabel = isRu ? 'РЎСЂРµРґРЅРµРµ Р·Р° РїРµСЂРёРѕРґ' : 'Average';
      final minLabel = isRu ? 'РњРёРЅРёРјСѓРј' : 'Min';
      final maxLabel = isRu ? 'РњР°РєСЃРёРјСѓРј' : 'Max';
      final outLabel = isRu ? 'Р’С‹С€Рµ РЅРѕСЂРјС‹' : 'Above target';

      return pw.Container(
        decoration: pw.BoxDecoration(
          borderRadius: pw.BorderRadius.circular(8),
          color: PdfColors.grey100,
          border: pw.Border.all(color: PdfColors.grey300, width: 1),
        ),
        padding: const pw.EdgeInsets.all(10),
        child: pw.Column(
          crossAxisAlignment: pw.CrossAxisAlignment.start,
          children: [
            kvLine(avgLabel, avg),
            pw.SizedBox(height: 4),
            kvLine(minLabel, min),
            pw.SizedBox(height: 4),
            kvLine(maxLabel, max),
            pw.SizedBox(height: 4),
            kvLine(outLabel, out),
          ],
        ),
      );
    }

    pw.Widget bucketTable() {
      final morning = buckets['morning']!;
      final day = buckets['day']!;
      final evening = buckets['evening']!;
      final night = buckets['night']!;

      String f(_BucketStats b) {
        if (b.isEmpty) return 'вЂ”';
        return '${b.avgSys}/${b.avgDia}  (${_countLabel(b.n, isRu)})';
      }

      final rows = [
        [isRu ? 'РЈС‚СЂРѕ (06вЂ“10)' : 'Morning (06вЂ“10)', f(morning)],
        [isRu ? 'Р”РµРЅСЊ (12вЂ“16)' : 'Day (12вЂ“16)', f(day)],
        [isRu ? 'Р’РµС‡РµСЂ (18вЂ“22)' : 'Evening (18вЂ“22)', f(evening)],
        [isRu ? 'РќРѕС‡СЊ (22вЂ“06)' : 'Night (22вЂ“06)', f(night)],
      ];

      return pw.TableHelper.fromTextArray(
        headers: [
          isRu ? 'Р’СЂРµРјСЏ СЃСѓС‚РѕРє' : 'Time of day',
          isRu ? 'РЎСЂРµРґРЅРµРµ (SYS/DIA)' : 'Average (SYS/DIA)',
        ],
        data: rows,
        headerStyle: pw.TextStyle(font: ttfBold, fontSize: 10, color: PdfColors.white),
        headerDecoration: const pw.BoxDecoration(color: PdfColors.blue800),
        cellStyle: body,
        cellAlignment: pw.Alignment.centerLeft,
        columnWidths: {
          0: const pw.FlexColumnWidth(2),
          1: const pw.FlexColumnWidth(3),
        },
        cellPadding: const pw.EdgeInsets.symmetric(horizontal: 8, vertical: 6),
      );
    }

    pw.Widget entriesTable() {
      final sorted = List<BloodPressureRecord>.from(filtered)
        ..sort((a, b) => b.dateTime.compareTo(a.dateTime));

      final headers = isRu
          ? ['Р”Р°С‚Р°', 'Р’СЂРµРјСЏ', 'Р”Р°РІР»РµРЅРёРµ', 'РџСѓР»СЊСЃ', 'РџСЂРёРјРµС‡Р°РЅРёСЏ']
          : ['Date', 'Time', 'BP', 'Pulse', 'Notes'];

      final data = sorted.map((r) {
        final note = (r.note ?? '').trim();
        return [
          _fmtDate(r.dateTime),
          _fmtTime(r.dateTime),
          '${r.systolic}/${r.diastolic}',
          r.pulse.toString(),
          note,
        ];
      }).toList();

      return pw.TableHelper.fromTextArray(
        headers: headers,
        data: data,
        headerStyle: pw.TextStyle(font: ttfBold, fontSize: 10, color: PdfColors.white),
        headerDecoration: const pw.BoxDecoration(color: PdfColors.blue800),
        cellStyle: body,
        cellAlignment: pw.Alignment.center,
        cellPadding: const pw.EdgeInsets.symmetric(horizontal: 6, vertical: 4),
        columnWidths: {
          0: const pw.FixedColumnWidth(70),
          1: const pw.FixedColumnWidth(46),
          2: const pw.FixedColumnWidth(60),
          3: const pw.FixedColumnWidth(44),
          4: const pw.FlexColumnWidth(),
        },
      );
    }

    pw.Widget doctorNotes() {
      final label = isRu ? 'Р—Р°РјРµС‚РєРё РІСЂР°С‡Р°:' : "Doctor's notes:";
      return pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(label, style: bodyBold),
          pw.SizedBox(height: 6),
          for (int i = 0; i < 6; i++)
            pw.Container(
              margin: const pw.EdgeInsets.only(bottom: 6),
              height: 10,
              decoration: const pw.BoxDecoration(
                border: pw.Border(bottom: pw.BorderSide(color: PdfColors.grey500, width: 0.7)),
              ),
            ),
        ],
      );
    }

    final disclaimerRu =
        'Р”Р°РЅРЅС‹Рµ РІРЅРµСЃРµРЅС‹ РїРѕР»СЊР·РѕРІР°С‚РµР»РµРј Рё РЅРµ СЏРІР»СЏСЋС‚СЃСЏ РјРµРґРёС†РёРЅСЃРєРёРј РёР·РјРµСЂРµРЅРёРµРј. РРЅС‚РµСЂРїСЂРµС‚Р°С†РёСЏ С‚СЂРµР±СѓРµС‚ РєР»РёРЅРёС‡РµСЃРєРѕР№ РІРµСЂРёС„РёРєР°С†РёРё.';
    final disclaimerEn =
        'Data is user-entered and does not replace a clinical measurement. Interpretation requires medical verification.';

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(32),
        build: (_) => [
          pw.Text(title, style: h1),
          pw.SizedBox(height: 6),
          pw.Text(periodText, style: body),
          pw.SizedBox(height: 8),
          pw.Row(
            children: [
              pw.Expanded(
                child: pw.Text(isRu ? 'РџР°С†РёРµРЅС‚: $name' : 'Patient: $name', style: body),
              ),
              pw.Text(isRu ? 'Р’РѕР·СЂР°СЃС‚: $ageText' : 'Age: $ageText', style: body),
            ],
          ),
          pw.SizedBox(height: 6),
          pw.Text(
            isRu ? 'Р¦РµР»РµРІС‹Рµ Р·РЅР°С‡РµРЅРёСЏ: $targetSys/$targetDia' : 'Targets: $targetSys/$targetDia',
            style: body,
          ),
          sectionTitle(isRu ? 'Р РµР·СЋРјРµ' : 'Summary'),
          statBox(),
          sectionTitle(isRu ? 'РђРЅР°Р»РёС‚РёРєР° РїРѕ РІСЂРµРјРµРЅРё СЃСѓС‚РѕРє' : 'Time-of-day analysis'),
          bucketTable(),
          sectionTitle(isRu ? 'Р–СѓСЂРЅР°Р» РёР·РјРµСЂРµРЅРёР№' : 'Measurements log'),
          entriesTable(),
          pw.SizedBox(height: 12),
          doctorNotes(),
          pw.SizedBox(height: 10),
          pw.Text(isRu ? disclaimerRu : disclaimerEn, style: small),
        ],
      ),
    );

    // вњ… Р’РћРў Р­РўРћ вЂ” РєР»СЋС‡РµРІРѕР№ С„СѓРЅРґР°РјРµРЅС‚: bytes Р±РµСЂС‘Рј РёР· pdf.save()
    final bytes = await pdf.save();

    final dir = await getTemporaryDirectory();
    final safeTs = DateTime.now().toIso8601String().replaceAll(':', '-');
    final file = File('${dir.path}/pressure_report_$safeTs.pdf');
    await file.writeAsBytes(bytes, flush: true);

    await Share.shareXFiles(
      [XFile(file.path)],
      text: isRu ? 'РћС‚С‡С‘С‚ РґР°РІР»РµРЅРёСЏ (PDF)' : 'Blood pressure report (PDF)',
    );
  }
}

class _Stats {
  final int n;
  final int avgSys;
  final int avgDia;
  final int minSys;
  final int maxSys;
  final int minDia;
  final int maxDia;
  final int outOfRangeCount;
  final double outOfRangePct;

  const _Stats({
    required this.n,
    required this.avgSys,
    required this.avgDia,
    required this.minSys,
    required this.maxSys,
    required this.minDia,
    required this.maxDia,
    required this.outOfRangeCount,
    required this.outOfRangePct,
  });

  bool get isEmpty => n == 0;

  factory _Stats.empty() => const _Stats(
    n: 0,
    avgSys: 0,
    avgDia: 0,
    minSys: 0,
    maxSys: 0,
    minDia: 0,
    maxDia: 0,
    outOfRangeCount: 0,
    outOfRangePct: 0.0,
  );
}

class _BucketStats {
  final int n;
  final int avgSys;
  final int avgDia;

  const _BucketStats({
    required this.n,
    required this.avgSys,
    required this.avgDia,
  });

  bool get isEmpty => n == 0;

  factory _BucketStats.empty() => const _BucketStats(n: 0, avgSys: 0, avgDia: 0);
}
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest_all.dart' as tz_data;
import 'package:permission_handler/permission_handler.dart';

class NotificationService {
  final FlutterLocalNotificationsPlugin _notificationsPlugin = FlutterLocalNotificationsPlugin();

  Future<void> initialize() async {
    tz_data.initializeTimeZones();
    
    const AndroidInitializationSettings androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const DarwinInitializationSettings iosSettings = DarwinInitializationSettings(
      requestAlertPermission: false,
      requestBadgePermission: false,
      requestSoundPermission: false,
    );

    const InitializationSettings settings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );

    await _notificationsPlugin.initialize(settings);
  }

  Future<bool> requestPermissions() async {
    if (await Permission.notification.request().isGranted) {
      return true;
    }
    return false;
  }

  Future<void> scheduleDailyNotification(int id, TimeOfDay time) async {
    final now = tz.TZDateTime.now(tz.local);
    var scheduledDate = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      time.hour,
      time.minute,
    );

    if (scheduledDate.isBefore(now)) {
      scheduledDate = scheduledDate.add(const Duration(days: 1));
    }

    await _notificationsPlugin.zonedSchedule(
      id,
      'РџРѕСЂР° РёР·РјРµСЂРёС‚СЊ РґР°РІР»РµРЅРёРµ',
      'РќРµ Р·Р°Р±СѓРґСЊС‚Рµ РІРЅРµСЃС‚Рё РґР°РЅРЅС‹Рµ РІ РґРЅРµРІРЅРёРє РґР»СЏ РєРѕРЅС‚СЂРѕР»СЏ Р·РґРѕСЂРѕРІСЊСЏ.',
      scheduledDate,
      const NotificationDetails(
        android: AndroidNotificationDetails(
          'blood_pressure_reminders',
          'РќР°РїРѕРјРёРЅР°РЅРёСЏ Рѕ РґР°РІР»РµРЅРёРё',
          channelDescription: 'Р•Р¶РµРґРЅРµРІРЅС‹Рµ СѓРІРµРґРѕРјР»РµРЅРёСЏ Рѕ РЅРµРѕР±С…РѕРґРёРјРѕСЃС‚Рё Р·Р°РјРµСЂР° РґР°РІР»РµРЅРёСЏ',
          importance: Importance.max,
          priority: Priority.high,
        ),
        iOS: DarwinNotificationDetails(),
      ),
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      uiLocalNotificationDateInterpretation: UILocalNotificationDateInterpretation.absoluteTime,
      matchDateTimeComponents: DateTimeComponents.time,
    );
  }

  Future<void> cancelNotification(int id) async {
    await _notificationsPlugin.cancel(id);
  }

  Future<void> cancelAllNotifications() async {
    await _notificationsPlugin.cancelAll();
  }
}
import 'package:flutter/material.dart';

// -----------------------------------------------------------------------------
// Base colors (palette)

@immutable
class _C {
  static const Color white = Color(0xFFFFFFFF);
  static const Color black = Color(0xFF000000);
}

class AppPalette {
  // Blues
  static const Color blue900 = Color(0xFF2E5D85); // rgb(46,93,133)
  static const Color blue700 = Color(0xFF4D83AC); // rgb(77,131,172)
  static const Color blue600 = Color(0xFF3973A2); // rgb(57,115,162)
  static const Color blue500 = Color(0xFF6B9DC0); // rgb(107,157,192)
  static const Color blue300 = Color(0xFFBFD4E7); // rgb(191,212,231)

  // Light greys
  static const Color grey050 = Color(0xFFF9F8FA);
  static const Color grey100 = Color(0xFFF5F5F5);
  static const Color grey200 = Color(0xFFF0F4F8);
  static const Color grey400 = Color(0xFFD9D9D9);
  static const Color grey500 = Color(0xFFA0AEC0);
  static const Color grey600 = Color(0xFF808080);

  // Dark greys
  static const Color dark900 = Color(0xFF2D2D2D); // rgb(45,45,45)
  static const Color dark800 = Color(0xFF3C3C3C); // rgb(60,60,60)
  static const Color dark805 = Color(0xFF3D3D3D); // rgb(61,61,61) (РґР»СЏ linear РєРѕР»СЊС†Р°)
  static const Color dark700 = Color(0xFF4C4C4C); // rgb(76,76,76)
  static const Color dark600 = Color(0xFF747474); // rgb(116,116,116)
  static const Color dark400 = Color(0xFFCCCCCC); // rgb(204,204,204)
  static const Color dark350 = Color(0xFFC6C6C6); // rgb(198,198,198)

  // Accents
  static const Color green = Color(0xFF3DBE65);
  static const Color red = Color(0xFFDA3F3F);
  static const Color amber = Color(0xFFEB8F00);
  static const Color blueAccent = Color(0xFF5A8EF6);

  // Browns (profile)
  static const Color brown900 = Color(0xFF422B0D);
  static const Color brown700 = Color(0xFF896024);

  // Shadows
  static const Color shadow10 = Color(0x1A000000); // rgba(0,0,0,0.1)
  static const Color shadow25 = Color(0x40000000); // rgba(0,0,0,0.25)
}

// -----------------------------------------------------------------------------
// Semantic colors (ThemeExtension)

@immutable
class AppColors extends ThemeExtension<AppColors> {
  final Color background;
  final Color surface;
  final Color surfaceAlt;

  final Color brand;
  final Color brandStrong;
  final Color brandSoft;

  final Color textPrimary;
  final Color textSecondary;
  final Color textOnBrand;

  final Color divider;

  final Color iconPrimary;
  final Color iconSecondary;

  final Color success;
  final Color warning;
  final Color danger;
  final Color dangerSoft;

  final Color shadow;

  final Color profileAccentBrown;
  final Color profileAccentBrownDark;

  const AppColors({
    required this.background,
    required this.surface,
    required this.surfaceAlt,
    required this.brand,
    required this.brandStrong,
    required this.brandSoft,
    required this.textPrimary,
    required this.textSecondary,
    required this.textOnBrand,
    required this.divider,
    required this.iconPrimary,
    required this.iconSecondary,
    required this.success,
    required this.warning,
    required this.danger,
    required this.dangerSoft,
    required this.shadow,
    required this.profileAccentBrown,
    required this.profileAccentBrownDark,
  });

  static const light = AppColors(
    background: AppPalette.grey200,
    surface: _C.white,
    surfaceAlt: AppPalette.grey050,
    brand: AppPalette.blue600,
    brandStrong: AppPalette.blue900,
    brandSoft: AppPalette.blue500,
    textPrimary: AppPalette.blue900,
    textSecondary: AppPalette.grey500,
    textOnBrand: _C.white,
    divider: AppPalette.shadow10,
    iconPrimary: AppPalette.blue900,
    iconSecondary: AppPalette.blue900,
    success: AppPalette.green,
    warning: AppPalette.amber,
    danger: AppPalette.red,
    dangerSoft: AppPalette.red,
    shadow: AppPalette.shadow10,
    profileAccentBrown: AppPalette.brown700,
    profileAccentBrownDark: AppPalette.brown900,
  );

  static const dark = AppColors(
    background: AppPalette.dark900,
    surface: AppPalette.dark700,
    surfaceAlt: AppPalette.dark800,
    brand: AppPalette.dark800,
    brandStrong: AppPalette.dark400,
    brandSoft: AppPalette.dark700,
    textPrimary: AppPalette.dark400,
    textSecondary: AppPalette.dark350,
    textOnBrand: _C.white,
    divider: Colors.transparent,
    iconPrimary: AppPalette.dark400,
    iconSecondary: AppPalette.dark400,
    success: AppPalette.green,
    warning: AppPalette.amber,
    danger: AppPalette.red,
    dangerSoft: AppPalette.red,
    shadow: AppPalette.shadow10,
    profileAccentBrown: AppPalette.brown700,
    profileAccentBrownDark: AppPalette.brown900,
  );

  @override
  AppColors copyWith({
    Color? background,
    Color? surface,
    Color? surfaceAlt,
    Color? brand,
    Color? brandStrong,
    Color? brandSoft,
    Color? textPrimary,
    Color? textSecondary,
    Color? textOnBrand,
    Color? divider,
    Color? iconPrimary,
    Color? iconSecondary,
    Color? success,
    Color? warning,
    Color? danger,
    Color? dangerSoft,
    Color? shadow,
    Color? profileAccentBrown,
    Color? profileAccentBrownDark,
  }) {
    return AppColors(
      background: background ?? this.background,
      surface: surface ?? this.surface,
      surfaceAlt: surfaceAlt ?? this.surfaceAlt,
      brand: brand ?? this.brand,
      brandStrong: brandStrong ?? this.brandStrong,
      brandSoft: brandSoft ?? this.brandSoft,
      textPrimary: textPrimary ?? this.textPrimary,
      textSecondary: textSecondary ?? this.textSecondary,
      textOnBrand: textOnBrand ?? this.textOnBrand,
      divider: divider ?? this.divider,
      iconPrimary: iconPrimary ?? this.iconPrimary,
      iconSecondary: iconSecondary ?? this.iconSecondary,
      success: success ?? this.success,
      warning: warning ?? this.warning,
      danger: danger ?? this.danger,
      dangerSoft: dangerSoft ?? this.dangerSoft,
      shadow: shadow ?? this.shadow,
      profileAccentBrown: profileAccentBrown ?? this.profileAccentBrown,
      profileAccentBrownDark: profileAccentBrownDark ?? this.profileAccentBrownDark,
    );
  }

  @override
  ThemeExtension<AppColors> lerp(ThemeExtension<AppColors>? other, double t) {
    if (other is! AppColors) return this;
    Color l(Color a, Color b) => Color.lerp(a, b, t)!;

    return AppColors(
      background: l(background, other.background),
      surface: l(surface, other.surface),
      surfaceAlt: l(surfaceAlt, other.surfaceAlt),
      brand: l(brand, other.brand),
      brandStrong: l(brandStrong, other.brandStrong),
      brandSoft: l(brandSoft, other.brandSoft),
      textPrimary: l(textPrimary, other.textPrimary),
      textSecondary: l(textSecondary, other.textSecondary),
      textOnBrand: l(textOnBrand, other.textOnBrand),
      divider: l(divider, other.divider),
      iconPrimary: l(iconPrimary, other.iconPrimary),
      iconSecondary: l(iconSecondary, other.iconSecondary),
      success: l(success, other.success),
      warning: l(warning, other.warning),
      danger: l(danger, other.danger),
      dangerSoft: l(dangerSoft, other.dangerSoft),
      shadow: l(shadow, other.shadow),
      profileAccentBrown: l(profileAccentBrown, other.profileAccentBrown),
      profileAccentBrownDark: l(profileAccentBrownDark, other.profileAccentBrownDark),
    );
  }
}

// -----------------------------------------------------------------------------
// Spacing

@immutable
class AppSpacing extends ThemeExtension<AppSpacing> {
  final double s1;
  final double s2;
  final double s4;
  final double s6;
  final double s8;
  final double s10;
  final double s12;
  final double s14;
  final double s16;
  final double s18;
  final double s20;
  final double s22;
  final double s24;
  final double s26;
  final double s30;
  final double s32;
  final double s40;
  final double s46;
  final double s48;
  final double s56;
  final double s57;
  final double s72;
  final double s80;
  final double s96;
  final double s112;
  final double s114;
  final double s120;
  final double s128;
  final double s160;

  final double w320;
  final double w243;
  final double w208;
  final double w184;
  final double w96;

  const AppSpacing({
    required this.s1,
    required this.s2,
    required this.s4,
    required this.s6,
    required this.s8,
    required this.s10,
    required this.s12,
    required this.s14,
    required this.s16,
    required this.s18,
    required this.s20,
    required this.s22,
    required this.s24,
    required this.s26,
    required this.s30,
    required this.s32,
    required this.s40,
    required this.s46,
    required this.s48,
    required this.s56,
    required this.s57,
    required this.s72,
    required this.s80,
    required this.s96,
    required this.s112,
    required this.s114,
    required this.s120,
    required this.s128,
    required this.s160,
    required this.w320,
    required this.w243,
    required this.w208,
    required this.w184,
    required this.w96,
  });

  static const base = AppSpacing(
    s1: 1,
    s2: 2,
    s4: 4,
    s6: 6,
    s8: 8,
    s10: 10,
    s12: 12,
    s14: 14,
    s16: 16,
    s18: 18,
    s20: 20,
    s22: 22,
    s24: 24,
    s26: 26,
    s30: 30,
    s32: 32,
    s40: 40,
    s46: 46,
    s48: 48,
    s56: 56,
    s57: 57,
    s72: 72,
    s80: 80,
    s96: 96,
    s112: 112,
    s114: 114,
    s120: 120,
    s128: 128,
    s160: 160,
    w320: 320,
    w243: 243,
    w208: 208,
    w184: 184,
    w96: 96,
  );

  @override
  AppSpacing copyWith({
    double? s1,
    double? s2,
    double? s4,
    double? s6,
    double? s8,
    double? s10,
    double? s12,
    double? s14,
    double? s16,
    double? s18,
    double? s20,
    double? s22,
    double? s24,
    double? s26,
    double? s30,
    double? s32,
    double? s40,
    double? s46,
    double? s48,
    double? s56,
    double? s57,
    double? s72,
    double? s80,
    double? s96,
    double? s112,
    double? s114,
    double? s120,
    double? s128,
    double? s160,
    double? w320,
    double? w243,
    double? w208,
    double? w184,
    double? w96,
  }) {
    return AppSpacing(
      s1: s1 ?? this.s1,
      s2: s2 ?? this.s2,
      s4: s4 ?? this.s4,
      s6: s6 ?? this.s6,
      s8: s8 ?? this.s8,
      s10: s10 ?? this.s10,
      s12: s12 ?? this.s12,
      s14: s14 ?? this.s14,
      s16: s16 ?? this.s16,
      s18: s18 ?? this.s18,
      s20: s20 ?? this.s20,
      s22: s22 ?? this.s22,
      s24: s24 ?? this.s24,
      s26: s26 ?? this.s26,
      s30: s30 ?? this.s30,
      s32: s32 ?? this.s32,
      s40: s40 ?? this.s40,
      s46: s46 ?? this.s46,
      s48: s48 ?? this.s48,
      s56: s56 ?? this.s56,
      s57: s57 ?? this.s57,
      s72: s72 ?? this.s72,
      s80: s80 ?? this.s80,
      s96: s96 ?? this.s96,
      s112: s112 ?? this.s112,
      s114: s114 ?? this.s114,
      s120: s120 ?? this.s120,
      s128: s128 ?? this.s128,
      s160: s160 ?? this.s160,
      w320: w320 ?? this.w320,
      w243: w243 ?? this.w243,
      w208: w208 ?? this.w208,
      w184: w184 ?? this.w184,
      w96: w96 ?? this.w96,
    );
  }

  @override
  AppSpacing lerp(ThemeExtension<AppSpacing>? other, double t) {
    return other is AppSpacing ? other : this;
  }
}

// -----------------------------------------------------------------------------
// Radii

@immutable
class AppRadii extends ThemeExtension<AppRadii> {
  final double r5;
  final double r10;
  final double r20;
  final double r30;

  const AppRadii({
    required this.r5,
    required this.r10,
    required this.r20,
    required this.r30,
  });

  static const base = AppRadii(r5: 5, r10: 10, r20: 20, r30: 30);

  @override
  AppRadii copyWith({double? r5, double? r10, double? r20, double? r30}) {
    return AppRadii(
      r5: r5 ?? this.r5,
      r10: r10 ?? this.r10,
      r20: r20 ?? this.r20,
      r30: r30 ?? this.r30,
    );
  }

  @override
  AppRadii lerp(ThemeExtension<AppRadii>? other, double t) {
    return other is AppRadii ? other : this;
  }
}

// -----------------------------------------------------------------------------
// Shadows / effects

@immutable
class AppShadows extends ThemeExtension<AppShadows> {
  final BoxShadow card; // 0 2 4 rgba(0,0,0,0.1)
  final BoxShadow strong; // rgba(0,0,0,0.25)

  const AppShadows({
    required this.card,
    required this.strong,
  });

  static const base = AppShadows(
    card: BoxShadow(
      offset: Offset(0, 2),
      blurRadius: 4,
      color: AppPalette.shadow10,
    ),
    strong: BoxShadow(
      offset: Offset(0, 2),
      blurRadius: 4,
      color: AppPalette.shadow25,
    ),
  );

  @override
  AppShadows copyWith({BoxShadow? card, BoxShadow? strong}) {
    return AppShadows(
      card: card ?? this.card,
      strong: strong ?? this.strong,
    );
  }

  @override
  AppShadows lerp(ThemeExtension<AppShadows>? other, double t) {
    return other is AppShadows ? other : this;
  }
}

// -----------------------------------------------------------------------------
// Typography

@immutable
class AppTypography extends ThemeExtension<AppTypography> {
  final String family;

  final FontWeight w400;
  final FontWeight w500;
  final FontWeight w600;
  final FontWeight w700;

  final double fs12;
  final double fs14;
  final double fs16;
  final double fs18;
  final double fs20;
  final double fs22;
  final double fs24;
  final double fs26;
  final double fs30;

  const AppTypography({
    required this.family,
    required this.w400,
    required this.w500,
    required this.w600,
    required this.w700,
    required this.fs12,
    required this.fs14,
    required this.fs16,
    required this.fs18,
    required this.fs20,
    required this.fs22,
    required this.fs24,
    required this.fs26,
    required this.fs30,
  });

  static const base = AppTypography(
    family: 'Inter',
    w400: FontWeight.w400,
    w500: FontWeight.w500,
    w600: FontWeight.w600,
    w700: FontWeight.w700,
    fs12: 12,
    fs14: 14,
    fs16: 16,
    fs18: 18,
    fs20: 20,
    fs22: 22,
    fs24: 24,
    fs26: 26,
    fs30: 30,
  );

  @override
  AppTypography copyWith({
    String? family,
    FontWeight? w400,
    FontWeight? w500,
    FontWeight? w600,
    FontWeight? w700,
    double? fs12,
    double? fs14,
    double? fs16,
    double? fs18,
    double? fs20,
    double? fs22,
    double? fs24,
    double? fs26,
    double? fs30,
  }) {
    return AppTypography(
      family: family ?? this.family,
      w400: w400 ?? this.w400,
      w500: w500 ?? this.w500,
      w600: w600 ?? this.w600,
      w700: w700 ?? this.w700,
      fs12: fs12 ?? this.fs12,
      fs14: fs14 ?? this.fs14,
      fs16: fs16 ?? this.fs16,
      fs18: fs18 ?? this.fs18,
      fs20: fs20 ?? this.fs20,
      fs22: fs22 ?? this.fs22,
      fs24: fs24 ?? this.fs24,
      fs26: fs26 ?? this.fs26,
      fs30: fs30 ?? this.fs30,
    );
  }

  @override
  AppTypography lerp(ThemeExtension<AppTypography>? other, double t) {
    return other is AppTypography ? other : this;
  }
}

// -----------------------------------------------------------------------------
// AppTheme (ThemeData builder)

class AppTheme {
  static ThemeData get lightTheme => _build(
    brightness: Brightness.light,
    colors: AppColors.light,
  );

  static ThemeData get darkTheme => _build(
    brightness: Brightness.dark,
    colors: AppColors.dark,
  );

  static ThemeData _build({
    required Brightness brightness,
    required AppColors colors,
  }) {
    final typography = AppTypography.base;
    final spacing = AppSpacing.base;
    final radii = AppRadii.base;
    final shadows = AppShadows.base;

    final isDark = brightness == Brightness.dark;

    return ThemeData(
      useMaterial3: true,
      brightness: brightness,
      fontFamily: typography.family,
      scaffoldBackgroundColor: colors.background,
      // вњ… Р­С‚Рѕ РєСЂРёС‚РёС‡РЅРѕ РґР»СЏ appColors/appSpace/...
      extensions: <ThemeExtension<dynamic>>[
        colors,
        typography,
        spacing,
        radii,
        shadows,
      ],
      colorScheme: ColorScheme.fromSeed(
        seedColor: colors.brand,
        brightness: brightness,
        primary: colors.brand,
        surface: colors.surface,
      ),
      dividerColor: colors.divider,
      cardTheme: CardThemeData(
        elevation: 0,
        color: colors.surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radii.r5),
          side: BorderSide(
            color: isDark ? Colors.transparent : colors.divider,
            width: 1,
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colors.surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(radii.r10),
          borderSide: BorderSide.none,
        ),
        hintStyle: TextStyle(
          fontFamily: typography.family,
          fontSize: typography.fs16,
          fontWeight: typography.w400,
          color: colors.textSecondary,
          height: 1.0,
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.brandStrong,
          foregroundColor: colors.textOnBrand,
          disabledBackgroundColor: colors.shadow,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radii.r10),
          ),
          textStyle: TextStyle(
            fontFamily: typography.family,
            fontWeight: typography.w600,
            fontSize: typography.fs20,
            height: 1.0,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          backgroundColor: colors.surface,
          foregroundColor: colors.brandStrong,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radii.r10),
          ),
          side: BorderSide(
            color: isDark ? Colors.transparent : colors.divider,
            width: 1,
          ),
          padding: EdgeInsets.symmetric(
            vertical: spacing.s12,
            horizontal: spacing.s14,
          ),
          textStyle: TextStyle(
            fontFamily: typography.family,
            fontSize: typography.fs16,
            fontWeight: typography.w400,
            height: 1.0,
          ),
        ),
      ),
      textTheme: TextTheme(
        titleLarge: TextStyle(
          fontFamily: typography.family,
          fontSize: typography.fs26,
          fontWeight: typography.w600,
          color: colors.textOnBrand,
          height: 1.0,
        ),
        titleMedium: TextStyle(
          fontFamily: typography.family,
          fontSize: typography.fs22,
          fontWeight: typography.w600,
          color: colors.textPrimary,
          height: 1.0,
        ),
        bodyLarge: TextStyle(
          fontFamily: typography.family,
          fontSize: typography.fs18,
          fontWeight: typography.w400,
          color: colors.textPrimary,
          height: 1.0,
        ),
        bodyMedium: TextStyle(
          fontFamily: typography.family,
          fontSize: typography.fs16,
          fontWeight: typography.w400,
          color: colors.textPrimary,
          height: 1.0,
        ),
        labelLarge: TextStyle(
          fontFamily: typography.family,
          fontSize: typography.fs14,
          fontWeight: typography.w500,
          color: colors.textSecondary,
          height: 1.0,
        ),
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// Context accessors (СЌС‚Рѕ Рё РµСЃС‚СЊ appColors/appSpace/...)

extension AppThemeX on BuildContext {
  AppColors get appColors => Theme.of(this).extension<AppColors>() ?? AppColors.light;
  AppTypography get appText => Theme.of(this).extension<AppTypography>() ?? AppTypography.base;
  AppSpacing get appSpace => Theme.of(this).extension<AppSpacing>() ?? AppSpacing.base;
  AppRadii get appRadii => Theme.of(this).extension<AppRadii>() ?? AppRadii.base;
  AppShadows get appShadow => Theme.of(this).extension<AppShadows>() ?? AppShadows.base;
}

// -----------------------------------------------------------------------------
// Legacy API (С‡С‚РѕР±С‹ СЃС‚Р°СЂС‹Р№ РєРѕРґ РЅРµ РїРѕСЃС‹РїР°Р»СЃСЏ)

class AppUI {
  // Sizes
  static const double hPad = 20.0;
  static const double cardRadius = 5.0;
  static const double fieldRadius = 10.0;
  static const double fieldHeight = 48.0;
  static const double noteHeight = 72.0;
  static const double keypadButtonWidth = 96.0;
  static const double keypadButtonHeight = 48.0;
  static const double dateButtonWidth = 208.0;
  static const double timeButtonWidth = 96.0;
  static const double dateTextWidth = 184.0;
  static const double timeTextWidth = 57.0;
  static const double noteWidth = 320.0;

  // Colors (light-ish legacy)
  static const Color primaryBlue = AppPalette.blueAccent;
  static const Color headerBlue = AppPalette.blue700;
  static const Color buttonBlue = AppPalette.blue900;
  static const Color summaryCardColor = AppPalette.blue600;
  static const Color background = AppPalette.grey200;

  static const Color textPrimary = Color(0xFF1C1C1C);
  static const Color textSecondary = AppPalette.grey500;
  static const Color textLight = AppPalette.grey500;
  static const Color textTime = AppPalette.blue900;

  static const Color accentRed = AppPalette.red;
  static const Color accentGreen = AppPalette.green;
  static const Color accentBlue = AppPalette.blueAccent;
  static const Color accentOrange = AppPalette.amber;

  static const Color todayButtonColor = AppPalette.blue500;

  static const Color white = _C.white;
  static const Color dividerColor = AppPalette.shadow10;

  static const BoxShadow shadow4x2 = BoxShadow(
    offset: Offset(0, 2),
    blurRadius: 4,
    color: AppPalette.shadow10,
  );
}
import 'dart:math' as math;
import 'package:flutter/widgets.dart';

const double _designHeight = 800.0; // СЌС‚Р°Р»РѕРЅРЅР°СЏ РІС‹СЃРѕС‚Р° РјР°РєРµС‚Р° (dp)

double _scale(BuildContext context) {
  final h = MediaQuery.sizeOf(context).height;
  final safeH = math.max(1.0, h);
  return safeH / _designHeight;
}

double dp(BuildContext context, double designPx) =>
    designPx * _scale(context);

double sp(BuildContext context, double designSp) =>
    designSp * _scale(context);
class AppStrings {
  static const newRecord = 'РќРѕРІР°СЏ Р·Р°РїРёСЃСЊ';
  static const deleteRecordQ = 'РЈРґР°Р»РёС‚СЊ Р·Р°РїРёСЃСЊ?';
  static const cannotUndo = 'Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.';
  static const cancel = 'РћС‚РјРµРЅР°';
  static const delete = 'РЈРґР°Р»РёС‚СЊ';
  static const pickTime = 'Р’С‹Р±РµСЂРёС‚Рµ РІСЂРµРјСЏ';
  static const pickDate = 'Р’С‹Р±РµСЂРёС‚Рµ РґР°С‚Сѓ';
  static const systolicShort = 'РЎРёСЃС‚.';
  static const diastolicShort = 'Р”РёР°СЃС‚.';
  static const pulse = 'РџСѓР»СЊСЃ';
  static const commentHint = 'РљРѕРјРјРµРЅС‚Р°СЂРёР№';
  static const save = 'РЎРѕС…СЂР°РЅРёС‚СЊ';
  static const today = 'РЎРµРіРѕРґРЅСЏ';
  static const week = 'РќРµРґРµР»СЏ';
  static const month = 'РњРµСЃСЏС†';
  static const allShort = 'Р’СЃС‘';
  static const allTime = 'Р’СЃС‘ РІСЂРµРјСЏ';
  static const myDiary = 'РњРѕР№ РґРЅРµРІРЅРёРє';
  static String recordsWord(int n) {
    final nAbs = n.abs() % 100;
    final n1 = nAbs % 10;
    if (nAbs >= 11 && nAbs <= 19) return 'Р·Р°РїРёСЃРµР№';
    if (n1 == 1) return 'Р·Р°РїРёСЃСЊ';
    if (n1 >= 2 && n1 <= 4) return 'Р·Р°РїРёСЃРё';
    return 'Р·Р°РїРёСЃРµР№';
  }
}
import 'package:flutter/material.dart';
import '../theme/app_theme.dart';

class BloodPressureColorUtils {
  /// Р¦РІРµС‚ РјР°СЂРєРµСЂР° Р·Р°РїРёСЃРё РІ Р¶СѓСЂРЅР°Р»Рµ.
  /// Р›РѕРіРёРєР° СЃРёРЅС…СЂРѕРЅРёР·РёСЂРѕРІР°РЅР° СЃ Р·РѕРЅР°РјРё РЅР° РіСЂР°С„РёРєРµ:
  /// SYS: target В±10, DIA: target В±5.
  static Color getIndicatorColor(
      BuildContext context, {
        required int systolic,
        required int diastolic,
        required int targetSystolic,
        required int targetDiastolic,
      }) {
    final c = context.appColors;

    const sysDelta = 10;
    const diaDelta = 5;

    final sysLow = targetSystolic - sysDelta;
    final sysHigh = targetSystolic + sysDelta;
    final diaLow = targetDiastolic - diaDelta;
    final diaHigh = targetDiastolic + diaDelta;

    final isLow = systolic < sysLow || diastolic < diaLow;
    final isHigh = systolic > sysHigh || diastolic > diaHigh;

    if (isHigh) return c.danger;
    if (isLow) return AppPalette.blueAccent; // РЅРёР·РєРѕРµ РґР°РІР»РµРЅРёРµ
    return c.success; // РІ Р·РѕРЅРµ
  }
}
import 'input_field.dart';
import 'pressure_field.dart';

PressureField? toPressureField(InputField f) {
  return switch (f) {
    InputField.systolic => PressureField.systolic,
    InputField.diastolic => PressureField.diastolic,
    InputField.pulse => PressureField.pulse,
    _ => null,
  };
}
enum InputField { systolic, diastolic, pulse, none }
import 'package:url_launcher/url_launcher.dart';
import 'dart:io' show Platform;

Future<void> launchEmail({
  required String to,
  required String subject,
  String? body,
}) async {
  final uri = Uri(
    scheme: 'mailto',
    path: to,
    queryParameters: <String, String>{
      'subject': subject,
      if (body != null && body.trim().isNotEmpty) 'body': body,
    },
  );

  if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {
    // РјРѕР¶РЅРѕ РїРѕРєР°Р·Р°С‚СЊ SnackBar/Toast вЂ” РєР°Рє Сѓ С‚РµР±СЏ РїСЂРёРЅСЏС‚Рѕ РІ РїСЂРѕРµРєС‚Рµ
    throw Exception('Could not launch email client');
  }
}

Future<void> rateApp({
  required String androidPackageName,
  String? iosAppId, // РєРѕРіРґР° РїРѕСЏРІРёС‚СЃСЏ
}) async {
  if (Platform.isAndroid) {
    final marketUri = Uri.parse('market://details?id=$androidPackageName');
    if (await canLaunchUrl(marketUri)) {
      await launchUrl(marketUri, mode: LaunchMode.externalApplication);
      return;
    }
    final webUri = Uri.parse('https://play.google.com/store/apps/details?id=$androidPackageName');
    await launchUrl(webUri, mode: LaunchMode.externalApplication);
    return;
  }

  if (Platform.isIOS) {
    if (iosAppId == null || iosAppId.isEmpty) {
      // РїРѕРєР° РЅРµ РѕРїСѓР±Р»РёРєРѕРІР°РЅРѕ вЂ” РјРѕР¶РЅРѕ РїСЂРѕСЃС‚Рѕ РјРѕР»С‡Р° РёРіРЅРѕСЂРёС‚СЊ РёР»Рё РїРѕРєР°Р·Р°С‚СЊ РїРѕРґСЃРєР°Р·РєСѓ
      throw Exception('iOS App ID is not set yet');
    }
    final uri = Uri.parse('https://apps.apple.com/app/id$iosAppId?action=write-review');
    await launchUrl(uri, mode: LaunchMode.externalApplication);
  }
}
enum PressureCategory {
  low,
  normal,
  elevated,
  high1,
  high2,
  crisis
}

class PressureAssessmentPolicy {
  /// РћС†РµРЅРёРІР°РµС‚ СЃРѕСЃС‚РѕСЏРЅРёРµ РЅР° РѕСЃРЅРѕРІРµ СЃРёСЃС‚РѕР»РёС‡РµСЃРєРѕРіРѕ Рё РґРёР°СЃС‚РѕР»РёС‡РµСЃРєРѕРіРѕ РґР°РІР»РµРЅРёСЏ.
  /// Р›РѕРіРёРєР° РѕСЃРЅРѕРІР°РЅР° РЅР° СЃС‚Р°РЅРґР°СЂС‚РЅС‹С… РјРµРґРёС†РёРЅСЃРєРёС… СЂРµРєРѕРјРµРЅРґР°С†РёСЏС…, РЅРѕ РјРѕР¶РµС‚ Р±С‹С‚СЊ СЂР°СЃС€РёСЂРµРЅР°.
  static PressureCategory assess(int systolic, int diastolic) {
    if (systolic >= 180 || diastolic >= 120) return PressureCategory.crisis;
    if (systolic >= 160 || diastolic >= 100) return PressureCategory.high2;
    if (systolic >= 140 || diastolic >= 90) return PressureCategory.high1;
    if (systolic >= 130 || diastolic >= 80) return PressureCategory.elevated;
    if (systolic < 90 || diastolic < 60) return PressureCategory.low;
    return PressureCategory.normal;
  }

  static bool isHigh(int systolic, int diastolic) {
    final category = assess(systolic, diastolic);
    return category == PressureCategory.high1 || 
           category == PressureCategory.high2 || 
           category == PressureCategory.crisis;
  }

  static bool isLow(int systolic, int diastolic) {
    return assess(systolic, diastolic) == PressureCategory.low;
  }
}
enum PressureField { systolic, diastolic, pulse }
import 'package:blood_pressure_diary/core/utils/input_field.dart';
import 'package:blood_pressure_diary/core/utils/validation_policy.dart';
import 'package:blood_pressure_diary/core/utils/validation_utils.dart';

class SmartInputEngine {
  /// РћРїСЂРµРґРµР»СЏРµС‚ С†РµР»РµРІСѓСЋ РґР»РёРЅСѓ РїРѕР»СЏ РЅР° РѕСЃРЅРѕРІРµ РїРµСЂРІРѕР№ РІРІРµРґРµРЅРЅРѕР№ С†РёС„СЂС‹.
  static int getTargetLength(InputField field, String currentText, String nextDigit) {
    assert(currentText.isNotEmpty || nextDigit.isNotEmpty);
    final first = currentText.isEmpty ? nextDigit : currentText[0];
    return _targetLenByFirstDigit(field: field, firstDigit: first);
  }

  /// РџСЂРѕРІРµСЂСЏРµС‚, РјРѕР¶РЅРѕ Р»Рё РґРѕР±Р°РІРёС‚СЊ С†РёС„СЂСѓ Рє С‚РµРєСѓС‰РµРјСѓ С‚РµРєСЃС‚Сѓ.
  static bool isDigitAllowed({
    required InputField field,
    required String currentText,
    required String digit,
    int? systolicValue,
  }) {
    if (digit.length != 1) return false;
    final code = digit.codeUnitAt(0);
    if (code < 48 || code > 57) return false;

    // Р’РµРґСѓС‰РёР№ РЅРѕР»СЊ Р·Р°РїСЂРµС‰РµРЅ
    if (currentText.isEmpty && digit == '0') return false;

    final newText = currentText + digit;
    final targetLen = getTargetLength(field, currentText, digit);

    // Р•СЃР»Рё РїСЂРµРІС‹С€Р°РµРј РґР»РёРЅСѓ вЂ” Р·Р°РїСЂРµС‰РµРЅРѕ
    if (newText.length > targetLen) return false;

    // Р•СЃР»Рё СЌС‚Рѕ С„РёРЅР°Р»СЊРЅР°СЏ РґР»РёРЅР° вЂ” РїСЂРѕРІРµСЂСЏРµРј РґРёР°РїР°Р·РѕРЅ
    if (newText.length == targetLen) {
      final value = int.tryParse(newText) ?? 0;
      return _isInRange(field, value, systolicValue);
    }

    // Р•СЃР»Рё СЌС‚Рѕ РїСЂРѕРјРµР¶СѓС‚РѕС‡РЅС‹Р№ РІРІРѕРґ вЂ” РїСЂРѕРІРµСЂСЏРµРј, РґРѕСЃС‚РёР¶РёРј Р»Рё С…РѕС‚СЊ РѕРґРёРЅ РІР°Р»РёРґРЅС‹Р№ СЂРµР·СѓР»СЊС‚Р°С‚
    return _isReachable(field, newText, targetLen, systolicValue);
  }

  /// РќСѓР¶РЅРѕ Р»Рё Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРё РїРµСЂРµС…РѕРґРёС‚СЊ Рє СЃР»РµРґСѓСЋС‰РµРјСѓ РїРѕР»СЋ.
  static bool shouldAutoAdvance({
    required InputField field,
    required String currentText,
    int? systolicValue,
  }) {
    if (currentText.isEmpty) return false;

    final targetLen = _targetLenByFirstDigit(field: field, firstDigit: currentText[0]);
    if (currentText.length >= targetLen) return true;

    for (int i = 0; i <= 9; i++) {
      if (isDigitAllowed(
        field: field,
        currentText: currentText,
        digit: i.toString(),
        systolicValue: systolicValue,
      )) {
        return false;
      }
    }
    return true;
  }

  static bool _isInRange(InputField field, int value, int? systolicValue) {
    return switch (field) {
      InputField.systolic =>
      value >= ValidationPolicy.minSys && value <= ValidationPolicy.maxSys,
      InputField.diastolic => _isDiaInRange(value, systolicValue),
      InputField.pulse =>
      value >= ValidationPolicy.minPulse && value <= ValidationPolicy.maxPulse,
      _ => true,
    };
  }

  static bool _isDiaInRange(int value, int? systolicValue) {
    if (systolicValue == null) {
      return value >= ValidationPolicy.minDia && value <= ValidationPolicy.maxDia;
    }
    final (min, max) = ValidationUtils.diaRangeForSys(systolicValue);
    return value >= min && value <= max;
  }

  static bool _isReachable(
      InputField field,
      String prefix,
      int targetLen,
      int? systolicValue,
      ) {
    final diff = targetLen - prefix.length;
    if (diff <= 0) return _isInRange(field, int.parse(prefix), systolicValue);

    final minPossible = int.parse(prefix + ('0' * diff));
    final maxPossible = int.parse(prefix + ('9' * diff));

    return switch (field) {
      InputField.systolic =>
      !(maxPossible < ValidationPolicy.minSys || minPossible > ValidationPolicy.maxSys),
      InputField.diastolic => _isDiaReachable(minPossible, maxPossible, systolicValue),
      InputField.pulse =>
      !(maxPossible < ValidationPolicy.minPulse || minPossible > ValidationPolicy.maxPulse),
      _ => true,
    };
  }

  static bool _isDiaReachable(int minPossible, int maxPossible, int? systolicValue) {
    int minAllowed = ValidationPolicy.minDia;
    int maxAllowed = ValidationPolicy.maxDia;

    if (systolicValue != null) {
      final (min, max) = ValidationUtils.diaRangeForSys(systolicValue);
      minAllowed = min;
      maxAllowed = max;
    }

    return !(maxPossible < minAllowed || minPossible > maxAllowed);
  }

  static int _targetLenByFirstDigit({
    required InputField field,
    required String firstDigit,
  }) {
    return switch (field) {
      InputField.systolic => (firstDigit == '1' || firstDigit == '2') ? 3 : 2,
      InputField.diastolic => (firstDigit == '1') ? 3 : 2,
      InputField.pulse => (firstDigit == '1' || firstDigit == '2') ? 3 : 2,
      _ => 3,
    };
  }

}
class ValidationPolicy {
  static const int minSys = 50;
  static const int maxSys = 250;

  static const int minDia = 30;
  static const int maxDia = 150;

  static const int minPulse = 30;
  static const int maxPulse = 250;

  static const int maxSysDiaDiff = 110;
}
import 'validation_policy.dart';

class ValidationUtils {
  /// РџСЂРѕРІРµСЂРєР° С„РёРЅР°Р»СЊРЅРѕР№ РІР°Р»РёРґРЅРѕСЃС‚Рё РІСЃРµР№ С„РѕСЂРјС‹.
  static bool isFormValid({
    required String systolic,
    required String diastolic,
    required String pulse,
  }) {
    final sys = int.tryParse(systolic);
    final dia = int.tryParse(diastolic);
    final pul = int.tryParse(pulse);

    if (sys == null || dia == null || pul == null) return false;

    if (sys < ValidationPolicy.minSys || sys > ValidationPolicy.maxSys) return false;
    if (pul < ValidationPolicy.minPulse || pul > ValidationPolicy.maxPulse) return false;

    final (diaMin, diaMax) = diaRangeForSys(sys);
    if (dia < diaMin || dia > diaMax) return false;

    return true;
  }

  /// Р”РѕРїСѓСЃС‚РёРјС‹Р№ РґРёР°РїР°Р·РѕРЅ DIA Р·Р°РІРёСЃРёС‚ РѕС‚ С‚РµРєСѓС‰РµРіРѕ SYS.
  static (int, int) diaRangeForSys(int sys) {
    final lo = (sys - ValidationPolicy.maxSysDiaDiff) > ValidationPolicy.minDia
        ? (sys - ValidationPolicy.maxSysDiaDiff)
        : ValidationPolicy.minDia;

    final hi = (sys - 1) < ValidationPolicy.maxDia
        ? (sys - 1)
        : ValidationPolicy.maxDia;

    return (lo, hi);
  }
}
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/repositories/pressure_repository.dart';
import '../../../../core/utils/validation_utils.dart';
import '../../../../core/utils/smart_input_engine.dart';
import '../../../home/data/blood_pressure_model.dart';
import 'add_record_event.dart';
import 'add_record_state.dart';
import 'package:blood_pressure_diary/core/utils/input_field.dart';

class AddRecordBloc extends Bloc<AddRecordEvent, AddRecordState> {
  final PressureRepository _repository;
  int? _editingId;

  AddRecordBloc(this._repository) : super(AddRecordState()) {
    on<EditStarted>(_onEditStarted);
    on<NumberPressed>(_onNumberPressed);
    on<BackspacePressed>(_onBackspacePressed);
    on<FieldChanged>(_onFieldChanged);
    on<NoteChanged>((event, emit) => emit(state.copyWith(note: event.note)));
    on<SaveSubmitted>(_onSaveSubmitted);
    on<DeleteSubmitted>(_onDeleteSubmitted);
    on<DateTimeSet>((event, emit) => emit(state.copyWith(selectedDateTime: event.value)));
    on<TagToggled>(_onTagToggled);
    on<TagsExpandedToggled>((event, emit) {
      emit(state.copyWith(isTagsExpanded: !state.isTagsExpanded));
    });

    // РљР РРўРР§РќРћ: РРЅРёС†РёР°Р»РёР·РёСЂСѓРµРј РєРЅРѕРїРєРё РґР»СЏ РїСѓСЃС‚РѕРіРѕ СЃРѕСЃС‚РѕСЏРЅРёСЏ СЃРёСЃС‚РѕР»С‹ СЃСЂР°Р·Сѓ
    add(const FieldChanged(InputField.systolic));
  }

  void _onNumberPressed(NumberPressed event, Emitter<AddRecordState> emit) {
    if (state.activeField == InputField.none) {
      final ns = state.copyWith(activeField: InputField.systolic);
      emit(ns);
      _updateEnabledKeys(emit, ns);
      return;
    }

    if (!state.enabledKeys.contains(event.number)) return;

    final cur = _getVal(state.activeField);
    final next = cur + event.number;

    // 1) РѕР±РЅРѕРІР»СЏРµРј Р·РЅР°С‡РµРЅРёРµ РїРѕР»СЏ
    final ns = _updateStateValue(state, state.activeField, next);

    // 2) Р°РІС‚Рѕ-РїРµСЂРµС…РѕРґ
    final nextField = _getAutoNextField(ns);

    if (nextField != ns.activeField) {
      final finalState = ns.copyWith(activeField: nextField);
      emit(finalState);
      _updateEnabledKeys(emit, finalState);
    } else {
      emit(ns);
      _updateEnabledKeys(emit, ns);
    }
  }

  InputField _getAutoNextField(AddRecordState s) {
    final val = _getValFrom(s, s.activeField);
    if (val.isEmpty) return s.activeField;

    final sys = int.tryParse(s.systolic);

    if (SmartInputEngine.shouldAutoAdvance(
      field: s.activeField,
      currentText: val,
      systolicValue: sys,
    )) {
      return switch (s.activeField) {
        InputField.systolic => InputField.diastolic,
        InputField.diastolic => InputField.pulse,
        InputField.pulse => InputField.none,
        _ => s.activeField,
      };
    }

    return s.activeField;
  }

  void _updateEnabledKeys(Emitter<AddRecordState> emit, AddRecordState s) {
    final val = _getValFrom(s, s.activeField);
    final sys = int.tryParse(s.systolic);

    const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
    final allowed = <String>[];

    for (final d in digits) {
      if (SmartInputEngine.isDigitAllowed(
        field: s.activeField,
        currentText: val,
        digit: d,
        systolicValue: sys,
      )) {
        allowed.add(d);
      }
    }

    emit(s.copyWith(enabledKeys: allowed));
  }

  void _onFieldChanged(FieldChanged event, Emitter<AddRecordState> emit) {
    final ns = state.copyWith(activeField: event.field);
    emit(ns);
    _updateEnabledKeys(emit, ns);
  }

  String _getValFrom(AddRecordState s, InputField field) {
    if (field == InputField.systolic) return s.systolic;
    if (field == InputField.diastolic) return s.diastolic;
    if (field == InputField.pulse) return s.pulse;
    return '';
  }

  String _getVal(InputField field) => _getValFrom(state, field);

  void _onEditStarted(EditStarted event, Emitter<AddRecordState> emit) {
    _editingId = event.record.id;
    final ns = state.copyWith(
      systolic: event.record.systolic.toString(),
      diastolic: event.record.diastolic.toString(),
      pulse: event.record.pulse.toString(),
      note: event.record.note,
      selectedDateTime: event.record.dateTime,
      activeField: InputField.systolic,
      tags: List<String>.from(event.record.tags),
      isTagsExpanded: event.record.tags.isNotEmpty,
    );
    emit(ns);
    _updateEnabledKeys(emit, ns);
  }

  AddRecordState _updateStateValue(AddRecordState s, InputField field, String val) {
    if (field == InputField.systolic) return s.copyWith(systolic: val);
    if (field == InputField.diastolic) return s.copyWith(diastolic: val);
    if (field == InputField.pulse) return s.copyWith(pulse: val);
    return s;
  }

  void _onTagToggled(
      TagToggled event,
      Emitter<AddRecordState> emit,
      ) {
    final current = List<String>.from(state.tags);

    if (current.contains(event.tag)) {
      current.remove(event.tag);
    } else {
      current.add(event.tag);
    }

    emit(state.copyWith(tags: current));
  }

  void _onBackspacePressed(BackspacePressed event, Emitter<AddRecordState> emit) {
    final cur = _getVal(state.activeField);
    if (cur.isEmpty) return;

    final next = cur.substring(0, cur.length - 1);
    final ns = _updateStateValue(state, state.activeField, next);
    emit(ns);
    _updateEnabledKeys(emit, ns);
  }

  Future<void> _onSaveSubmitted(SaveSubmitted event, Emitter<AddRecordState> emit) async {
    if (!ValidationUtils.isFormValid(
      systolic: state.systolic,
      diastolic: state.diastolic,
      pulse: state.pulse,
    )) {
      return;
    }

    final record = BloodPressureRecord()
      ..systolic = int.parse(state.systolic)
      ..diastolic = int.parse(state.diastolic)
      ..pulse = int.parse(state.pulse)
      ..note = state.note
      ..dateTime = state.selectedDateTime
      ..tags = List<String>.from(state.tags);

    if (_editingId != null) {
      record.id = _editingId!;
    }

    await _repository.addRecord(record);
    emit(state.copyWith(isSaved: true));
  }

  Future<void> _onDeleteSubmitted(DeleteSubmitted event, Emitter<AddRecordState> emit) async {
    if (_editingId != null) {
      await _repository.deleteRecord(_editingId!);
      emit(state.copyWith(isSaved: true));
    }
  }
}
import 'package:equatable/equatable.dart';
// РРјРїРѕСЂС‚РёСЂСѓРµРј РјРѕРґРµР»СЊ, С‡С‚РѕР±С‹ СЃРѕР±С‹С‚РёРµ EditStarted Р·РЅР°Р»Рѕ Рѕ BloodPressureRecord
import '../../../home/data/blood_pressure_model.dart';
import 'package:blood_pressure_diary/core/utils/input_field.dart';


abstract class AddRecordEvent extends Equatable {
  const AddRecordEvent();
  @override
  List<Object?> get props => [];
}

// РЎРћР‘Р«РўРР• Р”Р›РЇ Р Р•Р”РђРљРўРР РћР’РђРќРРЇ
class EditStarted extends AddRecordEvent {
  final BloodPressureRecord record;
  const EditStarted(this.record);

  @override
  List<Object?> get props => [record];
}

class NumberPressed extends AddRecordEvent {
  final String number;
  const NumberPressed(this.number);
  @override
  List<Object?> get props => [number];
}

class BackspacePressed extends AddRecordEvent {}

class FieldChanged extends AddRecordEvent {
  final InputField field;
  const FieldChanged(this.field);
  @override
  List<Object?> get props => [field];
}

// РЎРћР‘Р«РўРР• Р”Р›РЇ Р—РђРњР•РўРћРљ
class NoteChanged extends AddRecordEvent {
  final String note;
  const NoteChanged(this.note);

  @override
  List<Object?> get props => [note];
}

class TagToggled extends AddRecordEvent {
  final String tag;

  const TagToggled(this.tag);
}

class TagsExpandedToggled extends AddRecordEvent {
  const TagsExpandedToggled();
}

class EmotionChanged extends AddRecordEvent {
  final String emotion;
  const EmotionChanged(this.emotion);
  @override
  List<Object?> get props => [emotion];
}

class EmojiAppended extends AddRecordEvent {
  final String emoji;
  const EmojiAppended(this.emoji);

  @override
  List<Object?> get props => [emoji];
}

class SaveSubmitted extends AddRecordEvent {}
class DeleteSubmitted extends AddRecordEvent {}

class DateTimeSet extends AddRecordEvent {
  final DateTime value;
  const DateTimeSet(this.value);
  @override
  List<Object?> get props => [value];
}
import 'package:equatable/equatable.dart';

import 'package:blood_pressure_diary/core/utils/input_field.dart';
import '../../../../core/utils/validation_utils.dart';

class AddRecordState extends Equatable {
  final String systolic;
  final String diastolic;
  final String pulse;
  final String note;

  final DateTime selectedDateTime;
  final InputField activeField;

  final bool isSaved;

  /// Р Р°Р·СЂРµС€С‘РЅРЅС‹Рµ РєРЅРѕРїРєРё РєР°СЃС‚РѕРјРЅРѕР№ РєР»Р°РІРёР°С‚СѓСЂС‹ (СЃС‚СЂРѕРєРё С†РёС„СЂ).
  final List<String> enabledKeys;

  /// Р’С‹Р±СЂР°РЅРЅС‹Рµ С‚РµРіРё (С…СЂР°РЅРёРј С‚РµРєСЃС‚РѕРІС‹Рµ label).
  final List<String> tags;

  /// Р Р°СЃРєСЂС‹С‚ Р»Рё Р±Р»РѕРє С‚РµРіРѕРІ РЅР° СЌРєСЂР°РЅРµ.
  final bool isTagsExpanded;

  AddRecordState({
    this.systolic = '',
    this.diastolic = '',
    this.pulse = '',
    this.note = '',
    DateTime? selectedDateTime,
    this.activeField = InputField.systolic,
    this.isSaved = false,
    this.enabledKeys = const [],
    this.tags = const [],
    this.isTagsExpanded = false,
  }) : selectedDateTime = selectedDateTime ?? DateTime.now();

  bool get isValid => ValidationUtils.isFormValid(
    systolic: systolic,
    diastolic: diastolic,
    pulse: pulse,
  );

  AddRecordState copyWith({
    String? systolic,
    String? diastolic,
    String? pulse,
    String? note,
    DateTime? selectedDateTime,
    InputField? activeField,
    bool? isSaved,
    List<String>? enabledKeys,
    List<String>? tags,
    bool? isTagsExpanded,
  }) {
    return AddRecordState(
      systolic: systolic ?? this.systolic,
      diastolic: diastolic ?? this.diastolic,
      pulse: pulse ?? this.pulse,
      note: note ?? this.note,
      selectedDateTime: selectedDateTime ?? this.selectedDateTime,
      activeField: activeField ?? this.activeField,
      isSaved: isSaved ?? this.isSaved,
      enabledKeys: enabledKeys ?? this.enabledKeys,
      tags: tags ?? this.tags,
      isTagsExpanded: isTagsExpanded ?? this.isTagsExpanded,
    );
  }

  @override
  List<Object?> get props => [
    systolic,
    diastolic,
    pulse,
    note,
    selectedDateTime,
    activeField,
    isSaved,
    enabledKeys,
    tags,
    isTagsExpanded,
  ];
}
import 'package:flutter/material.dart';

class CustomKeypad extends StatelessWidget {
  final Function(String) onKeyPressed;
  final VoidCallback onDeletePressed;
  final List<String>? enabledKeys;

  final double horizontalPadding;
  final double gap;
  final double cellHeight;
  final double radius;

  final Color background;
  final Color deleteBackground;
  final Color foreground;
  final TextStyle textStyle;

  final double deleteIconSize;
  final Color deleteIconColor;

  const CustomKeypad({
    super.key,
    required this.onKeyPressed,
    required this.onDeletePressed,
    this.enabledKeys,
    required this.horizontalPadding,
    required this.gap,
    required this.cellHeight,
    required this.radius,
    required this.background,
    required this.deleteBackground,
    required this.foreground,
    required this.textStyle,
    required this.deleteIconSize,
    required this.deleteIconColor,
  });

  @override
  Widget build(BuildContext context) {
    const keys = <String>[
      '1','2','3',
      '4','5','6',
      '7','8','9',
      '',
      '0',
      'delete',
    ];

    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        mainAxisExtent: cellHeight,
        mainAxisSpacing: gap,
        crossAxisSpacing: gap,
      ),
      itemCount: keys.length,
      itemBuilder: (context, index) {
        final key = keys[index];
        if (key.isEmpty) return const SizedBox.shrink();

        final isDelete = key == 'delete';
        final isEnabled = isDelete || enabledKeys == null || enabledKeys!.contains(key);

        return Opacity(
          opacity: isEnabled ? 1.0 : 0.3,
          child: ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: isDelete ? deleteBackground : background,
              foregroundColor: foreground,
              elevation: 0,
              padding: EdgeInsets.zero, // вњ… С‡С‚РѕР±С‹ РёРєРѕРЅРєР° РЅРµ вЂњРІРёСЃРµР»Р°вЂќ
              minimumSize: const Size(double.infinity, double.infinity), // вњ… Р·Р°РїРѕР»РЅРёС‚СЊ СЏС‡РµР№РєСѓ
              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(radius)),
            ),
            onPressed: isEnabled ? () => isDelete ? onDeletePressed() : onKeyPressed(key) : null,
            child: Center(
              child: isDelete
                  ? Icon(
                Icons.backspace_outlined,
                size: deleteIconSize,
                color: deleteIconColor,
              )
                  : Text(key, style: textStyle),
            ),
          ),
        );
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get_it/get_it.dart';
import 'package:intl/intl.dart';

import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';

import '../../../../core/theme/app_theme.dart';
import '../../../../core/theme/scale.dart';
import '../../../../core/utils/app_strings.dart';
import '../../../core/utils/input_field.dart';
import 'bloc/add_record_bloc.dart';
import 'bloc/add_record_event.dart';
import 'bloc/add_record_state.dart';
import 'widgets/custom_keypad.dart';

class TagPreset {
  final String label;
  final String iconAsset;

  const TagPreset(this.label, this.iconAsset);
}

class AddRecordScreen extends StatelessWidget {
  static const List<TagPreset> presetTags = [
    TagPreset('РџРѕСЃР»Рµ РєРѕС„Рµ', 'assets/icons/tags/coffee.svg'),
    TagPreset('РђР»РєРѕРіРѕР»СЊ', 'assets/icons/tags/alcohol.svg'),
    TagPreset('РџРѕСЃР»Рµ РµРґС‹', 'assets/icons/tags/hamburger.svg'),
    TagPreset('РџРѕСЃР»Рµ РїСЂРѕРіСѓР»РєРё', 'assets/icons/tags/walk.svg'),
    TagPreset('РџРѕСЃР»Рµ С‚СЂРµРЅРёСЂРѕРІРєРё', 'assets/icons/tags/training.svg'),
    TagPreset('РЎС‚СЂРµСЃСЃ', 'assets/icons/tags/stress.svg'),
    TagPreset('РџР»РѕС…РѕР№ СЃРѕРЅ', 'assets/icons/tags/sleep.svg'),
    TagPreset('Р“РѕР»РѕРІРЅР°СЏ Р±РѕР»СЊ', 'assets/icons/tags/headache.svg'),
    TagPreset('РџСЂРёРЅСЏР» Р»РµРєР°СЂСЃС‚РІРѕ', 'assets/icons/tags/meds.svg'),
    TagPreset('РџСЂРѕРїСѓСЃС‚РёР» РїСЂРёС‘Рј', 'assets/icons/tags/missed_meds.svg'),
  ];

  final BloodPressureRecord? record;

  const AddRecordScreen({super.key, this.record});

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) {
        final bloc = GetIt.I<AddRecordBloc>();
        if (record != null) {
          bloc.add(EditStarted(record!));
        }
        return bloc;
      },
      child: _AddRecordView(isEditing: record != null),
    );
  }
}

class _AddRecordView extends StatefulWidget {
  final bool isEditing;

  const _AddRecordView({required this.isEditing});

  @override
  State<_AddRecordView> createState() => _AddRecordViewState();
}

class _AddRecordViewState extends State<_AddRecordView> {
  final TextEditingController _noteController = TextEditingController();
  final FocusNode _noteFocusNode = FocusNode();

  String? _selectedEmoji;

  @override
  void initState() {
    super.initState();
    _noteFocusNode.addListener(() {
      if (_noteFocusNode.hasFocus) {
        context.read<AddRecordBloc>().add(const FieldChanged(InputField.none));
      }
    });
  }

  @override
  void dispose() {
    _noteController.dispose();
    _noteFocusNode.dispose();
    super.dispose();
  }

  void _appendEmojiToNote(String emoji) {
    final controller = _noteController;

    final text = controller.text;
    final selection = controller.selection;

    final start = selection.isValid ? selection.start : text.length;
    final end = selection.isValid ? selection.end : text.length;

    final newText = text.replaceRange(start, end, emoji);
    controller.value = TextEditingValue(
      text: newText,
      selection: TextSelection.collapsed(offset: start + emoji.length),
    );

    context.read<AddRecordBloc>().add(NoteChanged(newText));
  }

  Future<void> _pickTime(BuildContext context, DateTime current) async {
    final picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(current),
      helpText: AppStrings.pickTime,
    );
    if (picked == null || !context.mounted) return;

    final merged = DateTime(
      current.year,
      current.month,
      current.day,
      picked.hour,
      picked.minute,
    );
    context.read<AddRecordBloc>().add(DateTimeSet(merged));
  }

  Future<void> _pickDate(BuildContext context, DateTime current) async {
    final picked = await showDatePicker(
      context: context,
      initialDate: current,
      firstDate: DateTime(current.year - 1),
      lastDate: DateTime(current.year + 1),
      helpText: AppStrings.pickDate,
    );
    if (picked == null || !context.mounted) return;

    final merged = DateTime(
      picked.year,
      picked.month,
      picked.day,
      current.hour,
      current.minute,
    );
    context.read<AddRecordBloc>().add(DateTimeSet(merged));
  }

  Future<void> _confirmDelete(BuildContext context) async {
    final colors = context.appColors;
    final ok = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text(AppStrings.deleteRecordQ),
        content: const Text(AppStrings.cannotUndo),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(AppStrings.cancel, style: TextStyle(color: colors.brandStrong)),
          ),
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            child: Text(AppStrings.delete, style: TextStyle(color: colors.danger)),
          ),
        ],
      ),
    );

    if (ok == true && context.mounted) {
      context.read<AddRecordBloc>().add(DeleteSubmitted());
    }
  }

  double _bottomInset(BuildContext context) {
    final space = context.appSpace;

    final safeBottom = MediaQuery.paddingOf(context).bottom;
    final keyboard = MediaQuery.viewInsetsOf(context).bottom;

    // Bottom bar in AppNavigation: barH (69) + lift (43) в‰€ 112, РїР»СЋСЃ safeBottom.
    final barH = dp(context, space.s72 - space.s2 - space.s1);
    final outer = dp(context, space.s80 + space.s6);
    final lift = outer / 2;

    return dp(context, space.s96) + barH + lift + safeBottom + dp(context, space.s12) + keyboard;
  }

  Widget _threeColGridSpan23({
    required BuildContext context,
    required double gap,
    required Widget col1,
    required Widget span23,
  }) {
    return LayoutBuilder(
      builder: (ctx, c) {
        final w = c.maxWidth;
        final colW = (w - 2 * gap) / 3;
        final spanW = colW * 2 + gap;

        return Row(
          children: [
            SizedBox(width: colW, child: col1),
            SizedBox(width: gap),
            SizedBox(width: spanW, child: span23),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.appColors;
    final space = context.appSpace;
    final radii = context.appRadii;
    final shadows = context.appShadow;
    final txt = context.appText;

    final isDark = Theme.of(context).brightness == Brightness.dark;

    // С„РёРєСЃРёСЂРѕРІР°РЅРЅС‹Р№ РІРЅРµС€РЅРёР№ РіРѕСЂРёР·РѕРЅС‚Р°Р»СЊРЅС‹Р№ РїР°РґРґРёРЅРі (СЌС‚Р°Р»РѕРЅ)
    final side = dp(context, space.s20);

    final topInset = MediaQuery.paddingOf(context).top;
    final headerH = dp(context, space.s128);

    final pillH = dp(context, space.s48);
    final pillR = dp(context, radii.r10);

    final commentH = dp(context, space.s72);

    final emojiSize = dp(context, space.s24);

    final gap20 = dp(context, space.s20);
    final gap16 = dp(context, space.s16);
    final gap12 = dp(context, space.s12);
    final gap10 = dp(context, space.s10);

    final headerBg = isDark ? AppPalette.dark800 : AppPalette.blue700;
    final surface = isDark ? AppPalette.dark700 : colors.surface;

    final screenH = MediaQuery.sizeOf(context).height;
    final isSmallScreen = screenH < 700;
    final keypadCellH = isSmallScreen ? (pillH - dp(context, space.s6)) : pillH;
    final keypadGap = isSmallScreen ? dp(context, space.s12) : dp(context, space.s16);
    final keypadBg = isDark ? AppPalette.dark800 : surface;

    final hint = isDark ? AppPalette.dark350 : AppPalette.grey500;
    final value = isDark ? AppPalette.dark400 : AppPalette.blue900;
    final chevron = isDark ? AppPalette.dark350 : AppPalette.grey500;

    final titleStyle = TextStyle(
      fontFamily: txt.family,
      fontSize: sp(context, txt.fs24),
      fontWeight: txt.w700,
      color: colors.textOnBrand,
      height: 1.0,
    );

    final pillValueStyleBold = TextStyle(
      fontFamily: txt.family,
      fontSize: sp(context, txt.fs18),
      fontWeight: txt.w600,
      color: value,
      height: 1.0,
    );

    final pillValueStyleRegular = TextStyle(
      fontFamily: txt.family,
      fontSize: sp(context, txt.fs18),
      fontWeight: txt.w400,
      color: value,
      height: 1.0,
    );

    final pillHintStyle = TextStyle(
      fontFamily: txt.family,
      fontSize: sp(context, txt.fs16),
      fontWeight: txt.w500,
      color: hint,
      height: 1.0,
    );

    final commentStyle = TextStyle(
      fontFamily: txt.family,
      fontSize: sp(context, txt.fs16),
      fontWeight: txt.w400,
      color: value,
      height: 1.0,
    );

    final commentHintStyle = TextStyle(
      fontFamily: txt.family,
      fontSize: sp(context, txt.fs16),
      fontWeight: txt.w500,
      color: hint,
      height: 1.0,
    );

    final focusBorderColor = isDark ? AppPalette.blue500 : AppPalette.blue500;
    final focusBorderW = dp(context, space.s1);

    return BlocListener<AddRecordBloc, AddRecordState>(
      listenWhen: (prev, curr) => curr.isSaved,
      listener: (context, state) => Navigator.pop(context),
      child: Scaffold(
        backgroundColor: colors.background,
        body: BlocBuilder<AddRecordBloc, AddRecordState>(
          builder: (context, state) {
            final dt = state.selectedDateTime;
            final showKeypad = state.activeField != InputField.none;

            if (_noteController.text != state.note) {
              _noteController.value = TextEditingValue(
                text: state.note,
                selection: TextSelection.collapsed(offset: state.note.length),
              );
            }

            return Column(
              children: [
                Container(
                  height: headerH + topInset,
                  width: double.infinity,
                  color: headerBg,
                  padding: EdgeInsets.only(
                    left: side,
                    right: side,
                    top: topInset + gap12,
                    bottom: gap12,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      SizedBox(height: gap10),
                      Row(
                        children: [
                          _HeaderIconButton(icon: Icons.close, onTap: () => Navigator.of(context).pop()),
                          const Spacer(),
                          if (widget.isEditing)
                            _HeaderIconButton(icon: Icons.delete_outline, onTap: () => _confirmDelete(context)),
                        ],
                      ),
                      SizedBox(height: gap12),
                      Text(
                        AppStrings.newRecord,
                        style: titleStyle,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                ),

                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.only(
                      left: side,
                      right: side,
                      top: gap20,
                      bottom: _bottomInset(context),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        // SYS / DIA / Pulse вЂ” 3 СЂР°РІРЅС‹С… РїРѕР»СЏ РІ СЂСЏРґ (СЌС‚Р°Р»РѕРЅ)
                        Row(
                          children: [
                            Expanded(
                              child: _InputPill(
                                height: pillH,
                                radius: pillR,
                                bg: surface,
                                shadow: shadows.card,
                                text: state.systolic.isEmpty ? AppStrings.systolicShort : state.systolic,
                                textStyle: state.systolic.isEmpty ? pillHintStyle : pillValueStyleBold,
                                isFocused: state.activeField == InputField.systolic,
                                focusBorderColor: focusBorderColor,
                                focusBorderWidth: focusBorderW,
                                onTap: () => context.read<AddRecordBloc>().add(const FieldChanged(InputField.systolic)),
                              ),
                            ),
                            SizedBox(width: gap16),
                            Expanded(
                              child: _InputPill(
                                height: pillH,
                                radius: pillR,
                                bg: surface,
                                shadow: shadows.card,
                                text: state.diastolic.isEmpty ? AppStrings.diastolicShort : state.diastolic,
                                textStyle: state.diastolic.isEmpty ? pillHintStyle : pillValueStyleBold,
                                isFocused: state.activeField == InputField.diastolic,
                                focusBorderColor: focusBorderColor,
                                focusBorderWidth: focusBorderW,
                                onTap: () => context.read<AddRecordBloc>().add(const FieldChanged(InputField.diastolic)),
                              ),
                            ),
                            SizedBox(width: gap16),
                            Expanded(
                              child: _InputPill(
                                height: pillH,
                                radius: pillR,
                                bg: surface,
                                shadow: shadows.card,
                                text: state.pulse.isEmpty ? AppStrings.pulse : state.pulse,
                                textStyle: state.pulse.isEmpty ? pillHintStyle : pillValueStyleBold,
                                isFocused: state.activeField == InputField.pulse,
                                focusBorderColor: focusBorderColor,
                                focusBorderWidth: focusBorderW,
                                onTap: () => context.read<AddRecordBloc>().add(const FieldChanged(InputField.pulse)),
                              ),
                            ),
                          ],
                        ),

                        SizedBox(height: gap20),

                        // Р’СЂРµРјСЏ (РєР°Рє SYS) + Р”Р°С‚Р° (РѕСЃС‚Р°С‚РѕРє РґРѕ РїСЂР°РІРѕРіРѕ РѕС‚СЃС‚СѓРїР°)
                        _threeColGridSpan23(
                          context: context,
                          gap: gap16,
                          col1: _ChevronPill(
                            height: pillH,
                            radius: pillR,
                            bg: surface,
                            text: DateFormat('HH:mm').format(dt),
                            textStyle: pillValueStyleRegular,
                            chevronColor: chevron,
                            shadow: shadows.card,
                            onTap: () => _pickTime(context, dt),
                          ),
                          span23: _ChevronPill(
                            height: pillH,
                            radius: pillR,
                            bg: surface,
                            text: DateFormat('dd MMMM yyyy', 'ru').format(dt),
                            textStyle: pillValueStyleRegular,
                            chevronColor: chevron,
                            shadow: shadows.card,
                            onTap: () => _pickDate(context, dt),
                          ),
                        ),

                        SizedBox(height: gap20),

                        // РљРѕРјРјРµРЅС‚Р°СЂРёР№ вЂ” РЅР° РІСЃСЋ С€РёСЂРёРЅСѓ РјРёРЅСѓСЃ РєСЂР°Р№РЅРёРµ РѕС‚СЃС‚СѓРїС‹
                        Container(
                          height: commentH,
                          decoration: BoxDecoration(
                            color: surface,
                            borderRadius: BorderRadius.circular(pillR),
                            boxShadow: [shadows.card],
                          ),
                          padding: EdgeInsets.fromLTRB(
                            dp(context, space.s14),
                            dp(context, space.s12),
                            dp(context, space.s14),
                            dp(context, space.s12),
                          ),
                          child: TextField(
                            controller: _noteController,
                            focusNode: _noteFocusNode,
                            expands: true,
                            minLines: null,
                            maxLines: null,
                            textAlignVertical: TextAlignVertical.top,
                            onChanged: (v) => context.read<AddRecordBloc>().add(NoteChanged(v)),
                            style: commentStyle,
                            decoration: InputDecoration.collapsed(
                              hintText: AppStrings.commentHint,
                              hintStyle: commentHintStyle,
                            ),
                          ),
                        ),

                        SizedBox(height: gap16),

                        // РўРµРіРё вЂ” РїРѕ С‚РѕР№ Р¶Рµ С€РёСЂРёРЅРµ, РІС‹СЂР°РІРЅРёРІР°РЅРёРµ РїРѕ РїСЂР°РІРѕРјСѓ РєСЂР°СЋ РІРЅСѓС‚СЂРё СЃС‚СЂРѕРєРё
                        _TagsDisclosureRow(
                          isExpanded: state.isTagsExpanded,
                          selectedCount: state.tags.length,
                          onTap: () => context.read<AddRecordBloc>().add(TagsExpandedToggled()),
                          textStyle: pillValueStyleRegular,
                        ),

                        if (state.isTagsExpanded) ...[
                          SizedBox(height: dp(context, space.s8)),
                          Wrap(
                            spacing: dp(context, space.s8),
                            runSpacing: dp(context, space.s8),
                            alignment: WrapAlignment.end,
                            children: [
                              for (final tag in AddRecordScreen.presetTags)
                                FilterChip(
                                  selected: state.tags.contains(tag.label),
                                  label: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      SvgPicture.asset(
                                        tag.iconAsset,
                                        width: dp(context, space.s16),
                                        height: dp(context, space.s16),
                                      ),
                                      SizedBox(width: dp(context, space.s6)),
                                      Text(tag.label, style: pillValueStyleRegular),
                                    ],
                                  ),
                                  onSelected: (_) => context.read<AddRecordBloc>().add(TagToggled(tag.label)),
                                  backgroundColor: surface,
                                ),
                            ],
                          ),
                        ],

                        SizedBox(height: gap16),

                        // РЎРѕС…СЂР°РЅРёС‚СЊ вЂ” С€РёСЂРёРЅР° РєР°Рє РїРѕР»Рµ Р”Р°С‚С‹ (2/3), РІС‹СЂРѕРІРЅРµРЅРѕ РІРїСЂР°РІРѕ С‚РѕР№ Р¶Рµ СЃС‚СЂСѓРєС‚СѓСЂРѕР№
                        _threeColGridSpan23(
                          context: context,
                          gap: gap16,
                          col1: const SizedBox.shrink(),
                          span23: SizedBox(
                            height: pillH,
                            child: ElevatedButton(
                              onPressed: state.isValid ? () => context.read<AddRecordBloc>().add(SaveSubmitted()) : null,
                              style: ElevatedButton.styleFrom(
                                elevation: 0,
                                backgroundColor: isDark ? AppPalette.dark800 : colors.brandStrong,
                                disabledBackgroundColor: isDark ? AppPalette.dark700 : AppPalette.grey400,
                                foregroundColor: colors.textOnBrand,
                                disabledForegroundColor: hint,
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(pillR)),
                              ),
                              child: Text(
                                AppStrings.save,
                                style: TextStyle(
                                  fontFamily: txt.family,
                                  fontSize: sp(context, txt.fs20),
                                  fontWeight: txt.w700,
                                  height: 1.0,
                                ),
                              ),
                            ),
                          ),
                        ),

                        if (showKeypad) ...[
                          SizedBox(height: gap20),
                          CustomKeypad(
                            enabledKeys: state.enabledKeys,
                            onKeyPressed: (v) => context.read<AddRecordBloc>().add(NumberPressed(v)),
                            onDeletePressed: () => context.read<AddRecordBloc>().add(BackspacePressed()),
                            horizontalPadding: 0,
                            gap: keypadGap,
                            cellHeight: keypadCellH,
                            radius: dp(context, radii.r10),
                            background: keypadBg,
                            deleteBackground: keypadBg,
                            foreground: value,
                            textStyle: TextStyle(
                              fontFamily: txt.family,
                              fontSize: sp(context, txt.fs20),
                              fontWeight: txt.w400,
                              height: 1.0,
                              color: value,
                            ),
                            deleteIconSize: dp(context, space.s20),
                            deleteIconColor: value,
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}

class _HeaderIconButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;

  const _HeaderIconButton({required this.icon, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final colors = context.appColors;
    final space = context.appSpace;

    final size = dp(context, space.s24);
    return SizedBox(
      width: size,
      height: size,
      child: IconButton(
        padding: EdgeInsets.zero,
        constraints: const BoxConstraints(),
        icon: Icon(icon, color: colors.textOnBrand, size: size),
        onPressed: onTap,
      ),
    );
  }
}

class _InputPill extends StatelessWidget {
  final double height;
  final double radius;
  final Color bg;
  final BoxShadow shadow;
  final String text;
  final TextStyle textStyle;

  final bool isFocused;
  final Color focusBorderColor;
  final double focusBorderWidth;

  final VoidCallback onTap;

  const _InputPill({
    required this.height,
    required this.radius,
    required this.bg,
    required this.shadow,
    required this.text,
    required this.textStyle,
    required this.isFocused,
    required this.focusBorderColor,
    required this.focusBorderWidth,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      behavior: HitTestBehavior.opaque,
      child: SizedBox(
        height: height,
        child: Container(
          decoration: BoxDecoration(
            color: bg,
            borderRadius: BorderRadius.circular(radius),
            boxShadow: [shadow],
            border: isFocused ? Border.all(color: focusBorderColor, width: focusBorderWidth) : null,
          ),
          alignment: Alignment.center,
          child: Text(text, style: textStyle, maxLines: 1, overflow: TextOverflow.ellipsis),
        ),
      ),
    );
  }
}

class _ChevronPill extends StatelessWidget {
  final double height;
  final double radius;
  final Color bg;
  final String text;
  final TextStyle textStyle;
  final Color chevronColor;
  final BoxShadow shadow;
  final VoidCallback onTap;

  const _ChevronPill({
    required this.height,
    required this.radius,
    required this.bg,
    required this.text,
    required this.textStyle,
    required this.chevronColor,
    required this.shadow,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final space = context.appSpace;

    return GestureDetector(
      onTap: onTap,
      behavior: HitTestBehavior.opaque,
      child: SizedBox(
        height: height,
        child: Container(
          decoration: BoxDecoration(
            color: bg,
            borderRadius: BorderRadius.circular(radius),
            boxShadow: [shadow],
          ),
          padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
          child: Row(
            children: [
              Expanded(child: Text(text, style: textStyle, maxLines: 1, overflow: TextOverflow.ellipsis)),
              Icon(Icons.arrow_drop_down, color: chevronColor, size: dp(context, space.s24)),
            ],
          ),
        ),
      ),
    );
  }
}

class _EmojiButton extends StatelessWidget {
  final String emoji;
  final double size;
  final bool isSelected;
  final VoidCallback onTap;

  const _EmojiButton({
    required this.emoji,
    required this.size,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.appColors;
    final radii = context.appRadii;

    return GestureDetector(
      onTap: onTap,
      behavior: HitTestBehavior.opaque,
      child: Container(
        width: size,
        height: size,
        decoration: isSelected
            ? BoxDecoration(
          color: colors.shadow.withValues(alpha: 0.10),
          borderRadius: BorderRadius.circular(dp(context, radii.r10)),
        )
            : null,
        alignment: Alignment.center,
        child: Text(
          emoji,
          style: TextStyle(
            fontSize: size,
            height: 1.0,
          ),
        ),
      ),
    );
  }
}

class _TagsDisclosureRow extends StatelessWidget {
  final bool isExpanded;
  final int selectedCount;
  final VoidCallback onTap;

  /// РЎС‚РёР»СЊ С‚РµРєСЃС‚Р° вЂ” РїРѕРґР°С‘Рј СЃРЅР°СЂСѓР¶Рё, С‡С‚РѕР±С‹ СЃРѕРІРїР°РґР°Р» СЃ С‡РёРїР°РјРё С‚РµРіРѕРІ.
  final TextStyle textStyle;

  const _TagsDisclosureRow({
    required this.isExpanded,
    required this.selectedCount,
    required this.onTap,
    required this.textStyle,
  });

  @override
  Widget build(BuildContext context) {
    final space = context.appSpace;

    final label = selectedCount == 0 ? 'РўРµРіРё' : 'РўРµРіРё ($selectedCount)';

    return GestureDetector(
      onTap: onTap,
      behavior: HitTestBehavior.opaque,
      child: Padding(
        padding: EdgeInsets.symmetric(
          vertical: dp(context, space.s8),
          horizontal: dp(context, space.s12),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.max,
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            Text(label, style: textStyle),
            SizedBox(width: dp(context, space.s10)),
            Text(isExpanded ? 'вЂ“' : '+', style: textStyle),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:isar/isar.dart';

import 'package:blood_pressure_diary/core/utils/pressure_assessment_policy.dart';

part 'blood_pressure_model.g.dart';

@Collection()
class BloodPressureRecord {
  Id id = Isar.autoIncrement;

  @Index()
  late DateTime dateTime;
  late int systolic;
  late int diastolic;
  late int pulse;

  String? note;    // РџРѕР»Рµ РґР»СЏ Р·Р°РјРµС‚РѕРє (Р±С‹РІС€РёР№ comment)
  String? emotion; // РўРІРѕР№ СЌРјРѕРґР·Рё
  List<String> tags = const []; // РљРѕРЅС‚РµРєСЃС‚РЅС‹Рµ С‚РµРіРё (РїРѕСЃР»Рµ РєРѕС„Рµ, СЃС‚СЂРµСЃСЃ Рё С‚.Рї.)

  @ignore
  Color get statusColor {
    final category = PressureAssessmentPolicy.assess(systolic, diastolic);
    switch (category) {
      case PressureCategory.low:
        return const Color(0xFF60A5FA); // РіРѕР»СѓР±РѕР№
      case PressureCategory.normal:
        return const Color(0xFF22C55E); // Р·РµР»С‘РЅС‹Р№
      case PressureCategory.elevated:
        return const Color(0xFFFACC15); // Р¶РµР»С‚С‹Р№
      case PressureCategory.high1:
      case PressureCategory.high2:
      case PressureCategory.crisis:
        return const Color(0xFFE11D48); // РєСЂР°СЃРЅС‹Р№
    }
  }

  @ignore
  String get statusText {
    final category = PressureAssessmentPolicy.assess(systolic, diastolic);
    switch (category) {
      case PressureCategory.low:
        return 'РџРѕРЅРёР¶РµРЅРѕ';
      case PressureCategory.normal:
        return 'РќРѕСЂРјР°';
      case PressureCategory.elevated:
        return 'РџРѕРІС‹С€РµРЅРѕ';
      case PressureCategory.high1:
        return 'Р“РёРїРµСЂС‚РѕРЅРёСЏ 1';
      case PressureCategory.high2:
        return 'Р“РёРїРµСЂС‚РѕРЅРёСЏ 2';
      case PressureCategory.crisis:
        return 'РљСЂРёР·РёСЃ';
    }
  }
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'blood_pressure_model.dart';

// **************************************************************************
// IsarCollectionGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: duplicate_ignore, non_constant_identifier_names, constant_identifier_names, invalid_use_of_protected_member, unnecessary_cast, prefer_const_constructors, lines_longer_than_80_chars, require_trailing_commas, inference_failure_on_function_invocation, unnecessary_parenthesis, unnecessary_raw_strings, unnecessary_null_checks, join_return_with_assignment, prefer_final_locals, avoid_js_rounded_ints, avoid_positional_boolean_parameters, always_specify_types

extension GetBloodPressureRecordCollection on Isar {
  IsarCollection<BloodPressureRecord> get bloodPressureRecords =>
      this.collection();
}

const BloodPressureRecordSchema = CollectionSchema(
  name: r'BloodPressureRecord',
  id: -3447328812780924616,
  properties: {
    r'dateTime': PropertySchema(
      id: 0,
      name: r'dateTime',
      type: IsarType.dateTime,
    ),
    r'diastolic': PropertySchema(
      id: 1,
      name: r'diastolic',
      type: IsarType.long,
    ),
    r'emotion': PropertySchema(
      id: 2,
      name: r'emotion',
      type: IsarType.string,
    ),
    r'note': PropertySchema(
      id: 3,
      name: r'note',
      type: IsarType.string,
    ),
    r'pulse': PropertySchema(
      id: 4,
      name: r'pulse',
      type: IsarType.long,
    ),
    r'systolic': PropertySchema(
      id: 5,
      name: r'systolic',
      type: IsarType.long,
    ),
    r'tags': PropertySchema(
      id: 6,
      name: r'tags',
      type: IsarType.stringList,
    )
  },
  estimateSize: _bloodPressureRecordEstimateSize,
  serialize: _bloodPressureRecordSerialize,
  deserialize: _bloodPressureRecordDeserialize,
  deserializeProp: _bloodPressureRecordDeserializeProp,
  idName: r'id',
  indexes: {
    r'dateTime': IndexSchema(
      id: -138851979697481250,
      name: r'dateTime',
      unique: false,
      replace: false,
      properties: [
        IndexPropertySchema(
          name: r'dateTime',
          type: IndexType.value,
          caseSensitive: false,
        )
      ],
    )
  },
  links: {},
  embeddedSchemas: {},
  getId: _bloodPressureRecordGetId,
  getLinks: _bloodPressureRecordGetLinks,
  attach: _bloodPressureRecordAttach,
  version: '3.1.0+1',
);

int _bloodPressureRecordEstimateSize(
  BloodPressureRecord object,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  var bytesCount = offsets.last;
  {
    final value = object.emotion;
    if (value != null) {
      bytesCount += 3 + value.length * 3;
    }
  }
  {
    final value = object.note;
    if (value != null) {
      bytesCount += 3 + value.length * 3;
    }
  }
  bytesCount += 3 + object.tags.length * 3;
  {
    for (var i = 0; i < object.tags.length; i++) {
      final value = object.tags[i];
      bytesCount += value.length * 3;
    }
  }
  return bytesCount;
}

void _bloodPressureRecordSerialize(
  BloodPressureRecord object,
  IsarWriter writer,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  writer.writeDateTime(offsets[0], object.dateTime);
  writer.writeLong(offsets[1], object.diastolic);
  writer.writeString(offsets[2], object.emotion);
  writer.writeString(offsets[3], object.note);
  writer.writeLong(offsets[4], object.pulse);
  writer.writeLong(offsets[5], object.systolic);
  writer.writeStringList(offsets[6], object.tags);
}

BloodPressureRecord _bloodPressureRecordDeserialize(
  Id id,
  IsarReader reader,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  final object = BloodPressureRecord();
  object.dateTime = reader.readDateTime(offsets[0]);
  object.diastolic = reader.readLong(offsets[1]);
  object.emotion = reader.readStringOrNull(offsets[2]);
  object.id = id;
  object.note = reader.readStringOrNull(offsets[3]);
  object.pulse = reader.readLong(offsets[4]);
  object.systolic = reader.readLong(offsets[5]);
  object.tags = reader.readStringList(offsets[6]) ?? [];
  return object;
}

P _bloodPressureRecordDeserializeProp<P>(
  IsarReader reader,
  int propertyId,
  int offset,
  Map<Type, List<int>> allOffsets,
) {
  switch (propertyId) {
    case 0:
      return (reader.readDateTime(offset)) as P;
    case 1:
      return (reader.readLong(offset)) as P;
    case 2:
      return (reader.readStringOrNull(offset)) as P;
    case 3:
      return (reader.readStringOrNull(offset)) as P;
    case 4:
      return (reader.readLong(offset)) as P;
    case 5:
      return (reader.readLong(offset)) as P;
    case 6:
      return (reader.readStringList(offset) ?? []) as P;
    default:
      throw IsarError('Unknown property with id $propertyId');
  }
}

Id _bloodPressureRecordGetId(BloodPressureRecord object) {
  return object.id;
}

List<IsarLinkBase<dynamic>> _bloodPressureRecordGetLinks(
    BloodPressureRecord object) {
  return [];
}

void _bloodPressureRecordAttach(
    IsarCollection<dynamic> col, Id id, BloodPressureRecord object) {
  object.id = id;
}

extension BloodPressureRecordQueryWhereSort
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QWhere> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhere> anyId() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(const IdWhereClause.any());
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhere>
      anyDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        const IndexWhereClause.any(indexName: r'dateTime'),
      );
    });
  }
}

extension BloodPressureRecordQueryWhere
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QWhereClause> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: id,
        upper: id,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idNotEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            )
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            );
      } else {
        return query
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            )
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            );
      }
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idGreaterThan(Id id, {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.greaterThan(lower: id, includeLower: include),
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idLessThan(Id id, {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.lessThan(upper: id, includeUpper: include),
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      idBetween(
    Id lowerId,
    Id upperId, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: lowerId,
        includeLower: includeLower,
        upper: upperId,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeEqualTo(DateTime dateTime) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.equalTo(
        indexName: r'dateTime',
        value: [dateTime],
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeNotEqualTo(DateTime dateTime) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [],
              upper: [dateTime],
              includeUpper: false,
            ))
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [dateTime],
              includeLower: false,
              upper: [],
            ));
      } else {
        return query
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [dateTime],
              includeLower: false,
              upper: [],
            ))
            .addWhereClause(IndexWhereClause.between(
              indexName: r'dateTime',
              lower: [],
              upper: [dateTime],
              includeUpper: false,
            ));
      }
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeGreaterThan(
    DateTime dateTime, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.between(
        indexName: r'dateTime',
        lower: [dateTime],
        includeLower: include,
        upper: [],
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeLessThan(
    DateTime dateTime, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.between(
        indexName: r'dateTime',
        lower: [],
        upper: [dateTime],
        includeUpper: include,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterWhereClause>
      dateTimeBetween(
    DateTime lowerDateTime,
    DateTime upperDateTime, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IndexWhereClause.between(
        indexName: r'dateTime',
        lower: [lowerDateTime],
        includeLower: includeLower,
        upper: [upperDateTime],
        includeUpper: includeUpper,
      ));
    });
  }
}

extension BloodPressureRecordQueryFilter on QueryBuilder<BloodPressureRecord,
    BloodPressureRecord, QFilterCondition> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeEqualTo(DateTime value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'dateTime',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeGreaterThan(
    DateTime value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'dateTime',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeLessThan(
    DateTime value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'dateTime',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      dateTimeBetween(
    DateTime lower,
    DateTime upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'dateTime',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'diastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'diastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'diastolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      diastolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'diastolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNull(
        property: r'emotion',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsNotNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNotNull(
        property: r'emotion',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionEqualTo(
    String? value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionGreaterThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionLessThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionBetween(
    String? lower,
    String? upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'emotion',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'emotion',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'emotion',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'emotion',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      emotionIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'emotion',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idEqualTo(Id value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idGreaterThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idLessThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      idBetween(
    Id lower,
    Id upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'id',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNull(
        property: r'note',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsNotNull() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(const FilterCondition.isNotNull(
        property: r'note',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteEqualTo(
    String? value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteGreaterThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteLessThan(
    String? value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteBetween(
    String? lower,
    String? upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'note',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'note',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'note',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'note',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      noteIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'note',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'pulse',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'pulse',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'pulse',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      pulseBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'pulse',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicEqualTo(int value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'systolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicGreaterThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'systolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicLessThan(
    int value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'systolic',
        value: value,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      systolicBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'systolic',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'tags',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'tags',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'tags',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'tags',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'tags',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'tags',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'tags',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'tags',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'tags',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsElementIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'tags',
        value: '',
      ));
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsLengthEqualTo(int length) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'tags',
        length,
        true,
        length,
        true,
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'tags',
        0,
        true,
        0,
        true,
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'tags',
        0,
        false,
        999999,
        true,
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsLengthLessThan(
    int length, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'tags',
        0,
        true,
        length,
        include,
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsLengthGreaterThan(
    int length, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'tags',
        length,
        include,
        999999,
        true,
      );
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterFilterCondition>
      tagsLengthBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'tags',
        lower,
        includeLower,
        upper,
        includeUpper,
      );
    });
  }
}

extension BloodPressureRecordQueryObject on QueryBuilder<BloodPressureRecord,
    BloodPressureRecord, QFilterCondition> {}

extension BloodPressureRecordQueryLinks on QueryBuilder<BloodPressureRecord,
    BloodPressureRecord, QFilterCondition> {}

extension BloodPressureRecordQuerySortBy
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QSortBy> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDateTimeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByEmotion() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByEmotionDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByNote() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByNoteDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByPulse() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortByPulseDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortBySystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      sortBySystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.desc);
    });
  }
}

extension BloodPressureRecordQuerySortThenBy
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QSortThenBy> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDateTimeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'dateTime', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByDiastolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'diastolic', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByEmotion() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByEmotionDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'emotion', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenById() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByIdDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByNote() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByNoteDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'note', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByPulse() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenByPulseDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'pulse', Sort.desc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenBySystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.asc);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QAfterSortBy>
      thenBySystolicDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'systolic', Sort.desc);
    });
  }
}

extension BloodPressureRecordQueryWhereDistinct
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct> {
  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByDateTime() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'dateTime');
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByDiastolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'diastolic');
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByEmotion({bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'emotion', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByNote({bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'note', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByPulse() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'pulse');
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctBySystolic() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'systolic');
    });
  }

  QueryBuilder<BloodPressureRecord, BloodPressureRecord, QDistinct>
      distinctByTags() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'tags');
    });
  }
}

extension BloodPressureRecordQueryProperty
    on QueryBuilder<BloodPressureRecord, BloodPressureRecord, QQueryProperty> {
  QueryBuilder<BloodPressureRecord, int, QQueryOperations> idProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'id');
    });
  }

  QueryBuilder<BloodPressureRecord, DateTime, QQueryOperations>
      dateTimeProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'dateTime');
    });
  }

  QueryBuilder<BloodPressureRecord, int, QQueryOperations> diastolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'diastolic');
    });
  }

  QueryBuilder<BloodPressureRecord, String?, QQueryOperations>
      emotionProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'emotion');
    });
  }

  QueryBuilder<BloodPressureRecord, String?, QQueryOperations> noteProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'note');
    });
  }

  QueryBuilder<BloodPressureRecord, int, QQueryOperations> pulseProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'pulse');
    });
  }

  QueryBuilder<BloodPressureRecord, int, QQueryOperations> systolicProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'systolic');
    });
  }

  QueryBuilder<BloodPressureRecord, List<String>, QQueryOperations>
      tagsProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'tags');
    });
  }
}
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/repositories/pressure_repository.dart';
import '../../data/blood_pressure_model.dart';
import 'home_event.dart';
import 'home_state.dart';

class HomeBloc extends Bloc<HomeEvent, HomeState> {
  final PressureRepository _repository;

  HomeBloc(this._repository) : super(HomeLoading()) {
    on<LoadHomeData>(_onLoadData);
    add(LoadHomeData());
  }

  Future<void> _onLoadData(LoadHomeData event, Emitter<HomeState> emit) async {
    // РЇРІРЅРѕ С‚РёРїРёР·РёСЂСѓРµРј СЃС‚СЂРёРј, С‡С‚РѕР±С‹ РёР·Р±РµР¶Р°С‚СЊ РѕС€РёР±РєРё Object?
    await emit.forEach<List<BloodPressureRecord>>(
      _repository.getAllRecordsStream(),
      onData: (records) => HomeLoaded(records),
      onError: (error, stackTrace) => HomeError(error.toString()),
    );
  }
}
import 'package:equatable/equatable.dart';

abstract class HomeEvent extends Equatable {
  const HomeEvent();
  @override
  List<Object> get props => [];
}

class LoadHomeData extends HomeEvent {}
import 'package:equatable/equatable.dart';
import '../../data/blood_pressure_model.dart';

abstract class HomeState extends Equatable {
  const HomeState();
  @override
  List<Object> get props => [];
}

class HomeLoading extends HomeState {}

class HomeLoaded extends HomeState {
  final List<BloodPressureRecord> records;
  const HomeLoaded(this.records);

  @override
  List<Object> get props => [records];
}

class HomeError extends HomeState {
  final String message;
  const HomeError(this.message);
}
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../data/blood_pressure_model.dart';
import 'statistics_state.dart';

class StatisticsCubit extends Cubit<StatisticsState> {
  List<BloodPressureRecord> _allRecords;

  StatisticsCubit(
      List<BloodPressureRecord> records, {
        int targetSystolic = 120,
        int targetDiastolic = 80,
      })  : _allRecords = List<BloodPressureRecord>.from(records),
        super(StatisticsState(
        targetSystolic: targetSystolic,
        targetDiastolic: targetDiastolic,
      )) {
    updatePeriod(StatisticsPeriod.sevenDays);
  }

  /// вњ… РћР±РЅРѕРІРёС‚СЊ РёСЃС…РѕРґРЅС‹Рµ Р·Р°РїРёСЃРё (РЅР°РїСЂРёРјРµСЂ, РїРѕСЃР»Рµ СѓРґР°Р»РµРЅРёСЏ/РґРѕР±Р°РІР»РµРЅРёСЏ РІ Р¶СѓСЂРЅР°Р»Рµ)
  /// Рё РїРµСЂРµСЃС‡РёС‚Р°С‚СЊ С‚РµРєСѓС‰РёР№ РїРµСЂРёРѕРґ Р±РµР· РїРµСЂРµР·Р°РїСѓСЃРєР° РїСЂРёР»РѕР¶РµРЅРёСЏ.
  void updateRecords(List<BloodPressureRecord> records) {
    _allRecords = List<BloodPressureRecord>.from(records);
    updatePeriod(state.period);
  }

  void updatePeriod(StatisticsPeriod period) {
    final now = DateTime.now();
    List<BloodPressureRecord> filtered;

    switch (period) {
      case StatisticsPeriod.sevenDays:
        filtered = _allRecords
            .where((r) => r.dateTime.isAfter(now.subtract(const Duration(days: 7))))
            .toList();
        break;
      case StatisticsPeriod.thirtyDays:
        filtered = _allRecords
            .where((r) => r.dateTime.isAfter(now.subtract(const Duration(days: 30))))
            .toList();
        break;
      case StatisticsPeriod.all:
        filtered = List.from(_allRecords);
        break;
    }

    filtered.sort((a, b) => a.dateTime.compareTo(b.dateTime));

    // Thinning if records > 100
    if (filtered.length > 100) {
      final int skip = (filtered.length / 50).floor();
      final List<BloodPressureRecord> thinned = [];
      for (int i = 0; i < filtered.length; i++) {
        if (skip <= 1 || i % skip == 0 || i == filtered.length - 1) {
          thinned.add(filtered[i]);
        }
      }
      filtered = thinned;
    }

    _calculateAnalytics(filtered, period);
  }

  void _calculateAnalytics(List<BloodPressureRecord> records, StatisticsPeriod period) {
    if (records.isEmpty) {
      emit(state.copyWith(
        filteredRecords: const [],
        period: period,
        maxSys: 0,
        maxDia: 0,
        minSys: 0,
        minDia: 0,
        avgSys: 0,
        avgDia: 0,
        maxPulse: 0,
        minPulse: 0,
        avgPulse: 0,
      ));
      return;
    }

    double maxSys = 0;
    double maxDia = 0;
    double minSys = double.infinity;
    double minDia = double.infinity;
    double sumSys = 0;
    double sumDia = 0;

    // pulse analytics ignore invalid (<=0)
    double maxPulse = 0;
    double minPulse = double.infinity;
    double sumPulse = 0;
    int pulseCount = 0;

    for (final r in records) {
      if (r.systolic > maxSys) maxSys = r.systolic.toDouble();
      if (r.diastolic > maxDia) maxDia = r.diastolic.toDouble();
      if (r.systolic < minSys) minSys = r.systolic.toDouble();
      if (r.diastolic < minDia) minDia = r.diastolic.toDouble();
      sumSys += r.systolic;
      sumDia += r.diastolic;

      final p = r.pulse;
      if (p > 0) {
        if (p > maxPulse) maxPulse = p.toDouble();
        if (p < minPulse) minPulse = p.toDouble();
        sumPulse += p;
        pulseCount++;
      }
    }

    emit(state.copyWith(
      filteredRecords: records,
      period: period,
      maxSys: maxSys,
      maxDia: maxDia,
      minSys: minSys == double.infinity ? 0 : minSys,
      minDia: minDia == double.infinity ? 0 : minDia,
      avgSys: sumSys / records.length,
      avgDia: sumDia / records.length,
      maxPulse: maxPulse,
      minPulse: minPulse == double.infinity ? 0 : minPulse,
      avgPulse: pulseCount == 0 ? 0 : (sumPulse / pulseCount),
    ));
  }
}
import 'package:equatable/equatable.dart';
import '../../data/blood_pressure_model.dart';

enum StatisticsPeriod { sevenDays, thirtyDays, all }

class StatisticsState extends Equatable {
  final List<BloodPressureRecord> filteredRecords;
  final StatisticsPeriod period;

  final double maxSys;
  final double maxDia;
  final double minSys;
  final double minDia;
  final double avgSys;
  final double avgDia;

  // вњ… PULSE analytics
  final double maxPulse;
  final double minPulse;
  final double avgPulse;

  final int targetSystolic;
  final int targetDiastolic;

  const StatisticsState({
    this.filteredRecords = const [],
    this.period = StatisticsPeriod.sevenDays,
    this.maxSys = 0,
    this.maxDia = 0,
    this.minSys = 0,
    this.minDia = 0,
    this.avgSys = 0,
    this.avgDia = 0,
    this.maxPulse = 0,
    this.minPulse = 0,
    this.avgPulse = 0,
    this.targetSystolic = 120,
    this.targetDiastolic = 80,
  });

  StatisticsState copyWith({
    List<BloodPressureRecord>? filteredRecords,
    StatisticsPeriod? period,
    double? maxSys,
    double? maxDia,
    double? minSys,
    double? minDia,
    double? avgSys,
    double? avgDia,
    double? maxPulse,
    double? minPulse,
    double? avgPulse,
    int? targetSystolic,
    int? targetDiastolic,
  }) {
    return StatisticsState(
      filteredRecords: filteredRecords ?? this.filteredRecords,
      period: period ?? this.period,
      maxSys: maxSys ?? this.maxSys,
      maxDia: maxDia ?? this.maxDia,
      minSys: minSys ?? this.minSys,
      minDia: minDia ?? this.minDia,
      avgSys: avgSys ?? this.avgSys,
      avgDia: avgDia ?? this.avgDia,
      maxPulse: maxPulse ?? this.maxPulse,
      minPulse: minPulse ?? this.minPulse,
      avgPulse: avgPulse ?? this.avgPulse,
      targetSystolic: targetSystolic ?? this.targetSystolic,
      targetDiastolic: targetDiastolic ?? this.targetDiastolic,
    );
  }

  @override
  List<Object?> get props => [
    filteredRecords,
    period,
    maxSys,
    maxDia,
    minSys,
    minDia,
    avgSys,
    avgDia,
    maxPulse,
    minPulse,
    avgPulse,
    targetSystolic,
    targetDiastolic,
  ];
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';

import '../../../../core/theme/app_theme.dart';
import '../../../../core/theme/scale.dart';
import '../../../../core/utils/blood_pressure_color_utils.dart';
import '../../../profile/presentation/bloc/profile_cubit.dart';
import '../../../profile/presentation/bloc/profile_state.dart';
import '../../data/blood_pressure_model.dart';

class RecordListItem extends StatelessWidget {
  static const Map<String, String> _tagIconByLabel = {
    'РџРѕСЃР»Рµ РєРѕС„Рµ': 'assets/icons/tags/coffee.svg',
    'РџРѕСЃР»Рµ РµРґС‹': 'assets/icons/tags/hamburger.svg',
    'РџРѕСЃР»Рµ РїСЂРѕРіСѓР»РєРё': 'assets/icons/tags/walk.svg',
    'РџРѕСЃР»Рµ РЅР°РіСЂСѓР·РєРё/С‚СЂРµРЅРёСЂРѕРІРєРё': 'assets/icons/tags/training.svg',
    'РЎС‚СЂРµСЃСЃ': 'assets/icons/tags/stress.svg',
    'РџР»РѕС…РѕР№ СЃРѕРЅ': 'assets/icons/tags/sleep.svg',
    'РџСЂРёРЅСЏР» Р»РµРєР°СЂСЃС‚РІРѕ': 'assets/icons/tags/meds.svg',
    'РџСЂРѕРїСѓСЃС‚РёР» РїСЂРёС‘Рј': 'assets/icons/tags/missed_meds.svg',
    'РђР»РєРѕРіРѕР»СЊ': 'assets/icons/tags/alcohol.svg',
    'Р“РѕР»РѕРІРЅР°СЏ Р±РѕР»СЊ': 'assets/icons/tags/headache.svg',
  };

  final BloodPressureRecord record;
  final VoidCallback? onTap;

  const RecordListItem({
    super.key,
    required this.record,
    this.onTap,
  });

  String _hhmm(DateTime t) => DateFormat('HH:mm').format(t);

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;

    final profileState = context.watch<ProfileCubit>().state;
    int targetSys = 120;
    int targetDia = 80;
    if (profileState is ProfileLoaded) {
      targetSys = profileState.profile.targetSystolic;
      targetDia = profileState.profile.targetDiastolic;
    }

    final c = context.appColors;
    final s = context.appSpace;
    final r = context.appRadii;
    final sh = context.appShadow;
    final tx = context.appText;

    final timeW = dp(context, s.s56);
    final dotD = dp(context, s.s10 + s.s4 + s.s1); // 15
    final timeGap = dp(context, s.s8);
    final dotGap = dp(context, s.s12);

    final iconSize = dp(context, s.s22);
    final iconGap = dp(context, s.s6);
    final blockGap = dp(context, s.s8);

    final cardR = dp(context, r.r5);
    final padH = dp(context, s.s20);

    final note = (record.note ?? '').trim();
    final hasNote = note.isNotEmpty;

    final tags = record.tags;
    final hasTags = tags.isNotEmpty;

    final hasMeta = hasNote || hasTags;

    final rowH = dp(context, hasMeta ? s.s72 : s.s56);
    final padV = dp(context, hasMeta ? s.s8 : s.s10);

    final valueStyle = TextStyle(
      fontFamily: tx.family,
      fontSize: sp(context, tx.fs22),
      fontWeight: tx.w700,
      color: c.textPrimary,
      height: 1.0,
    );

    final timeStyle = TextStyle(
      fontFamily: tx.family,
      fontSize: sp(context, tx.fs16),
      fontWeight: tx.w400,
      color: c.textPrimary,
      height: 1.0,
    );

    final noteStyle = TextStyle(
      fontFamily: tx.family,
      fontSize: sp(context, tx.fs14),
      fontWeight: tx.w400,
      color: c.textSecondary,
      height: 1.0,
    );

    final cardBg = isDark ? AppPalette.dark700 : c.surface;
    final iconColor = c.iconPrimary.withValues(alpha: 0.75);

    final leftTopPad = dp(context, hasMeta ? s.s12 : s.s18);
    final dotTopPad = dp(context, hasMeta ? s.s12 : s.s20);

    final dotColor = BloodPressureColorUtils.getIndicatorColor(
      context,
      systolic: record.systolic,
      diastolic: record.diastolic,
      targetSystolic: targetSys,
      targetDiastolic: targetDia,
    );

    return SizedBox(
      height: rowH,
      child: InkWell(
        onTap: onTap,
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SizedBox(
              width: timeW,
              child: Padding(
                padding: EdgeInsets.only(top: leftTopPad),
                child: Text(_hhmm(record.dateTime), style: timeStyle),
              ),
            ),
            SizedBox(width: timeGap),
            Padding(
              padding: EdgeInsets.only(top: dotTopPad),
              child: Container(
                width: dotD,
                height: dotD,
                decoration: BoxDecoration(color: dotColor, shape: BoxShape.circle),
              ),
            ),
            SizedBox(width: dotGap),
            Expanded(
              child: Container(
                height: rowH,
                padding: EdgeInsets.symmetric(horizontal: padH, vertical: padV),
                decoration: BoxDecoration(
                  color: cardBg,
                  borderRadius: BorderRadius.circular(cardR),
                  boxShadow: [sh.card],
                ),
                child: hasMeta
                    ? Center(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _MainRow(
                        record: record,
                        valueStyle: valueStyle,
                        iconSize: iconSize,
                        iconGap: iconGap,
                        blockGap: blockGap,
                        iconColor: iconColor,
                      ),
                      SizedBox(height: dp(context, s.s8)),
                      _TagsMetaRow(
                        tags: tags,
                        note: note,
                        noteStyle: noteStyle,
                        iconColor: iconColor,
                        iconSize: dp(context, s.s14),
                        gap: dp(context, s.s6),
                      ),
                    ],
                  ),
                )
                    : Center(
                  child: _MainRow(
                    record: record,
                    valueStyle: valueStyle,
                    iconSize: iconSize,
                    iconGap: iconGap,
                    blockGap: blockGap,
                    iconColor: iconColor,
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


class _TagsMetaRow extends StatelessWidget {
  final List<String> tags;
  final String note;
  final TextStyle noteStyle;
  final Color iconColor;
  final double iconSize;
  final double gap;

  const _TagsMetaRow({
    required this.tags,
    required this.note,
    required this.noteStyle,
    required this.iconColor,
    required this.iconSize,
    required this.gap,
  });

  @override
  Widget build(BuildContext context) {
    final icons = <String>[];
    for (final t in tags) {
      final p = RecordListItem._tagIconByLabel[t];
      if (p != null) icons.add(p);
    }

    final showText = note.trim().isNotEmpty || tags.isEmpty;
    final text = note.trim().isNotEmpty ? note.trim() : tags.join(', ');

    return Row(
      children: [
        if (icons.isNotEmpty)
          Flexible(
            flex: 0,
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                for (final p in icons.take(4)) ...[
                  SvgPicture.asset(
                    p,
                    width: iconSize,
                    height: iconSize,
                  ),
                  SizedBox(width: gap),
                ],
              ],
            ),
          ),
        if (icons.isNotEmpty && showText) SizedBox(width: gap),
        if (showText)
          Expanded(
            child: Text(
              text,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              style: noteStyle,
            ),
          ),
      ],
    );
  }
}

class _MainRow extends StatelessWidget {
  final BloodPressureRecord record;
  final TextStyle valueStyle;
  final double iconSize;
  final double iconGap;
  final double blockGap;
  final Color iconColor;

  const _MainRow({
    required this.record,
    required this.valueStyle,
    required this.iconSize,
    required this.iconGap,
    required this.blockGap,
    required this.iconColor,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Flexible(
              child: Text(
                '${record.systolic}/${record.diastolic}',
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: valueStyle,
              ),
            ),
            SizedBox(width: iconGap),
            SvgPicture.asset(
              'assets/arrow-up-down.svg',
              width: iconSize,
              height: iconSize,
              colorFilter: ColorFilter.mode(iconColor, BlendMode.srcIn),
            ),
          ],
        ),
        SizedBox(width: blockGap),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('${record.pulse}', maxLines: 1, overflow: TextOverflow.ellipsis, style: valueStyle),
            SizedBox(width: iconGap),
            SvgPicture.asset(
              'assets/activity.svg',
              width: iconSize,
              height: iconSize,
              colorFilter: ColorFilter.mode(iconColor, BlendMode.srcIn),
            ),
          ],
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';

import '../../../../core/theme/app_theme.dart';
import '../../../../core/theme/scale.dart';
import '../../data/blood_pressure_model.dart';

class SummaryCard extends StatelessWidget {
  final BloodPressureRecord? record;

  const SummaryCard({super.key, this.record});

  String _hhmm(DateTime t) => DateFormat('HH:mm').format(t);

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;

    final colors = context.appColors;
    final space = context.appSpace;
    final radii = context.appRadii;
    final shadow = context.appShadow;
    final text = context.appText;

    final width = MediaQuery.sizeOf(context).width - dp(context, space.s20) * 2;
    final height = dp(context, space.s114); // С„РёРєСЃ РїРѕ РјР°РєРµС‚Сѓ
    final r = dp(context, radii.r10);

    final bg = isDark ? AppPalette.dark900 : AppPalette.blue600;
    final mainText = isDark ? AppPalette.dark400 : colors.textOnBrand;
    final checkColor = isDark ? AppPalette.dark600 : AppPalette.blue500;

    // вњ… СѓРІРµР»РёС‡РёР»Рё, РЅРѕ Р±РµР· СѓР±РёР№СЃС‚РІР° РІС‹СЃРѕС‚С‹
    final checkSize = dp(context, space.s40);

    final pressureStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs30),
      fontWeight: text.w600,
      color: mainText,
      height: 1.0,
    );

    final pulseStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs22),
      fontWeight: text.w600,
      color: mainText,
      height: 1.0,
    );

    final timeStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs22),
      fontWeight: text.w600,
      color: mainText,
      height: 1.0,
    );

    final clockColor = isDark ? AppPalette.dark600 : colors.textOnBrand;

    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(r),
        boxShadow: [shadow.card],
      ),
      // вњ… СѓРјРµРЅСЊС€Р°РµРј РІРµСЂС‚РёРєР°Р»СЊРЅС‹Рµ РїР°РґРґРёРЅРіРё
      padding: EdgeInsets.fromLTRB(
        dp(context, space.s16),
        dp(context, space.s6),
        dp(context, space.s16),
        dp(context, space.s6),
      ),
      child: (record == null)
          ? Center(
        child: Text(
          'РќРµС‚ РґР°РЅРЅС‹С…',
          style: TextStyle(
            fontFamily: text.family,
            fontSize: sp(context, text.fs16),
            fontWeight: text.w500,
            color: mainText,
            height: 1.0,
          ),
        ),
      )
          : Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 1) Р”Р°РІР»РµРЅРёРµ
          Text(
            '${record!.systolic}/${record!.diastolic}',
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
            style: pressureStyle,
          ),

          SizedBox(height: dp(context, space.s1)),

          // 2) РџСѓР»СЊСЃ + РіР°Р»РѕС‡РєР°
          Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: Row(
                  children: [
                    Text('${record!.pulse}', style: pulseStyle),
                    SizedBox(width: dp(context, space.s6)),
                    Text('СѓРґ/РјРёРЅ', style: pulseStyle),
                  ],
                ),
              ),
              SizedBox(
                width: checkSize,
                height: checkSize,
                child: Center(
                  child: SvgPicture.asset(
                    'assets/check.svg',
                    width: checkSize,
                    height: checkSize,
                    colorFilter: ColorFilter.mode(checkColor, BlendMode.srcIn),
                  ),
                ),
              ),
            ],
          ),

          // вњ… вЂњРѕРїСѓСЃС‚РёС‚СЊвЂќ РІСЂРµРјСЏ РІРёР·СѓР°Р»СЊРЅРѕ, РЅРѕ РЅРµ СЂР°Р·РґСѓРІР°С‚СЊ РІС‹СЃРѕС‚Сѓ
          Padding(
            padding: EdgeInsets.only(top: dp(context, space.s4)),
            child: Row(
              children: [
                SvgPicture.asset(
                  'assets/clock.svg',
                  width: dp(context, space.s20),
                  height: dp(context, space.s20),
                  colorFilter: ColorFilter.mode(clockColor, BlendMode.srcIn),
                ),
                SizedBox(width: dp(context, space.s6)),
                Text(_hhmm(record!.dateTime), style: timeStyle),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';

import '../../../../core/theme/app_theme.dart';
import '../../../../core/theme/scale.dart';
import '../../../../core/utils/app_strings.dart';
import '../data/blood_pressure_model.dart';
import 'bloc/home_bloc.dart';
import 'bloc/home_state.dart';
import 'widgets/summary_card.dart';
import 'widgets/record_list_item.dart';
import '../../add_record/presentation/add_record_screen.dart';

enum _FilterPeriod { today, week, month, all }

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  _FilterPeriod _period = _FilterPeriod.week;

  String _periodLabel(_FilterPeriod p) {
    switch (p) {
      case _FilterPeriod.today:
        return AppStrings.today;
      case _FilterPeriod.week:
        return AppStrings.week;
      case _FilterPeriod.month:
        return AppStrings.month;
      case _FilterPeriod.all:
        return AppStrings.allShort;
    }
  }

  String _recordsWord(int n) => AppStrings.recordsWord(n);

  List<BloodPressureRecord> _applyFilter(List<BloodPressureRecord> records) {
    final now = DateTime.now();
    switch (_period) {
      case _FilterPeriod.today:
        final d = DateTime(now.year, now.month, now.day);
        return records.where((r) {
          final rd = DateTime(r.dateTime.year, r.dateTime.month, r.dateTime.day);
          return rd == d;
        }).toList();
      case _FilterPeriod.week:
        final from = now.subtract(const Duration(days: 7));
        return records.where((r) => r.dateTime.isAfter(from)).toList();
      case _FilterPeriod.month:
        final from = now.subtract(const Duration(days: 30));
        return records.where((r) => r.dateTime.isAfter(from)).toList();
      case _FilterPeriod.all:
        return records;
    }
  }

  void _openEdit(BuildContext context, BloodPressureRecord record) {
    Navigator.push(context, MaterialPageRoute(builder: (_) => AddRecordScreen(record: record)));
  }

  double _bottomInset(BuildContext context) {
    // Bottom bar in AppNavigation: barH (69) + lift (43) в‰€ 112, РїР»СЋСЃ safeBottom.
    final space = context.appSpace;
    final safeBottom = MediaQuery.paddingOf(context).bottom;

    final barH = dp(context, space.s72 - space.s2 - space.s1);
    final outer = dp(context, space.s80 + space.s6);
    final lift = outer / 2;

    return barH + lift + safeBottom + dp(context, space.s12);
  }

  @override
  Widget build(BuildContext context) {
    final safeTop = MediaQuery.of(context).padding.top;
    final isDark = Theme.of(context).brightness == Brightness.dark;

    final colors = context.appColors;
    final space = context.appSpace;
    final radii = context.appRadii;
    final appText = context.appText;

    // Layout tokens
    final side = dp(context, space.s20);
    final blueH = dp(context, space.s160); // header blue
    final shelfH = dp(context, space.s80); // shelf
    final overlap = dp(context, space.s40 + space.s10); // 50
    final headerTop = safeTop + dp(context, space.s20);

    // Header colors (С‚РѕС‡РЅРѕ РєР°Рє РІ РјР°РєРµС‚Рµ РіР»Р°РІРЅРѕРіРѕ СЌРєСЂР°РЅР°)
    final headerBg = isDark ? AppPalette.dark800 : AppPalette.blue700;
    final shelfBg = isDark ? AppPalette.dark700 : AppPalette.grey050;

    // Divider 0.5px (С‡РµСЂРµР· s1/s2)
    final dividerH = dp(context, space.s1) / dp(context, space.s2);
    final shelfDivider = isDark ? Colors.transparent : colors.divider;

    // Р”РµР»РёРєР°С‚РЅР°СЏ С‚РµРЅСЊ Сѓ РїРѕР»РєРё: РјРµРЅСЊС€Рµ blur/offset, С‡РµРј вЂњРєР°СЂС‚РѕС‡РЅР°СЏвЂќ
    final shelfShadow = BoxShadow(
      offset: Offset(0, dp(context, space.s1)),
      blurRadius: dp(context, space.s4),
      color: colors.shadow,
    );

    // Chip
    final chipH = dp(context, space.s32);
    final chipR = dp(context, radii.r5);
    final chipHPad = dp(context, space.s10);
    final chipGap = dp(context, space.s4);
    final icon24 = dp(context, space.s24);

    final chipBg = isDark ? AppPalette.dark700 : AppPalette.blue500;
    final chipText = colors.textOnBrand;

    // Typography
    final titleStyle = TextStyle(
      fontFamily: appText.family,
      fontSize: sp(context, appText.fs26),
      fontWeight: appText.w600,
      color: colors.textOnBrand,
      height: 1.0,
    );

    final countStyle = TextStyle(
      fontFamily: appText.family,
      fontSize: sp(context, appText.fs16),
      fontWeight: appText.w500,
      color: isDark ? AppPalette.dark400 : AppPalette.blue300,
      height: 1.0,
    );

    final dateStyle = TextStyle(
      fontFamily: appText.family,
      fontSize: sp(context, appText.fs16),
      fontWeight: appText.w600,
      color: colors.textPrimary,
      height: 1.0,
    );

    final emptyStyle = TextStyle(
      fontFamily: appText.family,
      fontSize: sp(context, appText.fs16),
      fontWeight: appText.w600,
      color: colors.textPrimary,
      height: 1.0,
    );

    // вњ… РќРёР¶РЅРёР№ вЂњР·Р°РїР°СЃвЂќ РїРѕРґ РЅР°РІР±Р°СЂ + FAB + safeBottom (СѓСЃС‚РѕР№С‡РёРІРѕ РЅР° СЂР°Р·РЅС‹С… РґРµРІР°Р№СЃР°С…)
    final bottomListPadding = _bottomInset(context);

    return BlocBuilder<HomeBloc, HomeState>(
      builder: (context, state) {
        final all = state is HomeLoaded ? state.records : const <BloodPressureRecord>[];
        final records = _applyFilter(all)..sort((a, b) => b.dateTime.compareTo(a.dateTime));
        final filteredCount = records.length;

        final lastRecord = all.isNotEmpty
            ? (List<BloodPressureRecord>.from(all)..sort((a, b) => b.dateTime.compareTo(a.dateTime))).first
            : null;

        final groups = _groupByDate(records);

        final header = SizedBox(
          height: blueH + shelfH,
          child: Stack(
            clipBehavior: Clip.none,
            children: [
              Positioned.fill(child: ColoredBox(color: headerBg)),
              Positioned(
                left: 0,
                right: 0,
                top: blueH,
                height: shelfH,
                child: Container(
                  decoration: BoxDecoration(
                    color: shelfBg,
                    boxShadow: [shelfShadow],
                  ),
                  child: Align(
                    alignment: Alignment.bottomCenter,
                    child: SizedBox(
                      height: dividerH,
                      child: ColoredBox(color: shelfDivider),
                    ),
                  ),
                ),
              ),
              Positioned(
                left: side,
                right: side,
                top: headerTop,
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            AppStrings.myDiary,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: titleStyle,
                          ),
                          SizedBox(height: dp(context, space.s20)),
                          Text(
                            '$filteredCount ${_recordsWord(filteredCount)}',
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: countStyle,
                          ),
                        ],
                      ),
                    ),
                    PopupMenuButton<_FilterPeriod>(
                      onSelected: (value) => setState(() => _period = value),
                      itemBuilder: (context) => const [
                        PopupMenuItem(value: _FilterPeriod.today, child: Text(AppStrings.today)),
                        PopupMenuItem(value: _FilterPeriod.week, child: Text(AppStrings.week)),
                        PopupMenuItem(value: _FilterPeriod.month, child: Text(AppStrings.month)),
                        PopupMenuItem(value: _FilterPeriod.all, child: Text(AppStrings.allTime)),
                      ],
                      offset: Offset(0, dp(context, space.s30 - space.s2)), // 28
                      child: Container(
                        height: chipH,
                        padding: EdgeInsets.symmetric(horizontal: chipHPad),
                        decoration: BoxDecoration(
                          color: chipBg,
                          borderRadius: BorderRadius.circular(chipR),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              _periodLabel(_period),
                              style: TextStyle(
                                fontFamily: appText.family,
                                fontSize: sp(context, appText.fs16),
                                fontWeight: appText.w600,
                                color: chipText,
                                height: 1.0,
                              ),
                            ),
                            SizedBox(width: chipGap),
                            SvgPicture.asset(
                              'assets/arrow_drop_down.svg',
                              width: icon24,
                              height: icon24,
                              colorFilter: ColorFilter.mode(chipText, BlendMode.srcIn),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        );

        final list = CustomScrollView(
          slivers: [
            if (groups.isEmpty) ...[
              SliverToBoxAdapter(
                child: Padding(
                  padding: EdgeInsets.only(top: dp(context, space.s24)),
                  child: Center(child: Text('РќРµС‚ Р·Р°РїРёСЃРµР№ Р·Р° РІС‹Р±СЂР°РЅРЅС‹Р№ РїРµСЂРёРѕРґ', style: emptyStyle)),
                ),
              ),
              SliverToBoxAdapter(child: SizedBox(height: bottomListPadding)),
            ] else ...[
              SliverToBoxAdapter(child: SizedBox(height: dp(context, space.s10))),
              for (final entry in groups.indexed) ...[
                SliverToBoxAdapter(
                  child: Padding(
                    padding: EdgeInsets.only(
                      right: side,
                      top: dp(context, space.s2),
                      bottom: dp(context, space.s2),
                    ),
                    child: Align(
                      alignment: Alignment.centerRight,
                      child: Text(_formatDate(entry.$2.key), textAlign: TextAlign.right, style: dateStyle),
                    ),
                  ),
                ),
                SliverList(
                  delegate: SliverChildBuilderDelegate(
                        (context, i) {
                      final r = entry.$2.value[i];
                      return Padding(
                        padding: EdgeInsets.fromLTRB(side, dp(context, space.s12), side, 0),
                        child: RecordListItem(
                          record: r,
                          onTap: () => _openEdit(context, r),
                        ),
                      );
                    },
                    childCount: entry.$2.value.length,
                  ),
                ),
                SliverToBoxAdapter(child: SizedBox(height: dp(context, space.s10))),
              ],
              SliverToBoxAdapter(child: SizedBox(height: bottomListPadding)),
            ],
          ],
        );

        return ColoredBox(
          color: colors.background,
          child: Column(
            children: [
              SizedBox(
                height: blueH + shelfH,
                child: Stack(
                  clipBehavior: Clip.none,
                  children: [
                    header,
                    Positioned(
                      left: side,
                      right: side,
                      top: blueH - overlap + dp(context, space.s4),
                      child: SummaryCard(record: lastRecord),
                    ),
                  ],
                ),
              ),
              Expanded(child: list),
            ],
          ),
        );
      },
    );
  }

  List<MapEntry<DateTime, List<BloodPressureRecord>>> _groupByDate(List<BloodPressureRecord> records) {
    final grouped = <DateTime, List<BloodPressureRecord>>{};
    for (final r in records) {
      final d = DateTime(r.dateTime.year, r.dateTime.month, r.dateTime.day);
      grouped.putIfAbsent(d, () => []).add(r);
    }
    final keys = grouped.keys.toList()..sort((a, b) => b.compareTo(a));
    return [for (final k in keys) MapEntry(k, grouped[k]!)];
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    if (date == today) {
      return '${AppStrings.today}, ${DateFormat('d MMMM', 'ru').format(date)}';
    }
    return DateFormat('d MMMM yyyy, EEEE', 'ru').format(date);
  }
}
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';

import '../../../core/theme/app_theme.dart';
import '../../../core/theme/scale.dart';

import '../../profile/presentation/bloc/profile_cubit.dart';
import '../../profile/presentation/bloc/profile_state.dart';

import '../presentation/bloc/home_bloc.dart';
import '../presentation/bloc/home_state.dart';
import '../presentation/bloc/statistics_cubit.dart';
import '../presentation/bloc/statistics_state.dart';

enum _ChartTab { pressure, pulse }

class StatisticsScreen extends StatelessWidget {
  const StatisticsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<ProfileCubit, ProfileState>(
      builder: (context, profileState) {
        int targetSys = 120;
        int targetDia = 80;

        if (profileState is ProfileLoaded) {
          targetSys = profileState.profile.targetSystolic;
          targetDia = profileState.profile.targetDiastolic;
        }

        return BlocBuilder<HomeBloc, HomeState>(
          builder: (context, homeState) {
            if (homeState is! HomeLoaded) {
              return const Scaffold(body: Center(child: CircularProgressIndicator()));
            }

            return BlocProvider(
              create: (_) => StatisticsCubit(
                homeState.records,
                targetSystolic: targetSys,
                targetDiastolic: targetDia,
              )..updatePeriod(StatisticsPeriod.thirtyDays),
              child: const _StatisticsView(),
            );
          },
        );
      },
    );
  }
}

class _StatisticsView extends StatefulWidget {
  const _StatisticsView();

  @override
  State<_StatisticsView> createState() => _StatisticsViewState();
}

class _StatisticsViewState extends State<_StatisticsView> {
  _ChartTab _tab = _ChartTab.pressure;

  String _periodLabel(StatisticsPeriod p) {
    switch (p) {
      case StatisticsPeriod.sevenDays:
        return 'РќРµРґРµР»СЏ';
      case StatisticsPeriod.thirtyDays:
        return 'РњРµСЃСЏС†';
      case StatisticsPeriod.all:
        return 'Р’СЃРµ';
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;

    final colors = context.appColors;
    final space = context.appSpace;
    final radii = context.appRadii;
    final shadows = context.appShadow;
    final text = context.appText;

    final headerH = dp(context, space.s128);
    final navH = dp(context, space.s72 - space.s2 - space.s1); // 69
    final side = space.s20;

    final chipH = dp(context, space.s32);
    final chipW = dp(context, space.w96) + dp(context, space.s4) + dp(context, space.s1); // 101
    final chipR = dp(context, radii.r5);

    final tabsW = double.infinity;
    final tabsH = dp(context, space.s46);

    final chartW = double.infinity;
    final chartH = dp(context, 350);

    final statsW = double.infinity;
    final statsH = dp(context, space.s112);

    final headerBg = isDark ? AppPalette.dark800 : AppPalette.blue700;
    final cardBg = isDark ? AppPalette.dark700 : AppPalette.grey050;
    final chipBg = isDark ? AppPalette.dark700 : AppPalette.blue500;

    final headerTopInset = MediaQuery.paddingOf(context).top;

    final titleStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs26),
      fontWeight: text.w600,
      color: colors.textOnBrand,
      height: 1.0,
    );

    final tabSelectedStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs16),
      fontWeight: text.w600,
      color: isDark ? colors.textOnBrand : AppPalette.blue900,
      height: 1.0,
    );

    final tabUnselectedStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs16),
      fontWeight: text.w400,
      color: isDark ? AppPalette.dark350 : AppPalette.grey500,
      height: 1.0,
    );

    return Scaffold(
      backgroundColor: colors.background,
      body: BlocBuilder<StatisticsCubit, StatisticsState>(
        builder: (context, state) {
          final hasData = state.filteredRecords.isNotEmpty;

          return Column(
            children: [
              // Header
              Container(
                height: headerH,
                width: double.infinity,
                color: headerBg,
                padding: EdgeInsets.only(
                  left: side,
                  right: side,
                  top: headerTopInset + dp(context, space.s20),
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: Text(
                        'Р“СЂР°С„РёРєРё',
                        style: titleStyle,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    _PeriodChip(
                      width: chipW,
                      height: chipH,
                      radius: chipR,
                      bg: chipBg,
                      textColor: colors.textOnBrand,
                      label: _periodLabel(state.period),
                      onSelected: (p) => context.read<StatisticsCubit>().updatePeriod(p),
                    ),
                  ],
                ),
              ),

              Expanded(
                child: SingleChildScrollView(
                  padding: EdgeInsets.fromLTRB(
                    side,
                    dp(context, space.s20),
                    side,
                    navH + dp(context, space.s20),
                  ),
                  child: Column(
                    children: [
                      // Tabs card
                      Container(
                        width: tabsW,
                        height: tabsH,
                        decoration: BoxDecoration(
                          color: cardBg,
                          boxShadow: [shadows.card],
                        ),
                        child: Row(
                          children: [
                            Expanded(
                              child: _WordUnderlineTab(
                                title: 'Р”Р°РІР»РµРЅРёРµ',
                                selected: _tab == _ChartTab.pressure,
                                selectedStyle: tabSelectedStyle,
                                unselectedStyle: tabUnselectedStyle,
                                underlineColor: isDark ? colors.textOnBrand : AppPalette.blue900,
                                underlineHeight: dp(context, space.s2),
                                onTap: () => setState(() => _tab = _ChartTab.pressure),
                              ),
                            ),
                            Expanded(
                              child: _WordUnderlineTab(
                                title: 'РџСѓР»СЊСЃ',
                                selected: _tab == _ChartTab.pulse,
                                selectedStyle: tabSelectedStyle,
                                unselectedStyle: tabUnselectedStyle,
                                underlineColor: isDark ? colors.textOnBrand : AppPalette.blue900,
                                underlineHeight: dp(context, space.s2),
                                onTap: () => setState(() => _tab = _ChartTab.pulse),
                              ),
                            ),
                          ],
                        ),
                      ),

                      SizedBox(height: dp(context, space.s2)),

                      // Chart card
                      Container(
                        width: chartW,
                        height: chartH,
                        decoration: BoxDecoration(
                          color: cardBg,
                          boxShadow: [shadows.card],
                        ),
                        child: Padding(
                          padding: EdgeInsets.fromLTRB(
                            space.s16,
                            dp(context, space.s16),
                            space.s16,
                            dp(context, space.s20),
                          ),
                          child: hasData
                              ? _Chart(
                            tab: _tab,
                            state: state,
                            isDark: isDark,
                          )
                              : Center(
                            child: Text(
                              'РќРµС‚ РґР°РЅРЅС‹С… Р·Р° СЌС‚РѕС‚ РїРµСЂРёРѕРґ',
                              style: TextStyle(
                                fontFamily: text.family,
                                fontSize: sp(context, text.fs14),
                                fontWeight: text.w400,
                                color: isDark ? AppPalette.dark350 : AppPalette.grey500,
                                height: 1.0,
                              ),
                            ),
                          ),
                        ),
                      ),

                      SizedBox(height: dp(context, space.s20)),

                      // Stats
                      Container(
                        width: statsW,
                        height: statsH,
                        decoration: BoxDecoration(
                          color: cardBg,
                          boxShadow: [shadows.card],
                        ),
                        padding: EdgeInsets.symmetric(
                          horizontal: dp(context, space.s20),
                          vertical: dp(context, space.s16),
                        ),
                        child: _StatsBlock(
                          isDark: isDark,
                          tab: _tab,
                          state: state,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

class _PeriodChip extends StatelessWidget {
  final double width;
  final double height;
  final double radius;
  final Color bg;
  final Color textColor;
  final String label;
  final ValueChanged<StatisticsPeriod> onSelected;

  const _PeriodChip({
    required this.width,
    required this.height,
    required this.radius,
    required this.bg,
    required this.textColor,
    required this.label,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    final space = context.appSpace;
    final text = context.appText;

    return PopupMenuButton<StatisticsPeriod>(
      onSelected: onSelected,
      itemBuilder: (context) => const [
        PopupMenuItem(value: StatisticsPeriod.sevenDays, child: Text('РќРµРґРµР»СЏ')),
        PopupMenuItem(value: StatisticsPeriod.thirtyDays, child: Text('РњРµСЃСЏС†')),
        PopupMenuItem(value: StatisticsPeriod.all, child: Text('Р’СЃРµ')),
      ],
      offset: Offset(0, dp(context, space.s30 - space.s2)),
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          color: bg,
          borderRadius: BorderRadius.circular(radius),
        ),
        padding: EdgeInsets.symmetric(horizontal: space.s10),
        child: Row(
          children: [
            Expanded(
              child: Text(
                label,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: TextStyle(
                  fontFamily: text.family,
                  fontSize: sp(context, text.fs16),
                  fontWeight: text.w600,
                  color: textColor,
                  height: 1.0,
                ),
              ),
            ),
            SvgPicture.asset(
              'assets/arrow_drop_down.svg',
              width: dp(context, space.s24),
              height: dp(context, space.s24),
              colorFilter: ColorFilter.mode(textColor, BlendMode.srcIn),
            ),
          ],
        ),
      ),
    );
  }
}

class _WordUnderlineTab extends StatelessWidget {
  final String title;
  final bool selected;
  final TextStyle selectedStyle;
  final TextStyle unselectedStyle;
  final Color underlineColor;
  final double underlineHeight;
  final VoidCallback onTap;

  const _WordUnderlineTab({
    required this.title,
    required this.selected,
    required this.selectedStyle,
    required this.unselectedStyle,
    required this.underlineColor,
    required this.underlineHeight,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final space = context.appSpace;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Center(
        child: IntrinsicWidth(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(title, style: selected ? selectedStyle : unselectedStyle),
              SizedBox(height: dp(context, space.s6)),
              Container(
                height: underlineHeight,
                width: double.infinity,
                color: selected ? underlineColor : Colors.transparent,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _StatsBlock extends StatelessWidget {
  final bool isDark;
  final _ChartTab tab;
  final StatisticsState state;

  const _StatsBlock({
    required this.isDark,
    required this.tab,
    required this.state,
  });

  @override
  Widget build(BuildContext context) {
    final space = context.appSpace;
    final text = context.appText;

    final color = isDark ? AppPalette.dark350 : AppPalette.blue900;

    String fmtPressure(double sys, double dia) => '${sys.toInt()}/${dia.toInt()}';
    String fmtPulse(double v) => v == 0 ? 'вЂ”' : '${v.toInt()}';

    final avg = tab == _ChartTab.pressure ? fmtPressure(state.avgSys, state.avgDia) : fmtPulse(state.avgPulse);
    final max = tab == _ChartTab.pressure ? fmtPressure(state.maxSys, state.maxDia) : fmtPulse(state.maxPulse);
    final min = tab == _ChartTab.pressure ? fmtPressure(state.minSys, state.minDia) : fmtPulse(state.minPulse);

    Widget row(String label, String value) => Row(
      children: [
        Icon(Icons.favorite, size: dp(context, space.s20), color: color),
        SizedBox(width: dp(context, space.s16)),
        Expanded(
          child: Text(
            label,
            style: TextStyle(
              fontFamily: text.family,
              fontSize: sp(context, text.fs16),
              fontWeight: text.w600,
              color: color,
              height: 1.0,
            ),
          ),
        ),
        Text(
          value,
          style: TextStyle(
            fontFamily: text.family,
            fontSize: sp(context, text.fs16),
            fontWeight: text.w600,
            color: color,
            height: 1.0,
          ),
        ),
      ],
    );

    return Column(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        row('РЎСЂРµРґРЅРµРµ:', avg),
        row('РњР°РєСЃ.:', max),
        row('РњРёРЅ.:', min),
      ],
    );
  }
}

class _Chart extends StatelessWidget {
  final _ChartTab tab;
  final StatisticsState state;
  final bool isDark;

  const _Chart({
    required this.tab,
    required this.state,
    required this.isDark,
  });

  int _xLabelStep(int len, StatisticsPeriod period) {
    if (len <= 1) return 1;
    if (period == StatisticsPeriod.sevenDays) return 1;

    if (period == StatisticsPeriod.thirtyDays) {
      if (len <= 10) return 1;
      if (len <= 20) return 2;
      return 4;
    }

    final target = 8;
    return (len / target).ceil().clamp(1, len);
  }

  Set<int> _pulseYLabels(double minY, double maxY) {
    int round10(double v) => (v / 10).round() * 10;
    final minR = (minY / 10).floor() * 10;
    final maxR = (maxY / 10).ceil() * 10;

    final span = (maxR - minR).abs();
    final rawStep = span / 3;
    var step = round10(rawStep.toDouble()).abs();
    if (step < 10) step = 10;

    return {minR, minR + step, minR + step * 2, maxR};
  }

  @override
  Widget build(BuildContext context) {
    final space = context.appSpace;
    final text = context.appText;
    final colors = context.appColors;

    final all = state.filteredRecords;
    final records = tab == _ChartTab.pulse ? all.where((r) => r.pulse > 0).toList() : all;

    if (records.isEmpty) {
      return Center(
        child: Text(
          'РќРµС‚ РґР°РЅРЅС‹С…',
          style: TextStyle(
            fontFamily: text.family,
            fontSize: sp(context, text.fs14),
            fontWeight: text.w400,
            color: isDark ? AppPalette.dark350 : AppPalette.grey500,
            height: 1.0,
          ),
        ),
      );
    }

    const pressureGridStep = 40.0;
    const pulseGridStep = 10.0;

    double minY;
    double maxY;

    if (tab == _ChartTab.pressure) {
      // С„РёРєСЃРёСЂСѓРµРј СЂР°Р·СѓРјРЅС‹Р№ РґРёР°РїР°Р·РѕРЅ РєР°Рє РІ РјР°РєРµС‚Рµ
      minY = 40;
      maxY = 220;
    } else {
      final minP = records.map((e) => e.pulse).reduce((a, b) => a < b ? a : b).toDouble();
      final maxP = records.map((e) => e.pulse).reduce((a, b) => a > b ? a : b).toDouble();
      minY = (minP - 10).clamp(30, 220);
      maxY = (maxP + 10).clamp(60, 240);
    }

    final gridColor = isDark ? AppPalette.dark600.withValues(alpha: 0.25) : AppPalette.grey400.withValues(alpha: 0.7);
    final axisTextColor = isDark ? AppPalette.dark350 : AppPalette.blue900;

    final lineStrong = isDark ? AppPalette.dark350 : AppPalette.blue900;
    final lineSoft = isDark ? AppPalette.blue500 : AppPalette.blue500;

    final spotsA = records.asMap().entries.map((e) {
      final x = e.key.toDouble();
      final y = tab == _ChartTab.pressure ? e.value.systolic.toDouble() : e.value.pulse.toDouble();
      return FlSpot(x, y);
    }).toList();

    final spotsB = tab == _ChartTab.pressure
        ? records.asMap().entries.map((e) => FlSpot(e.key.toDouble(), e.value.diastolic.toDouble())).toList()
        : const <FlSpot>[];

    final pressureYLabels = <int>{80, 120, 160, 200};
    final pulseYLabels = _pulseYLabels(minY, maxY);
    final xStep = _xLabelStep(records.length, state.period);

    String xLabel(DateTime dt) => DateFormat('d', 'ru').format(dt);

    // tooltip style
    final tooltipBg = isDark ? AppPalette.dark900.withValues(alpha: 0.92) : AppPalette.grey050.withValues(alpha: 0.96);
    final tooltipTextColor = isDark ? Colors.white : AppPalette.blue900;

    // вњ… Р·РѕРЅР° РґР°РІР»РµРЅРёСЏ РёР· РїСЂРѕС„РёР»СЏ
    final yLow = state.targetDiastolic.toDouble();
    final yHigh = state.targetSystolic.toDouble();
    final zoneColor = (tab == _ChartTab.pressure)
        ? (isDark ? AppPalette.blueAccent.withValues(alpha: 0.10) : AppPalette.blueAccent.withValues(alpha: 0.12))
        : Colors.transparent;

    final zoneLineColor = isDark
        ? AppPalette.dark350.withValues(alpha: 0.45)
        : AppPalette.blue900.withValues(alpha: 0.35);

    return LineChart(
      LineChartData(
        // вњ… ZONE (РїРѕР»РѕСЃР°)
        rangeAnnotations: tab == _ChartTab.pressure
            ? RangeAnnotations(
          horizontalRangeAnnotations: [
            HorizontalRangeAnnotation(
              y1: yLow,
              y2: yHigh,
              color: zoneColor,
            ),
          ],
        )
            : const RangeAnnotations(),

        // вњ… РіСЂР°РЅРёС†С‹ Р·РѕРЅС‹ РїСѓРЅРєС‚РёСЂРѕРј
        extraLinesData: tab == _ChartTab.pressure
            ? ExtraLinesData(
          horizontalLines: [
            HorizontalLine(
              y: yHigh,
              color: zoneLineColor,
              strokeWidth: 1,
              dashArray: const [6, 6],
            ),
            HorizontalLine(
              y: yLow,
              color: zoneLineColor,
              strokeWidth: 1,
              dashArray: const [6, 6],
            ),
          ],
        )
            : ExtraLinesData(horizontalLines: const []),

        gridData: FlGridData(
          show: true,
          drawVerticalLine: true,
          horizontalInterval: tab == _ChartTab.pressure ? pressureGridStep : pulseGridStep,
          verticalInterval: 1,
          getDrawingHorizontalLine: (_) => FlLine(color: gridColor, strokeWidth: 1),
          getDrawingVerticalLine: (_) => FlLine(color: gridColor, strokeWidth: 1),
        ),
        titlesData: FlTitlesData(
          topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          leftTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: dp(context, space.s40),
              interval: tab == _ChartTab.pressure ? pressureGridStep : pulseGridStep,
              getTitlesWidget: (value, meta) {
                final v = value.toInt();
                if (tab == _ChartTab.pressure) {
                  if (!pressureYLabels.contains(v)) return const SizedBox.shrink();
                } else {
                  if (!pulseYLabels.contains(v)) return const SizedBox.shrink();
                }
                return Text(
                  v.toString(),
                  style: TextStyle(
                    fontFamily: text.family,
                    fontSize: sp(context, text.fs12),
                    fontWeight: text.w400,
                    color: axisTextColor,
                    height: 1.0,
                  ),
                );
              },
            ),
          ),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: dp(context, space.s24),
              interval: 1,
              getTitlesWidget: (value, meta) {
                final i = value.toInt();
                if (i < 0 || i >= records.length) return const SizedBox.shrink();
                if (i % xStep != 0 && i != records.length - 1) return const SizedBox.shrink();
                return Padding(
                  padding: EdgeInsets.only(top: dp(context, space.s6)),
                  child: Text(
                    xLabel(records[i].dateTime),
                    style: TextStyle(
                      fontFamily: text.family,
                      fontSize: sp(context, text.fs12),
                      fontWeight: text.w400,
                      color: axisTextColor,
                      height: 1.0,
                    ),
                  ),
                );
              },
            ),
          ),
        ),
        borderData: FlBorderData(show: false),
        minX: 0,
        maxX: (records.length - 1).toDouble(),
        minY: minY,
        maxY: maxY,
        lineBarsData: [
          LineChartBarData(
            spots: spotsA,
            isCurved: false,
            color: lineStrong,
            barWidth: dp(context, space.s2),
            dotData: const FlDotData(show: false),
          ),
          if (tab == _ChartTab.pressure)
            LineChartBarData(
              spots: spotsB,
              isCurved: false,
              color: lineSoft,
              barWidth: dp(context, space.s2),
              dotData: const FlDotData(show: false),
            ),
        ],
        lineTouchData: LineTouchData(
          enabled: true,
          handleBuiltInTouches: true,
          touchTooltipData: LineTouchTooltipData(
            getTooltipColor: (_) => tooltipBg,
            tooltipRoundedRadius: dp(context, context.appRadii.r10),
            tooltipPadding: EdgeInsets.symmetric(
              horizontal: space.s10,
              vertical: dp(context, space.s6),
            ),
            fitInsideHorizontally: true,
            fitInsideVertically: true,
            getTooltipItems: (touchedSpots) {
              return touchedSpots.map((spot) {
                final rec = records[spot.x.toInt()];
                final dateStr = DateFormat('dd.MM', 'ru').format(rec.dateTime);
                final label = tab == _ChartTab.pressure ? (spot.barIndex == 0 ? 'РЎРёСЃС‚.' : 'Р”РёР°СЃС‚.') : 'РџСѓР»СЊСЃ';
                return LineTooltipItem(
                  '$dateStr\n$label: ${spot.y.toInt()}',
                  TextStyle(
                    fontFamily: text.family,
                    fontSize: sp(context, text.fs12),
                    fontWeight: text.w600,
                    color: tooltipTextColor,
                    height: 1.1,
                  ),
                );
              }).toList();
            },
          ),
        ),
      ),
    );
  }
}
import 'dart:async';

import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:blood_pressure_diary/core/database/isar_service.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';
import 'package:blood_pressure_diary/features/profile/presentation/bloc/profile_state.dart';

class ProfileCubit extends Cubit<ProfileState> {
  final IsarService _isarService;

  StreamSubscription<UserProfile>? _profileSub;

  ProfileCubit(this._isarService) : super(ProfileInitial()) {
    _bind();
  }

  Future<void> _bind() async {
    await _isarService.getOrCreateProfile();

    await _profileSub?.cancel();
    _profileSub = _isarService.watchProfile().listen((profile) {
      emit(ProfileLoaded(profile));
    });
  }

  @override
  Future<void> close() async {
    await _profileSub?.cancel();
    return super.close();
  }

  Future<void> loadProfile() async {
    if (state is ProfileLoaded) return;
    emit(ProfileLoading());
    try {
      final profile = await _isarService.getOrCreateProfile();
      emit(ProfileLoaded(profile));
    } catch (e) {
      emit(ProfileError(e.toString()));
    }
  }

  Future<void> updateProfile({
    String? name,
    int? age,
    String? gender,
    double? weight,
    int? targetSystolic,
    int? targetDiastolic,
  }) async {
    final current = await _isarService.getOrCreateProfile();

    final updated = UserProfile()
      ..id = 0
      ..name = name ?? current.name
      ..age = age ?? current.age
      ..gender = gender ?? current.gender
      ..weight = weight ?? current.weight
      ..targetSystolic = targetSystolic ?? current.targetSystolic
      ..targetDiastolic = targetDiastolic ?? current.targetDiastolic
      ..accountLinked = current.accountLinked
      ..accountEmail = current.accountEmail
      ..accountProvider = current.accountProvider;

    await _isarService.saveProfile(updated);
  }

  Future<void> linkAccount({
    required String provider,
    required String email,
  }) async {
    final current = await _isarService.getOrCreateProfile();

    final updated = UserProfile()
      ..id = 0
      ..name = current.name
      ..age = current.age
      ..gender = current.gender
      ..weight = current.weight
      ..targetSystolic = current.targetSystolic
      ..targetDiastolic = current.targetDiastolic
      ..accountLinked = true
      ..accountProvider = provider.trim()
      ..accountEmail = email.trim();

    await _isarService.saveProfile(updated);
  }

  Future<void> unlinkAccount() async {
    final current = await _isarService.getOrCreateProfile();

    final updated = UserProfile()
      ..id = 0
      ..name = current.name
      ..age = current.age
      ..gender = current.gender
      ..weight = current.weight
      ..targetSystolic = current.targetSystolic
      ..targetDiastolic = current.targetDiastolic
      ..accountLinked = false
      ..accountProvider = ''
      ..accountEmail = '';

    await _isarService.saveProfile(updated);
  }
}
import 'package:equatable/equatable.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';

abstract class ProfileState extends Equatable {
  const ProfileState();

  @override
  List<Object?> get props => [];
}

class ProfileInitial extends ProfileState {}

class ProfileLoading extends ProfileState {}

class ProfileLoaded extends ProfileState {
  final UserProfile profile;

  const ProfileLoaded(this.profile);

  @override
  List<Object?> get props => [
    profile.name,
    profile.age,
    profile.gender,
    profile.weight,
    profile.targetSystolic,
    profile.targetDiastolic,

    // вњ… Р’РђР–РќРћ: С‡С‚РѕР±С‹ UI РѕР±РЅРѕРІР»СЏР»СЃСЏ РїСЂРё РІС…РѕРґРµ/РІС‹С…РѕРґРµ
    profile.accountLinked,
    profile.accountEmail,
    profile.accountProvider,
  ];
}

class ProfileError extends ProfileState {
  final String message;

  const ProfileError(this.message);

  @override
  List<Object?> get props => [message];
}
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../core/database/models/user_profile.dart';
import '../../../core/theme/app_theme.dart';
import '../../../core/theme/scale.dart';
import '../../../l10n/generated/app_localizations.dart';

import 'bloc/profile_cubit.dart';
import 'bloc/profile_state.dart';

class ProfileScreen extends StatelessWidget {
  const ProfileScreen({super.key});

  String _providerTitle(String provider) {
    switch (provider) {
      case 'google':
        return 'Google';
      case 'apple':
        return 'Apple';
      case 'email':
        return 'Email';
      default:
        return provider.isEmpty ? 'РђРєРєР°СѓРЅС‚' : provider;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    final isDark = Theme.of(context).brightness == Brightness.dark;

    final colors = context.appColors;
    final space = context.appSpace;
    final radii = context.appRadii;
    final shadows = context.appShadow;
    final text = context.appText;

    final headerH = dp(context, space.s128);
    final side = dp(context, space.s20);

    final cardR = dp(context, radii.r10);

    final fieldH = dp(context, space.s48);
    final fieldR = dp(context, radii.r10);

    final headerBg = isDark ? AppPalette.dark800 : AppPalette.blue700;
    final headerTopInset = MediaQuery.paddingOf(context).top;

    // UI-only: РІ РјР°РєРµС‚Рµ РїРѕРєР°Р·Р°РЅ РїСЂРёРјРµСЂ РґР°С‚С‹
    const demoDob = '25.12.1980';

    String? _formatDob(int stored) {
      // РҐСЂР°РЅРёРј РґР°С‚Сѓ СЂРѕР¶РґРµРЅРёСЏ РєР°Рє YYYYMMDD РІ РїРѕР»Рµ age (С‡С‚РѕР±С‹ РЅРµ С‚СЂРѕРіР°С‚СЊ Isar-СЃС…РµРјСѓ).
      // Р•СЃР»Рё stored РІС‹РіР»СЏРґРёС‚ РєР°Рє "РѕР±С‹С‡РЅС‹Р№ РІРѕР·СЂР°СЃС‚" (0..150) вЂ” РґР°С‚С‹ РЅРµС‚.
      if (stored < 19000101) return null;
      final s = stored.toString().padLeft(8, '0');
      final yyyy = s.substring(0, 4);
      final mm = s.substring(4, 6);
      final dd = s.substring(6, 8);
      return '$dd.$mm.$yyyy';
    }

    // РџР»РѕС‚РЅРµРµ РїРѕ Y вЂ” РіР»Р°РІРЅС‹Р№ С„РёРєСЃ
    final pad12 = dp(context, space.s12);
    final pad10 = dp(context, space.s10);
    final pad8 = dp(context, space.s8);
    final pad6 = dp(context, space.s6);
    final pad4 = dp(context, space.s4);
    final pad2 = dp(context, space.s2);

    final titleStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs26),
      fontWeight: text.w600,
      color: colors.textOnBrand,
      height: 1.0,
    );

    final sectionTitleStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs16),
      fontWeight: text.w600,
      color: colors.textPrimary,
      height: 1.0,
    );

    final hintStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs12),
      fontWeight: text.w400,
      color: colors.textPrimary,
      height: 1.0,
    );

    final labelStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs14),
      fontWeight: text.w400,
      color: colors.textPrimary,
      height: 1.0,
    );

    final valueStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs20),
      fontWeight: text.w500,
      color: colors.textPrimary,
      height: 1.0,
    );

    final privacyStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs12),
      fontWeight: text.w400,
      color: colors.textPrimary,
      height: 1.0,
    );

    Widget _primaryButton({
      required String title,
      String? subtitle,
      required Color bg,
      required Color fg,
      required VoidCallback onTap,
    }) {
      return GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: onTap,
        child: Container(
          height: fieldH,
          decoration: BoxDecoration(
            color: bg,
            borderRadius: BorderRadius.circular(fieldR),
          ),
          alignment: Alignment.center,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                title,
                style: TextStyle(
                  fontFamily: text.family,
                  fontSize: sp(context, text.fs20),
                  fontWeight: text.w600,
                  color: fg,
                  height: 1.0,
                ),
              ),
              if (subtitle != null && subtitle.isNotEmpty) ...[
                SizedBox(height: dp(context, space.s2)),
                Text(subtitle, style: hintStyle.copyWith(color: fg), textAlign: TextAlign.center),
              ],
            ],
          ),
        ),
      );
    }

    Widget _wideField({required String textValue, VoidCallback? onTap}) {
      final bg = isDark ? colors.surfaceAlt : colors.background;
      return GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: onTap,
        child: Container(
          height: fieldH,
          width: double.infinity,
          decoration: BoxDecoration(
            color: bg,
            borderRadius: BorderRadius.circular(fieldR),
          ),
          padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
          alignment: Alignment.centerLeft,
          child: Text(textValue, style: valueStyle),
        ),
      );
    }

    Widget _valueBox({required String textValue, VoidCallback? onTap}) {
      final w = dp(context, space.s120 + space.s16 + space.s1); // 137
      final bg = isDark ? colors.surfaceAlt : colors.background;

      return GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: onTap,
        child: Container(
          height: fieldH,
          width: w,
          decoration: BoxDecoration(
            color: bg,
            borderRadius: BorderRadius.circular(fieldR),
          ),
          padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
          alignment: Alignment.centerRight,
          child: Text(textValue, style: valueStyle),
        ),
      );
    }

    Widget _segPill({
      required String title,
      required bool selected,
      required VoidCallback onTap,
      required Color activeBg,
      required Color inactiveText,
      required Color activeText,
    }) {
      return Expanded(
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: onTap,
          child: Container(
            height: fieldH,
            decoration: BoxDecoration(
              color: selected ? activeBg : Colors.transparent,
              borderRadius: BorderRadius.circular(fieldR),
            ),
            alignment: Alignment.center,
            child: Text(
              title,
              style: valueStyle.copyWith(color: selected ? activeText : inactiveText),
            ),
          ),
        ),
      );
    }

    Widget normsBlock({
      required String topValue,
      required String bottomValue,
      VoidCallback? onTapTop,
      VoidCallback? onTapBottom,
    }) {
      final fieldBg = isDark ? colors.surfaceAlt : colors.background;
      final borderColor = fieldBg;
      final borderW = dp(context, space.s1);

      final labelLeftPad = dp(context, space.s12);
      final betweenRows = pad4;

      return Container(
        width: double.infinity,
        decoration: BoxDecoration(
          border: Border.all(color: borderColor, width: borderW),
          borderRadius: BorderRadius.circular(fieldR),
        ),
        padding: EdgeInsets.all(pad2),
        child: Column(
          children: [
            SizedBox(
              height: fieldH,
              child: Row(
                children: [
                  Expanded(
                    child: Padding(
                      padding: EdgeInsets.only(left: labelLeftPad),
                      child: Align(
                        alignment: Alignment.centerLeft,
                        child: Text('Р’РµСЂС…РЅРµРµ', style: valueStyle),
                      ),
                    ),
                  ),
                  _valueBox(textValue: topValue, onTap: onTapTop),
                ],
              ),
            ),
            SizedBox(height: betweenRows),
            SizedBox(
              height: fieldH,
              child: Row(
                children: [
                  Expanded(
                    child: Padding(
                      padding: EdgeInsets.only(left: labelLeftPad),
                      child: Align(
                        alignment: Alignment.centerLeft,
                        child: Text('РќРёР¶РЅРµРµ', style: valueStyle),
                      ),
                    ),
                  ),
                  _valueBox(textValue: bottomValue, onTap: onTapBottom),
                ],
              ),
            ),
          ],
        ),
      );
    }

    Widget _sheetItem({
      required BuildContext context,
      required String title,
      required VoidCallback onTap,
    }) {
      return GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: onTap,
        child: Container(
          height: fieldH,
          decoration: BoxDecoration(
            color: isDark ? colors.surfaceAlt : colors.background,
            borderRadius: BorderRadius.circular(fieldR),
          ),
          padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
          alignment: Alignment.centerLeft,
          child: Text(title, style: valueStyle),
        ),
      );
    }

    void _showEmailInputSheet(BuildContext context) {
      final controller = TextEditingController();

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (ctx) {
          final sheetBg = colors.surface;
          final sheetR = dp(context, radii.r10);
          final bottomInset = MediaQuery.viewInsetsOf(ctx).bottom;

          return SafeArea(
            child: Padding(
              padding: EdgeInsets.only(
                left: dp(context, space.s12),
                right: dp(context, space.s12),
                bottom: dp(context, space.s12) + bottomInset,
              ),
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: sheetBg,
                  borderRadius: BorderRadius.circular(sheetR),
                  boxShadow: [shadows.card],
                ),
                child: Padding(
                  padding: EdgeInsets.all(dp(context, space.s12)),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('Email', style: sectionTitleStyle),
                      SizedBox(height: dp(context, space.s8)),
                      Container(
                        height: fieldH,
                        decoration: BoxDecoration(
                          color: isDark ? colors.surfaceAlt : colors.background,
                          borderRadius: BorderRadius.circular(fieldR),
                        ),
                        padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
                        alignment: Alignment.centerLeft,
                        child: TextField(
                          controller: controller,
                          keyboardType: TextInputType.emailAddress,
                          decoration: const InputDecoration(
                            border: InputBorder.none,
                            isCollapsed: true,
                          ),
                          style: valueStyle,
                        ),
                      ),
                      SizedBox(height: dp(context, space.s12)),
                      SizedBox(
                        width: double.infinity,
                        child: _primaryButton(
                          title: 'РџРѕРґРєР»СЋС‡РёС‚СЊ',
                          bg: isDark ? AppPalette.dark900 : AppPalette.blue900,
                          fg: isDark ? colors.textPrimary : colors.textOnBrand,
                          onTap: () {
                            final email = controller.text.trim();
                            if (email.isEmpty) return;
                            context.read<ProfileCubit>().linkAccount(provider: 'email', email: email);
                            Navigator.pop(ctx);
                          },
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      );
    }

    DateTime? _tryParseDob(int stored) {
      if (stored < 19000101) return null;
      final s = stored.toString().padLeft(8, '0');
      final yyyy = int.tryParse(s.substring(0, 4));
      final mm = int.tryParse(s.substring(4, 6));
      final dd = int.tryParse(s.substring(6, 8));
      if (yyyy == null || mm == null || dd == null) return null;
      return DateTime(yyyy, mm, dd);
    }

    Future<void> _pickDob(BuildContext context, UserProfile profile) async {
      final now = DateTime.now();
      final initial = _tryParseDob(profile.age) ?? DateTime(now.year - 30, 1, 1);

      final picked = await showDatePicker(
        context: context,
        initialDate: initial,
        firstDate: DateTime(1900, 1, 1),
        lastDate: DateTime(now.year, 12, 31),
      );

      if (picked == null) return;

      final stored = (picked.year * 10000) + (picked.month * 100) + picked.day;
      context.read<ProfileCubit>().updateProfile(age: stored);
    }

    void _showNameInputSheet(BuildContext context, UserProfile profile) {
      final controller = TextEditingController(text: profile.name.isEmpty ? '' : profile.name);

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (ctx) {
          final sheetBg = colors.surface;
          final sheetR = dp(context, radii.r10);
          final bottomInset = MediaQuery.viewInsetsOf(ctx).bottom;

          return SafeArea(
            child: Padding(
              padding: EdgeInsets.only(
                left: dp(context, space.s12),
                right: dp(context, space.s12),
                bottom: dp(context, space.s12) + bottomInset,
                top: dp(context, space.s12),
              ),
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: sheetBg,
                  borderRadius: BorderRadius.circular(sheetR),
                  boxShadow: [shadows.card],
                ),
                child: Padding(
                  padding: EdgeInsets.all(dp(context, space.s12)),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Text('РРјСЏ', style: labelStyle),
                      SizedBox(height: dp(context, space.s8)),
                      TextField(
                        controller: controller,
                        autofocus: true,
                        style: valueStyle,
                        decoration: InputDecoration(
                          filled: true,
                          fillColor: isDark ? colors.surfaceAlt : colors.background,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(fieldR),
                            borderSide: BorderSide.none,
                          ),
                        ),
                      ),
                      SizedBox(height: dp(context, space.s12)),
                      ElevatedButton(
                        onPressed: () {
                          final v = controller.text.trim();
                          context.read<ProfileCubit>().updateProfile(name: v);
                          Navigator.of(ctx).pop();
                        },
                        child: const Text('РЎРѕС…СЂР°РЅРёС‚СЊ'),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      );
    }

    void _showIntInputSheet(
        BuildContext context, {
          required String title,
          required int initialValue,
          required void Function(int value) onSubmit,
        }) {
      final controller = TextEditingController(text: initialValue.toString());

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (ctx) {
          final sheetBg = colors.surface;
          final sheetR = dp(context, radii.r10);
          final bottomInset = MediaQuery.viewInsetsOf(ctx).bottom;

          return SafeArea(
            child: Padding(
              padding: EdgeInsets.only(
                left: dp(context, space.s12),
                right: dp(context, space.s12),
                bottom: dp(context, space.s12) + bottomInset,
                top: dp(context, space.s12),
              ),
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: sheetBg,
                  borderRadius: BorderRadius.circular(sheetR),
                  boxShadow: [shadows.card],
                ),
                child: Padding(
                  padding: EdgeInsets.all(dp(context, space.s12)),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Text(title, style: labelStyle),
                      SizedBox(height: dp(context, space.s8)),
                      TextField(
                        controller: controller,
                        keyboardType: TextInputType.number,
                        autofocus: true,
                        style: valueStyle,
                        decoration: InputDecoration(
                          filled: true,
                          fillColor: isDark ? colors.surfaceAlt : colors.background,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(fieldR),
                            borderSide: BorderSide.none,
                          ),
                        ),
                      ),
                      SizedBox(height: dp(context, space.s12)),
                      ElevatedButton(
                        onPressed: () {
                          final v = int.tryParse(controller.text.trim());
                          if (v == null) return;
                          onSubmit(v);
                          Navigator.of(ctx).pop();
                        },
                        child: const Text('РЎРѕС…СЂР°РЅРёС‚СЊ'),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      );
    }

    void _showAccountLinkSheet(BuildContext context) {
      showModalBottomSheet(
        context: context,
        backgroundColor: Colors.transparent,
        builder: (ctx) {
          final sheetBg = colors.surface;
          final sheetR = dp(context, radii.r10);

          return SafeArea(
            child: Padding(
              padding: EdgeInsets.all(dp(context, space.s12)),
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: sheetBg,
                  borderRadius: BorderRadius.circular(sheetR),
                  boxShadow: [shadows.card],
                ),
                child: Padding(
                  padding: EdgeInsets.all(dp(context, space.s12)),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('Р’С‹Р±РµСЂРёС‚Рµ СЃРїРѕСЃРѕР± РІС…РѕРґР°', style: sectionTitleStyle),
                      SizedBox(height: dp(context, space.s12)),
                      _sheetItem(
                        context: context,
                        title: 'Email',
                        onTap: () {
                          Navigator.pop(ctx);
                          _showEmailInputSheet(context);
                        },
                      ),
                      SizedBox(height: dp(context, space.s8)),
                      _sheetItem(
                        context: context,
                        title: 'Google',
                        onTap: () {
                          // Р»РѕРєР°Р»СЊРЅР°СЏ РїСЂРёРІСЏР·РєР°: РїСЂРѕРІР°Р№РґРµСЂ РµСЃС‚СЊ, email РїСѓСЃС‚РѕР№
                          context.read<ProfileCubit>().linkAccount(provider: 'google', email: '');
                          Navigator.pop(ctx);
                        },
                      ),
                      SizedBox(height: dp(context, space.s8)),
                      _sheetItem(
                        context: context,
                        title: 'Apple',
                        onTap: () {
                          context.read<ProfileCubit>().linkAccount(provider: 'apple', email: '');
                          Navigator.pop(ctx);
                        },
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      );
    }

    return Scaffold(
      backgroundColor: colors.background,
      body: BlocBuilder<ProfileCubit, ProfileState>(
        builder: (context, state) {
          if (state is ProfileInitial) {
            context.read<ProfileCubit>().loadProfile();
          }
          if (state is ProfileLoading) {
            return const Center(child: CircularProgressIndicator());
          }
          if (state is! ProfileLoaded) {
            return const SizedBox.shrink();
          }

          final profile = state.profile;
          final displayedDob = _formatDob(profile.age) ?? demoDob;
          final isLoggedIn = profile.accountLinked;

          final cardBg = colors.surface;

          final innerZoneBg = isDark ? cardBg : AppPalette.grey050;
          final innerZoneBorderColor = isDark ? AppPalette.dark800 : colors.background;

          final accountBtnBg = isDark
              ? (isLoggedIn ? colors.surfaceAlt : AppPalette.dark900)
              : (isLoggedIn ? AppPalette.blue500 : AppPalette.blue900);

          final accountBtnFg = isDark ? colors.textPrimary : colors.textOnBrand;

          final segBg = isDark ? colors.surfaceAlt : colors.background;
          final segActiveBg = colors.surface;
          final segText = colors.textPrimary;

          final bottomPad = dp(context, space.s80) + MediaQuery.paddingOf(context).bottom + dp(context, space.s20);

          final accountLine = profile.accountEmail.trim().isNotEmpty
              ? profile.accountEmail.trim()
              : _providerTitle(profile.accountProvider);

          return Column(
            children: [
              Container(
                height: headerH,
                width: double.infinity,
                color: headerBg,
                padding: EdgeInsets.only(
                  left: side,
                  right: side,
                  top: headerTopInset + dp(context, space.s20),
                ),
                alignment: Alignment.centerLeft,
                child: Text(l10n.profile, style: titleStyle),
              ),
              Expanded(
                child: SingleChildScrollView(
                  padding: EdgeInsets.only(
                    left: side,
                    right: side,
                    top: pad12,
                    bottom: bottomPad,
                  ),
                  child: Column(
                    children: [
                      // ---- РђРєРєР°СѓРЅС‚
                      SizedBox(
                        width: double.infinity,
                        child: DecoratedBox(
                          decoration: BoxDecoration(
                            color: cardBg,
                            borderRadius: BorderRadius.circular(cardR),
                            boxShadow: [shadows.card],
                          ),
                          child: Padding(
                            padding: EdgeInsets.all(pad12),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text('РђРєРєР°СѓРЅС‚', style: sectionTitleStyle),
                                SizedBox(height: pad6),
                                Container(
                                  width: double.infinity,
                                  decoration: BoxDecoration(
                                    color: innerZoneBg,
                                    borderRadius: BorderRadius.circular(cardR),
                                    border: isDark
                                        ? Border.all(
                                      color: innerZoneBorderColor,
                                      width: dp(context, space.s1),
                                    )
                                        : null,
                                  ),
                                  padding: EdgeInsets.symmetric(horizontal: pad12, vertical: pad10),
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      if (!isLoggedIn) ...[
                                        Text('Р’С‹ РЅРµ РІРѕС€Р»Рё РІ Р°РєРєР°СѓРЅС‚', style: hintStyle),
                                        SizedBox(height: pad8),
                                        SizedBox(
                                          width: double.infinity,
                                          child: _primaryButton(
                                            title: 'Р’РѕР№С‚Рё',
                                            bg: accountBtnBg,
                                            fg: accountBtnFg,
                                            onTap: () => _showAccountLinkSheet(context),
                                          ),
                                        ),
                                      ] else ...[
                                        Text('РђРєРєР°СѓРЅС‚ РїРѕРґРєР»СЋС‡РµРЅ', style: hintStyle),
                                        SizedBox(height: pad4),
                                        Text(accountLine, style: valueStyle),
                                        SizedBox(height: pad8),
                                        SizedBox(
                                          width: double.infinity,
                                          child: _primaryButton(
                                            title: 'Р’С‹Р№С‚Рё',
                                            bg: accountBtnBg,
                                            fg: accountBtnFg,
                                            onTap: () => context.read<ProfileCubit>().unlinkAccount(),
                                          ),
                                        ),
                                      ],
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),

                      SizedBox(height: pad12),

                      // ---- РџСЂРѕС„РёР»СЊ
                      SizedBox(
                        width: double.infinity,
                        child: DecoratedBox(
                          decoration: BoxDecoration(
                            color: cardBg,
                            borderRadius: BorderRadius.circular(cardR),
                            boxShadow: [shadows.card],
                          ),
                          child: Padding(
                            padding: EdgeInsets.all(pad12),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text('РРјСЏ', style: labelStyle),
                                SizedBox(height: pad6),
                                _wideField(
                                  textValue: profile.name.isEmpty ? 'Р”РјРёС‚СЂРёР№' : profile.name,
                                  onTap: () => _showNameInputSheet(context, profile),
                                ),

                                SizedBox(height: pad10),

                                Row(
                                  children: [
                                    Expanded(child: Text('РџРѕР»', style: labelStyle)),
                                    SizedBox(width: dp(context, space.s20)),
                                    Expanded(
                                      child: Align(
                                        alignment: Alignment.centerRight,
                                        child: Text('Р”Р°С‚Р° СЂРѕР¶РґРµРЅРёСЏ', style: labelStyle),
                                      ),
                                    ),
                                  ],
                                ),
                                SizedBox(height: pad6),
                                Row(
                                  children: [
                                    Expanded(
                                      child: Container(
                                        height: fieldH,
                                        decoration: BoxDecoration(
                                          color: segBg,
                                          borderRadius: BorderRadius.circular(fieldR),
                                        ),
                                        padding: EdgeInsets.all(pad4),
                                        child: Row(
                                          children: [
                                            _segPill(
                                              title: 'РњСѓР¶.',
                                              selected: profile.gender == 'male',
                                              activeBg: segActiveBg,
                                              inactiveText: segText,
                                              activeText: segText,
                                              onTap: () => context.read<ProfileCubit>().updateProfile(gender: 'male'),
                                            ),
                                            SizedBox(width: pad4),
                                            _segPill(
                                              title: 'Р–РµРЅ.',
                                              selected: profile.gender == 'female',
                                              activeBg: segActiveBg,
                                              inactiveText: segText,
                                              activeText: segText,
                                              onTap: () => context.read<ProfileCubit>().updateProfile(gender: 'female'),
                                            ),
                                          ],
                                        ),
                                      ),
                                    ),
                                    SizedBox(width: dp(context, space.s20)),
                                    _valueBox(
                                      textValue: displayedDob,
                                      onTap: () => _pickDob(context, profile),
                                    ),
                                  ],
                                ),

                                SizedBox(height: pad10),

                                Text('РќРѕСЂРјС‹ РґР°РІР»РµРЅРёСЏ', style: labelStyle),
                                SizedBox(height: pad6),
                                normsBlock(
                                  topValue: profile.targetSystolic.toString(),
                                  bottomValue: profile.targetDiastolic.toString(),
                                  onTapTop: () => _showIntInputSheet(
                                    context,
                                    title: 'Р’РµСЂС…РЅРµРµ',
                                    initialValue: profile.targetSystolic,
                                    onSubmit: (v) => context.read<ProfileCubit>().updateProfile(targetSystolic: v),
                                  ),
                                  onTapBottom: () => _showIntInputSheet(
                                    context,
                                    title: 'РќРёР¶РЅРµРµ',
                                    initialValue: profile.targetDiastolic,
                                    onSubmit: (v) => context.read<ProfileCubit>().updateProfile(targetDiastolic: v),
                                  ),
                                ),

                                SizedBox(height: pad12),

                                SizedBox(
                                  width: double.infinity,
                                  child: _primaryButton(
                                    title: 'РЈР±СЂР°С‚СЊ СЂРµРєР»Р°РјСѓ',
                                    subtitle: 'Р Р°Р·РѕРІС‹Р№ РїР»Р°С‚РµР¶ 2,99 в‚¬ -  РЅР°РІСЃРµРіРґР°',
                                    bg: isDark ? AppPalette.dark900 : AppPalette.blue900,
                                    fg: isDark ? colors.textPrimary : colors.textOnBrand,
                                    onTap: () {},
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),

                      //SizedBox(height: pad12),
                      //Text('РџРѕР»РёС‚РёРєР° РєРѕРЅС„РёРґРµРЅС†РёР°Р»СЊРЅРѕСЃС‚Рё', style: privacyStyle, textAlign: TextAlign.center),
                    ],
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}
import 'package:isar/isar.dart';

part 'settings_model.g.dart';

@collection
class AppSettings {
  Id id = 0; // Р’СЃРµРіРґР° 0, С‚Р°Рє РєР°Рє Сѓ РЅР°СЃ С‚РѕР»СЊРєРѕ РѕРґРЅР° Р·Р°РїРёСЃСЊ РЅР°СЃС‚СЂРѕРµРє

  @enumerated
  AppThemeMode themeMode = AppThemeMode.light;

  String languageCode = 'ru';

  List<String> reminders = [];

  bool notificationsEnabled = false;

  // --- Account (Р»РѕРєР°Р»СЊРЅР°СЏ РїСЂРёРІСЏР·РєР° Р°РєРєР°СѓРЅС‚Р°)
  // РЎРµР№С‡Р°СЃ СЌС‚Рѕ РїСЂРѕСЃС‚РѕР№ "РїСЂРѕС„РёР»СЊ РїСЂРёРІСЏР·РєРё" (email/РїСЂРѕРІР°Р№РґРµСЂ) Р±РµР· СЂРµР°Р»СЊРЅРѕР№ Р°РІС‚РѕСЂРёР·Р°С†РёРё.
  // РќСѓР¶РµРЅ, С‡С‚РѕР±С‹ СЌРєСЂР°РЅ РџСЂРѕС„РёР»СЏ РјРѕРі "РІРѕР№С‚Рё/РІС‹Р№С‚Рё" Рё РІ Р±СѓРґСѓС‰РµРј РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ СЃРёРЅС…СЂРѕРЅРёР·Р°С†РёСЋ.
  bool accountLinked = false;
  String accountEmail = '';
  String accountProvider = ''; // РЅР°РїСЂРёРјРµСЂ: 'email', 'google', 'apple'

  AppSettings({
    this.themeMode = AppThemeMode.light,
    this.languageCode = 'ru',
    this.reminders = const [],
    this.notificationsEnabled = false,
    this.accountLinked = false,
    this.accountEmail = '',
    this.accountProvider = '',
  });
}

enum AppThemeMode {
  light,
  dark,
  system,
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'settings_model.dart';

// **************************************************************************
// IsarCollectionGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: duplicate_ignore, non_constant_identifier_names, constant_identifier_names, invalid_use_of_protected_member, unnecessary_cast, prefer_const_constructors, lines_longer_than_80_chars, require_trailing_commas, inference_failure_on_function_invocation, unnecessary_parenthesis, unnecessary_raw_strings, unnecessary_null_checks, join_return_with_assignment, prefer_final_locals, avoid_js_rounded_ints, avoid_positional_boolean_parameters, always_specify_types

extension GetAppSettingsCollection on Isar {
  IsarCollection<AppSettings> get appSettings => this.collection();
}

const AppSettingsSchema = CollectionSchema(
  name: r'AppSettings',
  id: -5633561779022347008,
  properties: {
    r'accountEmail': PropertySchema(
      id: 0,
      name: r'accountEmail',
      type: IsarType.string,
    ),
    r'accountLinked': PropertySchema(
      id: 1,
      name: r'accountLinked',
      type: IsarType.bool,
    ),
    r'accountProvider': PropertySchema(
      id: 2,
      name: r'accountProvider',
      type: IsarType.string,
    ),
    r'languageCode': PropertySchema(
      id: 3,
      name: r'languageCode',
      type: IsarType.string,
    ),
    r'notificationsEnabled': PropertySchema(
      id: 4,
      name: r'notificationsEnabled',
      type: IsarType.bool,
    ),
    r'reminders': PropertySchema(
      id: 5,
      name: r'reminders',
      type: IsarType.stringList,
    ),
    r'themeMode': PropertySchema(
      id: 6,
      name: r'themeMode',
      type: IsarType.byte,
      enumMap: _AppSettingsthemeModeEnumValueMap,
    )
  },
  estimateSize: _appSettingsEstimateSize,
  serialize: _appSettingsSerialize,
  deserialize: _appSettingsDeserialize,
  deserializeProp: _appSettingsDeserializeProp,
  idName: r'id',
  indexes: {},
  links: {},
  embeddedSchemas: {},
  getId: _appSettingsGetId,
  getLinks: _appSettingsGetLinks,
  attach: _appSettingsAttach,
  version: '3.1.0+1',
);

int _appSettingsEstimateSize(
  AppSettings object,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  var bytesCount = offsets.last;
  bytesCount += 3 + object.accountEmail.length * 3;
  bytesCount += 3 + object.accountProvider.length * 3;
  bytesCount += 3 + object.languageCode.length * 3;
  bytesCount += 3 + object.reminders.length * 3;
  {
    for (var i = 0; i < object.reminders.length; i++) {
      final value = object.reminders[i];
      bytesCount += value.length * 3;
    }
  }
  return bytesCount;
}

void _appSettingsSerialize(
  AppSettings object,
  IsarWriter writer,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  writer.writeString(offsets[0], object.accountEmail);
  writer.writeBool(offsets[1], object.accountLinked);
  writer.writeString(offsets[2], object.accountProvider);
  writer.writeString(offsets[3], object.languageCode);
  writer.writeBool(offsets[4], object.notificationsEnabled);
  writer.writeStringList(offsets[5], object.reminders);
  writer.writeByte(offsets[6], object.themeMode.index);
}

AppSettings _appSettingsDeserialize(
  Id id,
  IsarReader reader,
  List<int> offsets,
  Map<Type, List<int>> allOffsets,
) {
  final object = AppSettings(
    accountEmail: reader.readStringOrNull(offsets[0]) ?? '',
    accountLinked: reader.readBoolOrNull(offsets[1]) ?? false,
    accountProvider: reader.readStringOrNull(offsets[2]) ?? '',
    languageCode: reader.readStringOrNull(offsets[3]) ?? 'ru',
    notificationsEnabled: reader.readBoolOrNull(offsets[4]) ?? false,
    reminders: reader.readStringList(offsets[5]) ?? const [],
    themeMode:
        _AppSettingsthemeModeValueEnumMap[reader.readByteOrNull(offsets[6])] ??
            AppThemeMode.light,
  );
  object.id = id;
  return object;
}

P _appSettingsDeserializeProp<P>(
  IsarReader reader,
  int propertyId,
  int offset,
  Map<Type, List<int>> allOffsets,
) {
  switch (propertyId) {
    case 0:
      return (reader.readStringOrNull(offset) ?? '') as P;
    case 1:
      return (reader.readBoolOrNull(offset) ?? false) as P;
    case 2:
      return (reader.readStringOrNull(offset) ?? '') as P;
    case 3:
      return (reader.readStringOrNull(offset) ?? 'ru') as P;
    case 4:
      return (reader.readBoolOrNull(offset) ?? false) as P;
    case 5:
      return (reader.readStringList(offset) ?? const []) as P;
    case 6:
      return (_AppSettingsthemeModeValueEnumMap[
              reader.readByteOrNull(offset)] ??
          AppThemeMode.light) as P;
    default:
      throw IsarError('Unknown property with id $propertyId');
  }
}

const _AppSettingsthemeModeEnumValueMap = {
  'light': 0,
  'dark': 1,
  'system': 2,
};
const _AppSettingsthemeModeValueEnumMap = {
  0: AppThemeMode.light,
  1: AppThemeMode.dark,
  2: AppThemeMode.system,
};

Id _appSettingsGetId(AppSettings object) {
  return object.id;
}

List<IsarLinkBase<dynamic>> _appSettingsGetLinks(AppSettings object) {
  return [];
}

void _appSettingsAttach(
    IsarCollection<dynamic> col, Id id, AppSettings object) {
  object.id = id;
}

extension AppSettingsQueryWhereSort
    on QueryBuilder<AppSettings, AppSettings, QWhere> {
  QueryBuilder<AppSettings, AppSettings, QAfterWhere> anyId() {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(const IdWhereClause.any());
    });
  }
}

extension AppSettingsQueryWhere
    on QueryBuilder<AppSettings, AppSettings, QWhereClause> {
  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idEqualTo(Id id) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: id,
        upper: id,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idNotEqualTo(
      Id id) {
    return QueryBuilder.apply(this, (query) {
      if (query.whereSort == Sort.asc) {
        return query
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            )
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            );
      } else {
        return query
            .addWhereClause(
              IdWhereClause.greaterThan(lower: id, includeLower: false),
            )
            .addWhereClause(
              IdWhereClause.lessThan(upper: id, includeUpper: false),
            );
      }
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idGreaterThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.greaterThan(lower: id, includeLower: include),
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idLessThan(Id id,
      {bool include = false}) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(
        IdWhereClause.lessThan(upper: id, includeUpper: include),
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterWhereClause> idBetween(
    Id lowerId,
    Id upperId, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addWhereClause(IdWhereClause.between(
        lower: lowerId,
        includeLower: includeLower,
        upper: upperId,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension AppSettingsQueryFilter
    on QueryBuilder<AppSettings, AppSettings, QFilterCondition> {
  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'accountEmail',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'accountEmail',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'accountEmail',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountEmail',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountEmailIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'accountEmail',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountLinkedEqualTo(bool value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountLinked',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'accountProvider',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'accountProvider',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'accountProvider',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'accountProvider',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      accountProviderIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'accountProvider',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idEqualTo(
      Id value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idGreaterThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idLessThan(
    Id value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'id',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition> idBetween(
    Id lower,
    Id upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'id',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'languageCode',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'languageCode',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'languageCode',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'languageCode',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      languageCodeIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'languageCode',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      notificationsEnabledEqualTo(bool value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'notificationsEnabled',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementEqualTo(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementGreaterThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementLessThan(
    String value, {
    bool include = false,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementBetween(
    String lower,
    String upper, {
    bool includeLower = true,
    bool includeUpper = true,
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'reminders',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementStartsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.startsWith(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementEndsWith(
    String value, {
    bool caseSensitive = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.endsWith(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementContains(String value, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.contains(
        property: r'reminders',
        value: value,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementMatches(String pattern, {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.matches(
        property: r'reminders',
        wildcard: pattern,
        caseSensitive: caseSensitive,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'reminders',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersElementIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        property: r'reminders',
        value: '',
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthEqualTo(int length) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        length,
        true,
        length,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersIsEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        0,
        true,
        0,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersIsNotEmpty() {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        0,
        false,
        999999,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthLessThan(
    int length, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        0,
        true,
        length,
        include,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthGreaterThan(
    int length, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        length,
        include,
        999999,
        true,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      remindersLengthBetween(
    int lower,
    int upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.listLength(
        r'reminders',
        lower,
        includeLower,
        upper,
        includeUpper,
      );
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeEqualTo(AppThemeMode value) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.equalTo(
        property: r'themeMode',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeGreaterThan(
    AppThemeMode value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.greaterThan(
        include: include,
        property: r'themeMode',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeLessThan(
    AppThemeMode value, {
    bool include = false,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.lessThan(
        include: include,
        property: r'themeMode',
        value: value,
      ));
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterFilterCondition>
      themeModeBetween(
    AppThemeMode lower,
    AppThemeMode upper, {
    bool includeLower = true,
    bool includeUpper = true,
  }) {
    return QueryBuilder.apply(this, (query) {
      return query.addFilterCondition(FilterCondition.between(
        property: r'themeMode',
        lower: lower,
        includeLower: includeLower,
        upper: upper,
        includeUpper: includeUpper,
      ));
    });
  }
}

extension AppSettingsQueryObject
    on QueryBuilder<AppSettings, AppSettings, QFilterCondition> {}

extension AppSettingsQueryLinks
    on QueryBuilder<AppSettings, AppSettings, QFilterCondition> {}

extension AppSettingsQuerySortBy
    on QueryBuilder<AppSettings, AppSettings, QSortBy> {
  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByAccountEmail() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByAccountEmailDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByAccountLinked() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByAccountLinkedDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByAccountProvider() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByAccountProviderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByLanguageCode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByLanguageCodeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByNotificationsEnabled() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      sortByNotificationsEnabledDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByThemeMode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> sortByThemeModeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.desc);
    });
  }
}

extension AppSettingsQuerySortThenBy
    on QueryBuilder<AppSettings, AppSettings, QSortThenBy> {
  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByAccountEmail() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByAccountEmailDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountEmail', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByAccountLinked() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByAccountLinkedDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountLinked', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByAccountProvider() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByAccountProviderDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'accountProvider', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenById() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByIdDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'id', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByLanguageCode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByLanguageCodeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'languageCode', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByNotificationsEnabled() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy>
      thenByNotificationsEnabledDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'notificationsEnabled', Sort.desc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByThemeMode() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.asc);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QAfterSortBy> thenByThemeModeDesc() {
    return QueryBuilder.apply(this, (query) {
      return query.addSortBy(r'themeMode', Sort.desc);
    });
  }
}

extension AppSettingsQueryWhereDistinct
    on QueryBuilder<AppSettings, AppSettings, QDistinct> {
  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByAccountEmail(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'accountEmail', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByAccountLinked() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'accountLinked');
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByAccountProvider(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'accountProvider',
          caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByLanguageCode(
      {bool caseSensitive = true}) {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'languageCode', caseSensitive: caseSensitive);
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct>
      distinctByNotificationsEnabled() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'notificationsEnabled');
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByReminders() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'reminders');
    });
  }

  QueryBuilder<AppSettings, AppSettings, QDistinct> distinctByThemeMode() {
    return QueryBuilder.apply(this, (query) {
      return query.addDistinctBy(r'themeMode');
    });
  }
}

extension AppSettingsQueryProperty
    on QueryBuilder<AppSettings, AppSettings, QQueryProperty> {
  QueryBuilder<AppSettings, int, QQueryOperations> idProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'id');
    });
  }

  QueryBuilder<AppSettings, String, QQueryOperations> accountEmailProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'accountEmail');
    });
  }

  QueryBuilder<AppSettings, bool, QQueryOperations> accountLinkedProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'accountLinked');
    });
  }

  QueryBuilder<AppSettings, String, QQueryOperations>
      accountProviderProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'accountProvider');
    });
  }

  QueryBuilder<AppSettings, String, QQueryOperations> languageCodeProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'languageCode');
    });
  }

  QueryBuilder<AppSettings, bool, QQueryOperations>
      notificationsEnabledProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'notificationsEnabled');
    });
  }

  QueryBuilder<AppSettings, List<String>, QQueryOperations>
      remindersProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'reminders');
    });
  }

  QueryBuilder<AppSettings, AppThemeMode, QQueryOperations>
      themeModeProperty() {
    return QueryBuilder.apply(this, (query) {
      return query.addPropertyName(r'themeMode');
    });
  }
}
// settings_cubit.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:in_app_review/in_app_review.dart';
import 'package:url_launcher/url_launcher.dart';

import 'package:blood_pressure_diary/core/database/isar_service.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';
import 'package:blood_pressure_diary/core/repositories/pressure_repository.dart';
import 'package:blood_pressure_diary/core/services/export_service.dart';
import 'package:blood_pressure_diary/core/services/notification_service.dart';
import 'package:blood_pressure_diary/features/settings/data/models/settings_model.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_state.dart';

class SettingsCubit extends Cubit<SettingsState> {
  final IsarService _isarService;
  final PressureRepository _pressureRepository;
  final ExportService _exportService;
  final NotificationService _notificationService;

  StreamSubscription<AppSettings>? _settingsSub;

  SettingsCubit(
      this._isarService,
      this._pressureRepository,
      this._exportService,
      this._notificationService,
      ) : super(SettingsState(AppSettings())) {
    _bind();
  }

  Future<void> _bind() async {
    await _isarService.getOrCreateSettings();

    await _settingsSub?.cancel();
    _settingsSub = _isarService.watchSettings().listen((settings) {
      emit(SettingsState(
        settings,
        errorMessage: state.errorMessage,
        isExporting: state.isExporting,
      ));
    });
  }

  @override
  Future<void> close() async {
    await _settingsSub?.cancel();
    return super.close();
  }

  Future<void> changeLanguage(String langCode) async {
    final s = state.settings;
    final updated = AppSettings(
      themeMode: s.themeMode,
      languageCode: langCode,
      reminders: s.reminders,
      notificationsEnabled: s.notificationsEnabled,
      accountLinked: s.accountLinked,
      accountEmail: s.accountEmail,
      accountProvider: s.accountProvider,
    );
    await _isarService.saveSettings(updated);
  }

  Future<void> setThemeMode(AppThemeMode mode) async {
    final s = state.settings;
    final updated = AppSettings(
      themeMode: mode, // вњ… Р’РћРў Р­РўРћ Рё Р»РѕРјР°Р»Рѕ РїРµСЂРµРєР»СЋС‡РµРЅРёРµ
      languageCode: s.languageCode,
      reminders: s.reminders,
      notificationsEnabled: s.notificationsEnabled,
      accountLinked: s.accountLinked,
      accountEmail: s.accountEmail,
      accountProvider: s.accountProvider,
    );
    await _isarService.saveSettings(updated);
  }

  Future<void> addReminder(TimeOfDay time) async {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    final timeStr = '$hour:$minute';

    final s = state.settings;
    if (s.reminders.contains(timeStr)) return;

    final newList = List<String>.from(s.reminders)..add(timeStr);
    newList.sort();

    final updated = AppSettings(
      themeMode: s.themeMode,
      languageCode: s.languageCode,
      reminders: newList,
      notificationsEnabled: s.notificationsEnabled,
      accountLinked: s.accountLinked,
      accountEmail: s.accountEmail,
      accountProvider: s.accountProvider,
    );

    await _isarService.saveSettings(updated);

    if (s.notificationsEnabled) {
      await _notificationService.scheduleDailyNotification(timeStr.hashCode, time);
    }
  }

  Future<void> removeReminder(int index) async {
    final s = state.settings;
    if (index < 0 || index >= s.reminders.length) return;

    final timeStr = s.reminders[index];
    final newList = List<String>.from(s.reminders)..removeAt(index);

    final updated = AppSettings(
      themeMode: s.themeMode,
      languageCode: s.languageCode,
      reminders: newList,
      notificationsEnabled: s.notificationsEnabled,
      accountLinked: s.accountLinked,
      accountEmail: s.accountEmail,
      accountProvider: s.accountProvider,
    );

    await _isarService.saveSettings(updated);

    if (s.notificationsEnabled) {
      await _notificationService.cancelNotification(timeStr.hashCode);
    }
  }

  Future<void> toggleNotifications(bool enabled) async {
    final s = state.settings;

    if (enabled) {
      final granted = await _notificationService.requestPermissions();
      if (!granted) {
        final message = s.languageCode == 'ru'
            ? 'Р Р°Р·СЂРµС€РµРЅРёРµ РЅР° СѓРІРµРґРѕРјР»РµРЅРёСЏ РЅРµ РїРѕР»СѓС‡РµРЅРѕ'
            : 'Notification permission not granted';
        emit(state.copyWith(errorMessage: message));
        emit(state.copyWith(errorMessage: null));
        return;
      }
    }

    final reminders = (enabled && s.reminders.isEmpty)
        ? <String>['08:00', '20:00']
        : List<String>.from(s.reminders);

    reminders.sort();

    final updated = AppSettings(
      themeMode: s.themeMode,
      languageCode: s.languageCode,
      reminders: reminders,
      notificationsEnabled: enabled,
      accountLinked: s.accountLinked,
      accountEmail: s.accountEmail,
      accountProvider: s.accountProvider,
    );

    await _isarService.saveSettings(updated);

    if (enabled) {
      await _syncAllNotifications(reminders);
    } else {
      await _notificationService.cancelAllNotifications();
    }
  }

  Future<void> _syncAllNotifications(List<String> reminders) async {
    await _notificationService.cancelAllNotifications();

    for (final timeStr in reminders) {
      final parts = timeStr.split(':');
      final time = TimeOfDay(
        hour: int.parse(parts[0]),
        minute: int.parse(parts[1]),
      );
      await _notificationService.scheduleDailyNotification(timeStr.hashCode, time);
    }
  }

  /// periodDays РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ РґР»СЏ PDF (РЅР°РїСЂРёРјРµСЂ, 14 РґРЅРµР№), РґР»СЏ CSV РјРѕР¶РЅРѕ РїРµСЂРµРґР°РІР°С‚СЊ 0.
  Future<void> exportData(ExportFormat format, {int pdfPeriodDays = 14}) async {
    final records = await _pressureRepository.getAllRecords();

    if (records.isEmpty) {
      final message = state.settings.languageCode == 'ru'
          ? 'РќРµС‚ РґР°РЅРЅС‹С… РґР»СЏ СЌРєСЃРїРѕСЂС‚Р°'
          : 'No data to export';
      emit(state.copyWith(errorMessage: message));
      emit(state.copyWith(errorMessage: null));
      return;
    }

    UserProfile? profile;
    try {
      profile = await _isarService.getOrCreateProfile();
    } catch (_) {
      profile = null;
    }

    emit(state.copyWith(isExporting: true));
    try {
      await _exportService.exportData(
        records,
        format,
        state.settings.languageCode,
        profile: profile,
        periodDays: format == ExportFormat.pdf ? pdfPeriodDays : 0,
      );
    } catch (e) {
      final message = state.settings.languageCode == 'ru'
          ? 'РћС€РёР±РєР° РїСЂРё СЌРєСЃРїРѕСЂС‚Рµ: $e'
          : 'Export error: $e';
      emit(state.copyWith(errorMessage: message));
      emit(state.copyWith(errorMessage: null));
    } finally {
      emit(state.copyWith(isExporting: false));
    }
  }

  Future<void> clearAllData() async {
    await _pressureRepository.deleteAllRecords();
  }

  Future<void> contactSupport() async {
    final Uri emailLaunchUri = Uri(
      scheme: 'mailto',
      path: 'your_email@mail.com',
      query: 'subject=Blood Pressure Diary Feedback',
    );
    if (await canLaunchUrl(emailLaunchUri)) {
      await launchUrl(emailLaunchUri);
    }
  }

  Future<void> rateApp() async {
    final inAppReview = InAppReview.instance;
    if (await inAppReview.isAvailable()) {
      await inAppReview.requestReview();
    }
  }
}
import 'package:equatable/equatable.dart';
import '../../data/models/settings_model.dart';

class SettingsState extends Equatable {
  final AppSettings settings;
  final String? errorMessage;
  final bool isExporting;

  const SettingsState(this.settings, {this.errorMessage, this.isExporting = false});

  SettingsState copyWith({
    AppSettings? settings,
    String? errorMessage,
    bool? isExporting,
  }) {
    return SettingsState(
      settings ?? this.settings,
      errorMessage: errorMessage,
      isExporting: isExporting ?? this.isExporting,
    );
  }

  @override
  List<Object?> get props => [
    settings.themeMode,
    settings.languageCode,
    settings.notificationsEnabled,
    settings.reminders.join('|'),
    settings.accountLinked,
    settings.accountEmail,
    settings.accountProvider,
    errorMessage,
    isExporting,
  ];
}
// settings_screen.dart (РїРѕР»РЅР°СЏ Р·Р°РјРµРЅР° вЂ” РІС‹Р±РѕСЂ РїРµСЂРёРѕРґР° PDF + Privacy Policy + РІСЃС‘ РѕСЃС‚Р°Р»СЊРЅРѕРµ Р±РµР· РёР·РјРµРЅРµРЅРёР№)
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:blood_pressure_diary/core/services/export_service.dart';
import 'package:blood_pressure_diary/core/services/backup_service.dart';
import 'package:blood_pressure_diary/core/database/isar_service.dart';
import 'package:blood_pressure_diary/core/di/service_locator.dart';
import 'package:blood_pressure_diary/core/theme/app_theme.dart';
import 'package:blood_pressure_diary/core/theme/scale.dart';
import 'package:blood_pressure_diary/features/settings/data/models/settings_model.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_cubit.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_state.dart';
import 'package:blood_pressure_diary/l10n/generated/app_localizations.dart';
import 'package:blood_pressure_diary/core/utils/launcher_utils.dart';

import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:file_picker/file_picker.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  double _contentBottomInset(BuildContext context) {
    final s = context.appSpace;
    final safeBottom = MediaQuery.paddingOf(context).bottom;
    // Bottom bar in AppNavigation: barH (69) + lift (43) = 112 (tokens-based)
    final barH = dp(context, s.s72 - s.s2 - s.s1);
    final outer = dp(context, s.s80 + s.s6);
    final lift = outer / 2;
    return barH + lift + safeBottom + dp(context, s.s12);
  }

  Future<void> _runBlocking(BuildContext context, Future<void> Function() action) async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      await action();
    } finally {
      if (context.mounted) Navigator.pop(context);
    }
  }

  Future<void> _backupToJson(BuildContext context) async {
    final isar = getIt<IsarService>();
    final backupService = BackupService(isar);

    await _runBlocking(context, () async {
      final json = await backupService.createBackupJson();

      final dir = await getTemporaryDirectory();
      final ts = DateTime.now().toIso8601String().replaceAll(':', '-');
      final file = File('${dir.path}/pressure_diary_backup_$ts.json');
      await file.writeAsString(json, flush: true);

      await Share.shareXFiles(
        [XFile(file.path)],
        text: 'Pressure Diary backup (JSON)',
      );
    });
  }

  Future<void> _restoreFromJson(BuildContext context) async {
    final isar = getIt<IsarService>();
    final backupService = BackupService(isar);

    final result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: const ['json'],
      withData: false,
    );

    if (result == null || result.files.isEmpty) return;
    final path = result.files.first.path;
    if (path == null) return;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Р’РѕСЃСЃС‚Р°РЅРѕРІР»РµРЅРёРµ РёР· РєРѕРїРёРё'),
        content: const Text(
          'Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ Р·Р°РјРµРЅРёС‚ РІСЃРµ С‚РµРєСѓС‰РёРµ РґР°РЅРЅС‹Рµ РїСЂРёР»РѕР¶РµРЅРёСЏ (РїСЂРѕС„РёР»СЊ, РЅР°СЃС‚СЂРѕР№РєРё Рё Р·Р°РїРёСЃРё РґР°РІР»РµРЅРёСЏ). РџСЂРѕРґРѕР»Р¶РёС‚СЊ?',
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('РћС‚РјРµРЅР°')),
          TextButton(onPressed: () => Navigator.pop(context, true), child: const Text('Р’РѕСЃСЃС‚Р°РЅРѕРІРёС‚СЊ')),
        ],
      ),
    );

    if (confirmed != true) return;

    await _runBlocking(context, () async {
      final jsonText = await File(path).readAsString();
      await backupService.restoreFromJson(jsonText);
    });

    if (!context.mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Р”Р°РЅРЅС‹Рµ РІРѕСЃСЃС‚Р°РЅРѕРІР»РµРЅС‹')),
    );
  }

  Future<int?> _showPdfPeriodSheet(BuildContext context, AppLocalizations l10n) {
    final isRu = Localizations.localeOf(context).languageCode == 'ru';

    return showModalBottomSheet<int>(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) {
        Widget item(int days, String title) {
          return ListTile(
            title: Text(title),
            onTap: () => Navigator.pop(ctx, days),
          );
        }

        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Text(
                  l10n.exportPDF,
                  style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
              ),
              item(3, isRu ? '3 РґРЅСЏ (Free)' : '3 days (Free)'),
              item(14, isRu ? '14 РґРЅРµР№' : '14 days'),
              item(30, isRu ? '30 РґРЅРµР№' : '30 days'),
              item(90, isRu ? '90 РґРЅРµР№' : '90 days'),
              const SizedBox(height: 8),
            ],
          ),
        );
      },
    );
  }

  void _showPrivacyPolicy(BuildContext context, AppLocalizations l10n) {
    final isRu = Localizations.localeOf(context).languageCode == 'ru';

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) {
        return SafeArea(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    isRu ? 'РџРѕР»РёС‚РёРєР° РєРѕРЅС„РёРґРµРЅС†РёР°Р»СЊРЅРѕСЃС‚Рё' : 'Privacy Policy',
                    style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    isRu
                        ? '1) РџСЂРёР»РѕР¶РµРЅРёРµ С…СЂР°РЅРёС‚ РёР·РјРµСЂРµРЅРёСЏ РґР°РІР»РµРЅРёСЏ Рё РЅР°СЃС‚СЂРѕР№РєРё Р»РѕРєР°Р»СЊРЅРѕ РЅР° РІР°С€РµРј СѓСЃС‚СЂРѕР№СЃС‚РІРµ.\n\n'
                        '2) Р•СЃР»Рё РІС‹ СѓРєР°Р·С‹РІР°РµС‚Рµ e-mail, РѕРЅ РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ С‚РѕР»СЊРєРѕ РґР»СЏ РѕС‚РїСЂР°РІРєРё РѕС‚С‡С‘С‚РѕРІ Рё СЂРµР·РµСЂРІРЅС‹С… РєРѕРїРёР№ РїРѕ РІР°С€РµРјСѓ Р·Р°РїСЂРѕСЃСѓ.\n\n'
                        '3) РњС‹ РЅРµ РїРµСЂРµРґР°С‘Рј РІР°С€Рё РјРµРґРёС†РёРЅСЃРєРёРµ РґР°РЅРЅС‹Рµ С‚СЂРµС‚СЊРёРј Р»РёС†Р°Рј Рё РЅРµ РёСЃРїРѕР»СЊР·СѓРµРј РёС… РґР»СЏ СЂРµРєР»Р°РјС‹.\n\n'
                        '4) РЈРІРµРґРѕРјР»РµРЅРёСЏ РёСЃРїРѕР»СЊР·СѓСЋС‚СЃСЏ С‚РѕР»СЊРєРѕ РґР»СЏ РЅР°РїРѕРјРёРЅР°РЅРёР№ РѕР± РёР·РјРµСЂРµРЅРёСЏС… (РµСЃР»Рё РІС‹ РёС… РІРєР»СЋС‡РёР»Рё).'
                        : '1) The app stores blood pressure measurements and settings locally on your device.\n\n'
                        '2) If you provide an email, it is used only to send reports and backups upon your request.\n\n'
                        '3) We do not share your health data with third parties and do not use it for advertising.\n\n'
                        '4) Notifications are used only for measurement reminders (if enabled).',
                    style: const TextStyle(fontSize: 14),
                  ),
                  const SizedBox(height: 24),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    final isDark = Theme.of(context).brightness == Brightness.dark;

    final colors = context.appColors;
    final space = context.appSpace;
    final radii = context.appRadii;
    final shadows = context.appShadow;
    final text = context.appText;

    final safeTop = MediaQuery.paddingOf(context).top;

    final headerH = dp(context, space.s128);
    final side = dp(context, space.s20);

    final cardR = dp(context, radii.r10);

    final fieldH = dp(context, space.s48);

    final h47 = dp(context, space.s46 + space.s1); // 47
    final h92 = dp(context, space.s80 + space.s12); // 92

    final h43 = dp(context, space.s40 + space.s2 + space.s1);
    final h44 = dp(context, space.s40 + space.s4);

    final gap16 = dp(context, space.s16);
    final gap8 = dp(context, space.s8);

    final headerBg = isDark ? AppPalette.dark800 : AppPalette.blue700;
    final titleColor = isDark ? colors.textPrimary : colors.textOnBrand;

    final cardBg = colors.surface;
    final fieldBg = isDark ? colors.surfaceAlt : colors.background;

    final trackOn = isDark ? AppPalette.dark800 : AppPalette.blue900;
    final trackOff = isDark ? AppPalette.dark800 : AppPalette.grey200;
    final knobOn = isDark ? AppPalette.dark400 : colors.surface;
    final knobOff = isDark ? AppPalette.dark400 : colors.surface;

    final overlayColor = colors.textPrimary.withValues(alpha: 0.10);

    final titleStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs24),
      fontWeight: text.w600,
      color: titleColor,
      height: 1.0,
    );

    final cardTitleStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs20),
      fontWeight: text.w600,
      color: colors.textPrimary,
      height: 1.0,
    );

    final labelStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs14),
      fontWeight: text.w400,
      color: colors.textPrimary,
      height: 1.0,
    );

    final itemStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs20),
      fontWeight: text.w500,
      color: colors.textPrimary,
      height: 1.0,
    );

    final addStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs16),
      fontWeight: text.w600,
      color: colors.textPrimary,
      height: 1.0,
    );

    final versionStyle = TextStyle(
      fontFamily: text.family,
      fontSize: sp(context, text.fs12),
      fontWeight: text.w400,
      color: colors.textPrimary,
      height: 1.0,
    );

    Future<TimeOfDay?> _pickTimeInput(BuildContext context) {
      return showTimePicker(
        context: context,
        initialTime: TimeOfDay.now(),
        initialEntryMode: TimePickerEntryMode.input,
        builder: (ctx, child) {
          return MediaQuery(
            data: MediaQuery.of(ctx).copyWith(alwaysUse24HourFormat: true),
            child: child ?? const SizedBox.shrink(),
          );
        },
      );
    }

    return BlocListener<SettingsCubit, SettingsState>(
      listener: (context, state) {
        final msg = state.errorMessage;
        if (msg == null) return;

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(msg),
            backgroundColor: colors.danger,
          ),
        );
      },
      child: BlocBuilder<SettingsCubit, SettingsState>(
        builder: (context, state) {
          final s = state.settings;
          final enabled = s.notificationsEnabled;

          Future<void> pickAndAddTime() async {
            final picked = await _pickTimeInput(context);
            if (picked != null && context.mounted) {
              context.read<SettingsCubit>().addReminder(picked);
            }
          }

          Future<void> pickReplaceAt(int index) async {
            final picked = await _pickTimeInput(context);
            if (picked == null || !context.mounted) return;

            if (s.reminders.length > index) {
              await context.read<SettingsCubit>().removeReminder(index);
            }
            if (context.mounted) {
              context.read<SettingsCubit>().addReminder(picked);
            }
          }

          void removeAt(int index) {
            if (index < 0 || index >= s.reminders.length) return;
            context.read<SettingsCubit>().removeReminder(index);
          }

          Widget cardAuto({required Widget child}) {
            return SizedBox(
              width: double.infinity,
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: cardBg,
                  borderRadius: BorderRadius.circular(cardR),
                  boxShadow: [shadows.card],
                ),
                child: child,
              ),
            );
          }

          Widget cardFixed({required double height, required Widget child}) {
            return SizedBox(
              width: double.infinity,
              height: height,
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: cardBg,
                  borderRadius: BorderRadius.circular(cardR),
                  boxShadow: [shadows.card],
                ),
                child: child,
              ),
            );
          }

          Widget timeValueBox({required String value, required double height}) {
            return Container(
              width: dp(context, space.s120 + space.s16 + space.s1), // 137
              height: height,
              decoration: BoxDecoration(
                color: fieldBg,
                borderRadius: BorderRadius.circular(cardR),
              ),
              padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
              alignment: Alignment.centerRight,
              child: Text(value, style: itemStyle),
            );
          }

          Widget minusButton({
            required double rowHeight,
            required VoidCallback onTap,
          }) {
            final hit = dp(context, space.s32); // 32
            final iconSize = dp(context, space.s20);
            final bg = fieldBg.withValues(alpha: 0.60);
            final fg = colors.textPrimary;

            return GestureDetector(
              behavior: HitTestBehavior.opaque,
              onTap: onTap,
              child: SizedBox(
                width: hit,
                height: rowHeight,
                child: Center(
                  child: Container(
                    width: hit,
                    height: hit,
                    decoration: BoxDecoration(
                      color: bg,
                      borderRadius: BorderRadius.circular(dp(context, space.s6)),
                    ),
                    child: Icon(
                      Icons.remove_circle_outline,
                      size: iconSize,
                      color: fg,
                    ),
                  ),
                ),
              ),
            );
          }

          Widget remindersInnerBox() {
            final borderColor = fieldBg;
            final borderW = dp(context, space.s1);

            final labelLeftPad = dp(context, space.s12);
            final betweenRows = dp(context, space.s4);
            final betweenMinusAndField = dp(context, space.s6);

            String labelForIndex(int i) {
              if (i == 0) return 'РЈС‚СЂРѕ';
              if (i == 1) return 'Р’РµС‡РµСЂ';
              return 'Р’СЂРµРјСЏ';
            }

            double rowHeightForIndex(int i) => i == 0 ? h43 : h44;

            Widget row({
              required int index,
              required String label,
              required String value,
              required double h,
            }) {
              final removable = index >= 1 && enabled;

              return SizedBox(
                height: h,
                child: Row(
                  children: [
                    Expanded(
                      child: Padding(
                        padding: EdgeInsets.only(left: labelLeftPad),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Text(label, style: itemStyle),
                        ),
                      ),
                    ),
                    if (removable) ...[
                      minusButton(rowHeight: h, onTap: () => removeAt(index)),
                      SizedBox(width: betweenMinusAndField),
                    ],
                    GestureDetector(
                      behavior: HitTestBehavior.opaque,
                      onTap: () => pickReplaceAt(index),
                      child: timeValueBox(value: value, height: h),
                    ),
                  ],
                ),
              );
            }

            return Opacity(
              opacity: enabled ? 1.0 : 0.55,
              child: Container(
                width: double.infinity,
                decoration: BoxDecoration(
                  border: Border.all(color: borderColor, width: borderW),
                  borderRadius: BorderRadius.circular(cardR),
                ),
                padding: EdgeInsets.all(dp(context, space.s2)),
                child: Column(
                  children: [
                    if (s.reminders.isEmpty) ...[
                      row(index: 0, label: 'РЈС‚СЂРѕ', value: '08:00', h: h43),
                      SizedBox(height: betweenRows),
                      row(index: 1, label: 'Р’РµС‡РµСЂ', value: '20:00', h: h44),
                    ] else ...[
                      for (int i = 0; i < s.reminders.length; i++) ...[
                        row(
                          index: i,
                          label: labelForIndex(i),
                          value: s.reminders[i],
                          h: rowHeightForIndex(i),
                        ),
                        if (i != s.reminders.length - 1) SizedBox(height: betweenRows),
                      ],
                    ],
                  ],
                ),
              ),
            );
          }

          Widget remindersCard() {
            return cardAuto(
              child: Padding(
                padding: EdgeInsets.all(dp(context, space.s12)),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    SizedBox(
                      height: dp(context, space.s24),
                      child: Row(
                        children: [
                          Expanded(
                            child: Align(
                              alignment: Alignment.centerLeft,
                              child: Text(l10n.reminders, style: cardTitleStyle),
                            ),
                          ),
                          _FigmaSwitch(
                            value: enabled,
                            onChanged: (v) => context.read<SettingsCubit>().toggleNotifications(v),
                            trackOn: trackOn,
                            trackOff: trackOff,
                            knobOn: knobOn,
                            knobOff: knobOff,
                            space: space,
                          ),
                        ],
                      ),
                    ),
                    SizedBox(height: dp(context, space.s10)),
                    remindersInnerBox(),
                    SizedBox(height: dp(context, space.s10)),
                    Align(
                      alignment: Alignment.centerRight,
                      child: Opacity(
                        opacity: enabled ? 1.0 : 0.55,
                        child: GestureDetector(
                          behavior: HitTestBehavior.opaque,
                          onTap: pickAndAddTime,
                          child: Padding(
                            padding: EdgeInsets.only(right: dp(context, space.s6)),
                            child: Text('+${l10n.addReminder.toUpperCase()}', style: addStyle),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          }

          Widget themeCard() {
            return GestureDetector(
              behavior: HitTestBehavior.opaque,
              onTap: () async {
                final chosen = await _showThemeSheet(context, l10n, s.themeMode);
                if (chosen != null && context.mounted) {
                  context.read<SettingsCubit>().setThemeMode(chosen);
                }
              },
              child: cardFixed(
                height: h92,
                child: Padding(
                  padding: EdgeInsets.all(dp(context, space.s12)),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(l10n.theme, style: labelStyle),
                      SizedBox(height: dp(context, space.s6)),
                      Container(
                        width: double.infinity,
                        height: fieldH,
                        decoration: BoxDecoration(
                          color: fieldBg,
                          borderRadius: BorderRadius.circular(cardR),
                        ),
                        padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
                        child: Row(
                          children: [
                            Expanded(child: Text(_themeTitle(s.themeMode, l10n), style: itemStyle)),
                            Icon(
                              Icons.keyboard_arrow_down,
                              color: colors.textPrimary,
                              size: dp(context, space.s20),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            );
          }

          Future<String?> _showLanguageSheet(
              BuildContext context,
              AppLocalizations l10n,
              String current,
              ) {
            return showModalBottomSheet<String>(
              context: context,
              builder: (_) {
                Widget item(String code, String title) {
                  return ListTile(
                    title: Text(title),
                    trailing: current == code ? const Icon(Icons.check) : null,
                    onTap: () => Navigator.of(context).pop(code),
                  );
                }

                return SafeArea(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      item('ru', 'Р СѓСЃСЃРєРёР№'),
                      item('en', 'English'),
                    ],
                  ),
                );
              },
            );
          }

          Widget languageCard() {
            final s = state.settings;

            String title;
            switch (s.languageCode) {
              case 'ru':
                title = 'Р СѓСЃСЃРєРёР№';
                break;
              case 'en':
                title = 'English';
                break;
              default:
                title = 'English';
            }

            return InkWell(
              borderRadius: BorderRadius.circular(cardR),
              onTap: () async {
                final chosen = await _showLanguageSheet(context, l10n, s.languageCode);
                if (!context.mounted) return;
                if (chosen != null && chosen != s.languageCode) {
                  context.read<SettingsCubit>().changeLanguage(chosen);
                }
              },
              child: Container(
                decoration: BoxDecoration(
                  color: cardBg,
                  borderRadius: BorderRadius.circular(cardR),
                  boxShadow: [shadows.card],
                ),
                child: Padding(
                  padding: EdgeInsets.all(dp(context, space.s12)),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(l10n.language, style: labelStyle),
                      SizedBox(height: dp(context, space.s6)),
                      Container(
                        width: double.infinity,
                        height: fieldH,
                        decoration: BoxDecoration(
                          color: fieldBg,
                          borderRadius: BorderRadius.circular(cardR),
                        ),
                        padding: EdgeInsets.symmetric(horizontal: dp(context, space.s12)),
                        child: Row(
                          children: [
                            Expanded(child: Text(title, style: itemStyle)),
                            Icon(
                              Icons.keyboard_arrow_down,
                              color: colors.textPrimary,
                              size: dp(context, space.s20),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            );
          }

          Widget actionButton({required String title, required VoidCallback onTap}) {
            return GestureDetector(
              behavior: HitTestBehavior.opaque,
              onTap: onTap,
              child: SizedBox(
                width: double.infinity,
                height: h47,
                child: DecoratedBox(
                  decoration: BoxDecoration(
                    color: cardBg,
                    borderRadius: BorderRadius.circular(cardR),
                    boxShadow: [shadows.card],
                  ),
                  child: Padding(
                    padding: EdgeInsets.symmetric(horizontal: dp(context, space.s16)),
                    child: Align(
                      alignment: Alignment.centerLeft,
                      child: Text(title, style: itemStyle),
                    ),
                  ),
                ),
              ),
            );
          }

          return Scaffold(
            backgroundColor: colors.background,
            body: Stack(
              children: [
                Positioned(
                  left: 0,
                  right: 0,
                  top: 0,
                  height: headerH,
                  child: DecoratedBox(
                    decoration: BoxDecoration(
                      color: headerBg,
                      boxShadow: [shadows.strong],
                    ),
                  ),
                ),
                Positioned(
                  left: side,
                  top: safeTop + dp(context, space.s20) + dp(context, space.s10),
                  child: Text(l10n.settings, style: titleStyle),
                ),
                Positioned.fill(
                  top: safeTop + headerH - dp(context, space.s20),
                  child: SingleChildScrollView(
                    padding: EdgeInsets.only(
                      left: side,
                      right: side,
                      top: gap16,
                      bottom: _contentBottomInset(context),
                    ),
                    child: Column(
                      children: [
                        remindersCard(),
                        SizedBox(height: gap16),
                        themeCard(),
                        SizedBox(height: gap16),
                        languageCard(),
                        SizedBox(height: gap16),
                        actionButton(title: 'Р РµР·РµСЂРІРЅР°СЏ РєРѕРїРёСЏ (JSON)', onTap: () => _backupToJson(context)),
                        SizedBox(height: gap8),
                        actionButton(title: 'Р’РѕСЃСЃС‚Р°РЅРѕРІРёС‚СЊ РёР· РєРѕРїРёРё', onTap: () => _restoreFromJson(context)),
                        SizedBox(height: gap8),
                        actionButton(title: l10n.clearData, onTap: () => _showClearDataDialog(context, l10n)),
                        SizedBox(height: gap8),
                        actionButton(
                          title: l10n.export,
                          onTap: state.isExporting ? () {} : () => _showExportBottomSheet(context, l10n),
                        ),
                        SizedBox(height: gap8),
                        actionButton(
                          title: l10n.contactSupport,
                          onTap: () async {
                            await launchEmail(
                              to: 'resistor.rs@gmail.com',
                              subject: 'Pressure Diary вЂ” РѕР±СЂР°С‚РЅР°СЏ СЃРІСЏР·СЊ',
                              body: 'РћРїРёС€РёС‚Рµ РїСЂРѕР±Р»РµРјСѓ РёР»Рё РїСЂРµРґР»РѕР¶РµРЅРёРµ.\n',
                            );
                          },
                        ),
                        SizedBox(height: gap8),
                        actionButton(
                          title: l10n.rateApp,
                          onTap: () async {
                            await rateApp(androidPackageName: 'com.dmitry.blood_pressure_diary');
                          },
                        ),
                        SizedBox(height: gap8),
                        actionButton(
                          title: Localizations.localeOf(context).languageCode == 'ru'
                              ? 'РџРѕР»РёС‚РёРєР° РєРѕРЅС„РёРґРµРЅС†РёР°Р»СЊРЅРѕСЃС‚Рё'
                              : 'Privacy Policy',
                          onTap: () => _showPrivacyPolicy(context, l10n),
                        ),
                        SizedBox(height: gap8),
                        Center(child: Text(l10n.version('1.0.0'), style: versionStyle)),
                      ],
                    ),
                  ),
                ),
                if (state.isExporting)
                  Positioned.fill(
                    child: ColoredBox(
                      color: overlayColor,
                      child: const Center(child: CircularProgressIndicator()),
                    ),
                  ),
              ],
            ),
          );
        },
      ),
    );
  }

  String _themeTitle(AppThemeMode mode, AppLocalizations l10n) {
    switch (mode) {
      case AppThemeMode.light:
        return l10n.light;
      case AppThemeMode.dark:
        return l10n.dark;
      case AppThemeMode.system:
        return l10n.system;
    }
  }

  Future<AppThemeMode?> _showThemeSheet(BuildContext context, AppLocalizations l10n, AppThemeMode current) {
    return showModalBottomSheet<AppThemeMode>(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) {
        Widget item(AppThemeMode mode, String title) {
          final selected = mode == current;
          return ListTile(
            title: Text(title),
            trailing: selected ? const Icon(Icons.check) : null,
            onTap: () => Navigator.pop(ctx, mode),
          );
        }

        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              item(AppThemeMode.system, l10n.system),
              item(AppThemeMode.light, l10n.light),
              item(AppThemeMode.dark, l10n.dark),
              const SizedBox(height: 8),
            ],
          ),
        );
      },
    );
  }

  void _showExportBottomSheet(BuildContext context, AppLocalizations l10n) {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(l10n.export, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            ),
            ListTile(
              leading: const Icon(Icons.picture_as_pdf_outlined),
              title: Text(l10n.exportPDF),
              onTap: () async {
                Navigator.pop(context);
                final days = await _showPdfPeriodSheet(context, l10n);
                if (days == null || !context.mounted) return;
                await Future.delayed(const Duration(milliseconds: 150));
                await context.read<SettingsCubit>().exportData(ExportFormat.pdf, pdfPeriodDays: days);
              },
            ),
            ListTile(
              leading: const Icon(Icons.description_outlined),
              title: Text(l10n.exportCSV),
              onTap: () async {
                Navigator.pop(context);
                await Future.delayed(const Duration(milliseconds: 150));
                await context.read<SettingsCubit>().exportData(ExportFormat.csv);
              },
            ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }

  void _showClearDataDialog(BuildContext context, AppLocalizations l10n) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.clearData),
        content: Text(l10n.clearDataConfirm),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(l10n.no)),
          TextButton(
            onPressed: () {
              context.read<SettingsCubit>().clearAllData();
              Navigator.pop(ctx);
            },
            child: Text(l10n.yes),
          ),
        ],
      ),
    );
  }
}

class _FigmaSwitch extends StatelessWidget {
  final bool value;
  final ValueChanged<bool> onChanged;

  final Color trackOn;
  final Color trackOff;
  final Color knobOn;
  final Color knobOff;

  final AppSpacing space;

  const _FigmaSwitch({
    required this.value,
    required this.onChanged,
    required this.trackOn,
    required this.trackOff,
    required this.knobOn,
    required this.knobOff,
    required this.space,
  });

  @override
  Widget build(BuildContext context) {
    final trackW = dp(context, space.s40);
    final trackH = dp(context, space.s24);
    final knob = dp(context, space.s20);
    final pad = dp(context, space.s2);

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () => onChanged(!value),
      child: Container(
        width: trackW,
        height: trackH,
        decoration: BoxDecoration(
          color: value ? trackOn : trackOff,
          borderRadius: BorderRadius.circular(trackH / 2),
        ),
        padding: EdgeInsets.all(pad),
        child: Align(
          alignment: value ? Alignment.centerRight : Alignment.centerLeft,
          child: Container(
            width: knob,
            height: knob,
            decoration: BoxDecoration(
              color: value ? knobOn : knobOff,
              shape: BoxShape.circle,
            ),
          ),
        ),
      ),
    );
  }
}
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_en.dart';
import 'app_localizations_ru.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'generated/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, youвЂ™ll need to edit this
/// file.
///
/// First, open your projectвЂ™s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// projectвЂ™s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
    : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
        delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('en'),
    Locale('ru'),
  ];

  /// No description provided for @settings.
  ///
  /// In ru, this message translates to:
  /// **'РќР°СЃС‚СЂРѕР№РєРё'**
  String get settings;

  /// No description provided for @selectLanguage.
  ///
  /// In ru, this message translates to:
  /// **'Р’С‹Р±РѕСЂ СЏР·С‹РєР°'**
  String get selectLanguage;

  /// No description provided for @appTitle.
  ///
  /// In ru, this message translates to:
  /// **'Р”РЅРµРІРЅРёРє РґР°РІР»РµРЅРёСЏ'**
  String get appTitle;

  /// No description provided for @notifications.
  ///
  /// In ru, this message translates to:
  /// **'РЈРІРµРґРѕРјР»РµРЅРёСЏ'**
  String get notifications;

  /// No description provided for @clearData.
  ///
  /// In ru, this message translates to:
  /// **'РћС‡РёСЃС‚РёС‚СЊ РґР°РЅРЅС‹Рµ'**
  String get clearData;

  /// No description provided for @aboutApp.
  ///
  /// In ru, this message translates to:
  /// **'Рћ РїСЂРёР»РѕР¶РµРЅРёРё'**
  String get aboutApp;

  /// No description provided for @version.
  ///
  /// In ru, this message translates to:
  /// **'Р’РµСЂСЃРёСЏ {version}'**
  String version(String version);

  /// No description provided for @functionInDevelopment.
  ///
  /// In ru, this message translates to:
  /// **'Р¤СѓРЅРєС†РёСЏ РІ СЂР°Р·СЂР°Р±РѕС‚РєРµ'**
  String get functionInDevelopment;

  /// No description provided for @deleteRecordQ.
  ///
  /// In ru, this message translates to:
  /// **'РЈРґР°Р»РёС‚СЊ Р·Р°РїРёСЃСЊ?'**
  String get deleteRecordQ;

  /// No description provided for @cannotUndo.
  ///
  /// In ru, this message translates to:
  /// **'Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.'**
  String get cannotUndo;

  /// No description provided for @cancel.
  ///
  /// In ru, this message translates to:
  /// **'РћС‚РјРµРЅР°'**
  String get cancel;

  /// No description provided for @delete.
  ///
  /// In ru, this message translates to:
  /// **'РЈРґР°Р»РёС‚СЊ'**
  String get delete;

  /// No description provided for @theme.
  ///
  /// In ru, this message translates to:
  /// **'РўРµРјР°'**
  String get theme;

  /// No description provided for @language.
  ///
  /// In ru, this message translates to:
  /// **'РЇР·С‹Рє'**
  String get language;

  /// No description provided for @light.
  ///
  /// In ru, this message translates to:
  /// **'РЎРІРµС‚Р»Р°СЏ'**
  String get light;

  /// No description provided for @dark.
  ///
  /// In ru, this message translates to:
  /// **'РўРµРјРЅР°СЏ'**
  String get dark;

  /// No description provided for @system.
  ///
  /// In ru, this message translates to:
  /// **'РЎРёСЃС‚РµРјРЅР°СЏ'**
  String get system;

  /// No description provided for @reminders.
  ///
  /// In ru, this message translates to:
  /// **'РќР°РїРѕРјРёРЅР°РЅРёСЏ'**
  String get reminders;

  /// No description provided for @addReminder.
  ///
  /// In ru, this message translates to:
  /// **'Р”РѕР±Р°РІРёС‚СЊ РІСЂРµРјСЏ'**
  String get addReminder;

  /// No description provided for @clearDataConfirm.
  ///
  /// In ru, this message translates to:
  /// **'Р’С‹ СѓРІРµСЂРµРЅС‹, С‡С‚Рѕ С…РѕС‚РёС‚Рµ СѓРґР°Р»РёС‚СЊ РІСЃРµ Р·Р°РїРёСЃРё? Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.'**
  String get clearDataConfirm;

  /// No description provided for @yes.
  ///
  /// In ru, this message translates to:
  /// **'Р”Р°'**
  String get yes;

  /// No description provided for @no.
  ///
  /// In ru, this message translates to:
  /// **'РќРµС‚'**
  String get no;

  /// No description provided for @export.
  ///
  /// In ru, this message translates to:
  /// **'Р­РєСЃРїРѕСЂС‚ РґР°РЅРЅС‹С…'**
  String get export;

  /// No description provided for @exportCSV.
  ///
  /// In ru, this message translates to:
  /// **'CSV РўР°Р±Р»РёС†Р°'**
  String get exportCSV;

  /// No description provided for @exportPDF.
  ///
  /// In ru, this message translates to:
  /// **'PDF РћС‚С‡РµС‚'**
  String get exportPDF;

  /// No description provided for @contactSupport.
  ///
  /// In ru, this message translates to:
  /// **'РќР°РїРёСЃР°С‚СЊ РЅР°Рј'**
  String get contactSupport;

  /// No description provided for @rateApp.
  ///
  /// In ru, this message translates to:
  /// **'РћС†РµРЅРёС‚СЊ РїСЂРёР»РѕР¶РµРЅРёРµ'**
  String get rateApp;

  /// No description provided for @supportEmail.
  ///
  /// In ru, this message translates to:
  /// **'your_email@mail.com'**
  String get supportEmail;

  /// No description provided for @profile.
  ///
  /// In ru, this message translates to:
  /// **'РџСЂРѕС„РёР»СЊ'**
  String get profile;

  /// No description provided for @name.
  ///
  /// In ru, this message translates to:
  /// **'РРјСЏ'**
  String get name;

  /// No description provided for @age.
  ///
  /// In ru, this message translates to:
  /// **'Р’РѕР·СЂР°СЃС‚'**
  String get age;

  /// No description provided for @gender.
  ///
  /// In ru, this message translates to:
  /// **'РџРѕР»'**
  String get gender;

  /// No description provided for @weight.
  ///
  /// In ru, this message translates to:
  /// **'Р’РµСЃ'**
  String get weight;

  /// No description provided for @male.
  ///
  /// In ru, this message translates to:
  /// **'РњСѓР¶СЃРєРѕР№'**
  String get male;

  /// No description provided for @female.
  ///
  /// In ru, this message translates to:
  /// **'Р–РµРЅСЃРєРёР№'**
  String get female;

  /// No description provided for @other.
  ///
  /// In ru, this message translates to:
  /// **'Р”СЂСѓРіРѕР№'**
  String get other;

  /// No description provided for @myGoal.
  ///
  /// In ru, this message translates to:
  /// **'РњРѕСЏ С†РµР»СЊ'**
  String get myGoal;

  /// No description provided for @targetPressure.
  ///
  /// In ru, this message translates to:
  /// **'Р¦РµР»РµРІРѕРµ РґР°РІР»РµРЅРёРµ'**
  String get targetPressure;

  /// No description provided for @systolic.
  ///
  /// In ru, this message translates to:
  /// **'РЎРёСЃС‚РѕР»РёС‡РµСЃРєРѕРµ'**
  String get systolic;

  /// No description provided for @diastolic.
  ///
  /// In ru, this message translates to:
  /// **'Р”РёР°СЃС‚РѕР»РёС‡РµСЃРєРѕРµ'**
  String get diastolic;

  /// No description provided for @premium.
  ///
  /// In ru, this message translates to:
  /// **'РџСЂРµРјРёСѓРј'**
  String get premium;

  /// No description provided for @oneTimePayment.
  ///
  /// In ru, this message translates to:
  /// **'Р Р°Р·РѕРІС‹Р№ РїР»Р°С‚РµР¶ 2,99 в‚¬'**
  String get oneTimePayment;

  /// No description provided for @buyPremium.
  ///
  /// In ru, this message translates to:
  /// **'РљСѓРїРёС‚СЊ РџСЂРµРјРёСѓРј'**
  String get buyPremium;

  /// No description provided for @save.
  ///
  /// In ru, this message translates to:
  /// **'РЎРѕС…СЂР°РЅРёС‚СЊ'**
  String get save;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['en', 'ru'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'en':
      return AppLocalizationsEn();
    case 'ru':
      return AppLocalizationsRu();
  }

  throw FlutterError(
    'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
    'an issue with the localizations generation tool. Please file an issue '
    'on GitHub with a reproducible sample app and the gen-l10n configuration '
    'that was used.',
  );
}
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get settings => 'Settings';

  @override
  String get selectLanguage => 'Select Language';

  @override
  String get appTitle => 'Blood Pressure Diary';

  @override
  String get notifications => 'Notifications';

  @override
  String get clearData => 'Clear Data';

  @override
  String get aboutApp => 'About App';

  @override
  String version(String version) {
    return 'Version $version';
  }

  @override
  String get functionInDevelopment => 'Function in development';

  @override
  String get deleteRecordQ => 'Delete record?';

  @override
  String get cannotUndo => 'This action cannot be undone.';

  @override
  String get cancel => 'Cancel';

  @override
  String get delete => 'Delete';

  @override
  String get theme => 'Theme';

  @override
  String get language => 'РЇР·С‹Рє';

  @override
  String get light => 'Light';

  @override
  String get dark => 'Dark';

  @override
  String get system => 'System';

  @override
  String get reminders => 'Reminders';

  @override
  String get addReminder => 'Add time';

  @override
  String get clearDataConfirm =>
      'Are you sure you want to delete all records? This action cannot be undone.';

  @override
  String get yes => 'Yes';

  @override
  String get no => 'No';

  @override
  String get export => 'Export Data';

  @override
  String get exportCSV => 'CSV Spreadsheet';

  @override
  String get exportPDF => 'PDF Report';

  @override
  String get contactSupport => 'Contact Support';

  @override
  String get rateApp => 'Rate App';

  @override
  String get supportEmail => 'your_email@mail.com';

  @override
  String get profile => 'Profile';

  @override
  String get name => 'Name';

  @override
  String get age => 'Age';

  @override
  String get gender => 'Gender';

  @override
  String get weight => 'Weight';

  @override
  String get male => 'Male';

  @override
  String get female => 'Female';

  @override
  String get other => 'Other';

  @override
  String get myGoal => 'My Goal';

  @override
  String get targetPressure => 'Target Pressure';

  @override
  String get systolic => 'Systolic';

  @override
  String get diastolic => 'Diastolic';

  @override
  String get premium => 'Premium';

  @override
  String get oneTimePayment => 'One-time payment 2,99 в‚¬';

  @override
  String get buyPremium => 'Buy Premium';

  @override
  String get save => 'Save';
}
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Russian (`ru`).
class AppLocalizationsRu extends AppLocalizations {
  AppLocalizationsRu([String locale = 'ru']) : super(locale);

  @override
  String get settings => 'РќР°СЃС‚СЂРѕР№РєРё';

  @override
  String get selectLanguage => 'Р’С‹Р±РѕСЂ СЏР·С‹РєР°';

  @override
  String get appTitle => 'Р”РЅРµРІРЅРёРє РґР°РІР»РµРЅРёСЏ';

  @override
  String get notifications => 'РЈРІРµРґРѕРјР»РµРЅРёСЏ';

  @override
  String get clearData => 'РћС‡РёСЃС‚РёС‚СЊ РґР°РЅРЅС‹Рµ';

  @override
  String get aboutApp => 'Рћ РїСЂРёР»РѕР¶РµРЅРёРё';

  @override
  String version(String version) {
    return 'Р’РµСЂСЃРёСЏ $version';
  }

  @override
  String get functionInDevelopment => 'Р¤СѓРЅРєС†РёСЏ РІ СЂР°Р·СЂР°Р±РѕС‚РєРµ';

  @override
  String get deleteRecordQ => 'РЈРґР°Р»РёС‚СЊ Р·Р°РїРёСЃСЊ?';

  @override
  String get cannotUndo => 'Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.';

  @override
  String get cancel => 'РћС‚РјРµРЅР°';

  @override
  String get delete => 'РЈРґР°Р»РёС‚СЊ';

  @override
  String get theme => 'РўРµРјР°';

  @override
  String get language => 'РЇР·С‹Рє';

  @override
  String get light => 'РЎРІРµС‚Р»Р°СЏ';

  @override
  String get dark => 'РўРµРјРЅР°СЏ';

  @override
  String get system => 'РЎРёСЃС‚РµРјРЅР°СЏ';

  @override
  String get reminders => 'РќР°РїРѕРјРёРЅР°РЅРёСЏ';

  @override
  String get addReminder => 'Р”РѕР±Р°РІРёС‚СЊ РІСЂРµРјСЏ';

  @override
  String get clearDataConfirm =>
      'Р’С‹ СѓРІРµСЂРµРЅС‹, С‡С‚Рѕ С…РѕС‚РёС‚Рµ СѓРґР°Р»РёС‚СЊ РІСЃРµ Р·Р°РїРёСЃРё? Р­С‚Рѕ РґРµР№СЃС‚РІРёРµ РЅРµР»СЊР·СЏ РѕС‚РјРµРЅРёС‚СЊ.';

  @override
  String get yes => 'Р”Р°';

  @override
  String get no => 'РќРµС‚';

  @override
  String get export => 'Р­РєСЃРїРѕСЂС‚ РґР°РЅРЅС‹С…';

  @override
  String get exportCSV => 'CSV РўР°Р±Р»РёС†Р°';

  @override
  String get exportPDF => 'PDF РћС‚С‡РµС‚';

  @override
  String get contactSupport => 'РќР°РїРёСЃР°С‚СЊ РЅР°Рј';

  @override
  String get rateApp => 'РћС†РµРЅРёС‚СЊ РїСЂРёР»РѕР¶РµРЅРёРµ';

  @override
  String get supportEmail => 'your_email@mail.com';

  @override
  String get profile => 'РџСЂРѕС„РёР»СЊ';

  @override
  String get name => 'РРјСЏ';

  @override
  String get age => 'Р’РѕР·СЂР°СЃС‚';

  @override
  String get gender => 'РџРѕР»';

  @override
  String get weight => 'Р’РµСЃ';

  @override
  String get male => 'РњСѓР¶СЃРєРѕР№';

  @override
  String get female => 'Р–РµРЅСЃРєРёР№';

  @override
  String get other => 'Р”СЂСѓРіРѕР№';

  @override
  String get myGoal => 'РњРѕСЏ С†РµР»СЊ';

  @override
  String get targetPressure => 'Р¦РµР»РµРІРѕРµ РґР°РІР»РµРЅРёРµ';

  @override
  String get systolic => 'РЎРёСЃС‚РѕР»РёС‡РµСЃРєРѕРµ';

  @override
  String get diastolic => 'Р”РёР°СЃС‚РѕР»РёС‡РµСЃРєРѕРµ';

  @override
  String get premium => 'РџСЂРµРјРёСѓРј';

  @override
  String get oneTimePayment => 'Р Р°Р·РѕРІС‹Р№ РїР»Р°С‚РµР¶ 2,99 в‚¬';

  @override
  String get buyPremium => 'РљСѓРїРёС‚СЊ РџСЂРµРјРёСѓРј';

  @override
  String get save => 'РЎРѕС…СЂР°РЅРёС‚СЊ';
}
import 'package:flutter/material.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:blood_pressure_diary/core/di/service_locator.dart';
import 'package:blood_pressure_diary/core/theme/app_theme.dart';
import 'package:blood_pressure_diary/core/navigation/app_navigation.dart';
import 'package:blood_pressure_diary/features/home/data/blood_pressure_model.dart';
import 'package:blood_pressure_diary/features/settings/data/models/settings_model.dart';
import 'package:blood_pressure_diary/core/database/models/user_profile.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_cubit.dart';
import 'package:blood_pressure_diary/features/settings/presentation/bloc/settings_state.dart';
import 'package:blood_pressure_diary/l10n/generated/app_localizations.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  final dir = await getApplicationDocumentsDirectory();
  final isar = await Isar.open(
    [BloodPressureRecordSchema, AppSettingsSchema, UserProfileSchema],
    directory: dir.path,
  );

  await setupLocator(isar);
  await initializeDateFormatting('ru');

  runApp(const BloodPressureApp());
}

class BloodPressureApp extends StatelessWidget {
  const BloodPressureApp({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => getIt<SettingsCubit>(),
      child: BlocBuilder<SettingsCubit, SettingsState>(
        builder: (context, state) {
          return MaterialApp(
            debugShowCheckedModeBanner: false,
            onGenerateTitle: (context) => AppLocalizations.of(context)!.appTitle,
            theme: AppTheme.lightTheme,
            darkTheme: AppTheme.darkTheme,
            themeMode: _getThemeMode(state.settings.themeMode),
            locale: Locale(state.settings.languageCode),
            localizationsDelegates: const [
              AppLocalizations.delegate,
              GlobalMaterialLocalizations.delegate,
              GlobalWidgetsLocalizations.delegate,
              GlobalCupertinoLocalizations.delegate,
            ],
            supportedLocales: AppLocalizations.supportedLocales,

            // вњ… Р¤РёРєСЃРёСЂСѓРµРј СЃРёСЃС‚РµРјРЅС‹Р№ РјР°СЃС€С‚Р°Р± С€СЂРёС„С‚Р° (РґР»СЏ РїРёРєСЃРµР»СЊ-РїРµСЂС„РµРєС‚Р°)
            builder: (context, child) {
              final mq = MediaQuery.of(context);
              return MediaQuery(
                data: mq.copyWith(
                  textScaler: const TextScaler.linear(1.0),
                ),
                child: child ?? const SizedBox.shrink(),
              );
            },

            home: const AppNavigation(),
          );
        },
      ),
    );
  }

  ThemeMode _getThemeMode(AppThemeMode mode) {
    switch (mode) {
      case AppThemeMode.light:
        return ThemeMode.light;
      case AppThemeMode.dark:
        return ThemeMode.dark;
      case AppThemeMode.system:
        return ThemeMode.system;
    }
  }
}
